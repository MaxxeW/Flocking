/*! Flocking 0.2.0, Copyright 2017 Colin Clark | flockingjs.org */


!function(e, t) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e);
    } : t(e);
}("undefined" != typeof window ? window : this, function(e, t) {
    function n(e) {
        var t = !!e && "length" in e && e.length, n = re.type(e);
        return "function" !== n && !re.isWindow(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e);
    }
    function r(e, t, n) {
        if (re.isFunction(t)) return re.grep(e, function(e, r) {
            return !!t.call(e, r, e) !== n;
        });
        if (t.nodeType) return re.grep(e, function(e) {
            return e === t !== n;
        });
        if ("string" == typeof t) {
            if (pe.test(t)) return re.filter(t, e, n);
            t = re.filter(t, e);
        }
        return re.grep(e, function(e) {
            return Y.call(t, e) > -1 !== n;
        });
    }
    function o(e, t) {
        for (;(e = e[t]) && 1 !== e.nodeType; ) ;
        return e;
    }
    function a(e) {
        var t = {};
        return re.each(e.match(ye) || [], function(e, n) {
            t[n] = !0;
        }), t;
    }
    function i() {
        K.removeEventListener("DOMContentLoaded", i), e.removeEventListener("load", i), 
        re.ready();
    }
    function u() {
        this.expando = re.expando + u.uid++;
    }
    function s(e, t, n) {
        var r;
        if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(Ae, "-$&").toLowerCase(), 
        "string" == typeof (n = e.getAttribute(r))) {
            try {
                n = "true" === n || "false" !== n && ("null" === n ? null : +n + "" === n ? +n : Ce.test(n) ? re.parseJSON(n) : n);
            } catch (e) {}
            we.set(e, t, n);
        } else n = void 0;
        return n;
    }
    function l(e, t, n, r) {
        var o, a = 1, i = 20, u = r ? function() {
            return r.cur();
        } : function() {
            return re.css(e, t, "");
        }, s = u(), l = n && n[3] || (re.cssNumber[t] ? "" : "px"), c = (re.cssNumber[t] || "px" !== l && +s) && Te.exec(re.css(e, t));
        if (c && c[3] !== l) {
            l = l || c[3], n = n || [], c = +s || 1;
            do {
                c /= a = a || ".5", re.style(e, t, c + l);
            } while (a !== (a = u() / s) && 1 !== a && --i);
        }
        return n && (c = +c || +s || 0, o = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, 
        r.start = c, r.end = o)), o;
    }
    function c(e, t) {
        var n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
        return void 0 === t || t && re.nodeName(e, t) ? re.merge([ e ], n) : n;
    }
    function f(e, t) {
        for (var n = 0, r = e.length; n < r; n++) Se.set(e[n], "globalEval", !t || Se.get(t[n], "globalEval"));
    }
    function d(e, t, n, r, o) {
        for (var a, i, u, s, l, d, p = t.createDocumentFragment(), m = [], g = 0, h = e.length; g < h; g++) if ((a = e[g]) || 0 === a) if ("object" === re.type(a)) re.merge(m, a.nodeType ? [ a ] : a); else if (Re.test(a)) {
            for (i = i || p.appendChild(t.createElement("div")), u = (Oe.exec(a) || [ "", "" ])[1].toLowerCase(), 
            s = Le[u] || Le._default, i.innerHTML = s[1] + re.htmlPrefilter(a) + s[2], d = s[0]; d--; ) i = i.lastChild;
            re.merge(m, i.childNodes), (i = p.firstChild).textContent = "";
        } else m.push(t.createTextNode(a));
        for (p.textContent = "", g = 0; a = m[g++]; ) if (r && re.inArray(a, r) > -1) o && o.push(a); else if (l = re.contains(a.ownerDocument, a), 
        i = c(p.appendChild(a), "script"), l && f(i), n) for (d = 0; a = i[d++]; ) De.test(a.type || "") && n.push(a);
        return p;
    }
    function p() {
        return !0;
    }
    function m() {
        return !1;
    }
    function g() {
        try {
            return K.activeElement;
        } catch (e) {}
    }
    function h(e, t, n, r, o, a) {
        var i, u;
        if ("object" == typeof t) {
            "string" != typeof n && (r = r || n, n = void 0);
            for (u in t) h(e, u, n, r, t[u], a);
            return e;
        }
        if (null == r && null == o ? (o = n, r = n = void 0) : null == o && ("string" == typeof n ? (o = r, 
        r = void 0) : (o = r, r = n, n = void 0)), !1 === o) o = m; else if (!o) return e;
        return 1 === a && (i = o, (o = function(e) {
            return re().off(e), i.apply(this, arguments);
        }).guid = i.guid || (i.guid = re.guid++)), e.each(function() {
            re.event.add(this, t, o, r, n);
        });
    }
    function v(e, t) {
        return re.nodeName(e, "table") && re.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e;
    }
    function y(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e;
    }
    function k(e) {
        var t = Ge.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"), e;
    }
    function b(e, t) {
        var n, r, o, a, i, u, s, l;
        if (1 === t.nodeType) {
            if (Se.hasData(e) && (a = Se.access(e), i = Se.set(t, a), l = a.events)) {
                delete i.handle, i.events = {};
                for (o in l) for (n = 0, r = l[o].length; n < r; n++) re.event.add(t, o, l[o][n]);
            }
            we.hasData(e) && (u = we.access(e), s = re.extend({}, u), we.set(t, s));
        }
    }
    function x(e, t) {
        var n = t.nodeName.toLowerCase();
        "input" === n && Pe.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue);
    }
    function S(e, t, n, r) {
        t = J.apply([], t);
        var o, a, i, u, s, l, f = 0, p = e.length, m = p - 1, g = t[0], h = re.isFunction(g);
        if (h || p > 1 && "string" == typeof g && !ne.checkClone && _e.test(g)) return e.each(function(o) {
            var a = e.eq(o);
            h && (t[0] = g.call(this, o, a.html())), S(a, t, n, r);
        });
        if (p && (o = d(t, e[0].ownerDocument, !1, e, r), a = o.firstChild, 1 === o.childNodes.length && (o = a), 
        a || r)) {
            for (u = (i = re.map(c(o, "script"), y)).length; f < p; f++) s = o, f !== m && (s = re.clone(s, !0, !0), 
            u && re.merge(i, c(s, "script"))), n.call(e[f], s, f);
            if (u) for (l = i[i.length - 1].ownerDocument, re.map(i, k), f = 0; f < u; f++) s = i[f], 
            De.test(s.type || "") && !Se.access(s, "globalEval") && re.contains(l, s) && (s.src ? re._evalUrl && re._evalUrl(s.src) : re.globalEval(s.textContent.replace(je, "")));
        }
        return e;
    }
    function w(e, t, n) {
        for (var r, o = t ? re.filter(t, e) : e, a = 0; null != (r = o[a]); a++) n || 1 !== r.nodeType || re.cleanData(c(r)), 
        r.parentNode && (n && re.contains(r.ownerDocument, r) && f(c(r, "script")), r.parentNode.removeChild(r));
        return e;
    }
    function C(e, t) {
        var n = re(t.createElement(e)).appendTo(t.body), r = re.css(n[0], "display");
        return n.detach(), r;
    }
    function A(e) {
        var t = K, n = He[e];
        return n || ("none" !== (n = C(e, t)) && n || ((t = (Ue = (Ue || re("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement))[0].contentDocument).write(), 
        t.close(), n = C(e, t), Ue.detach()), He[e] = n), n;
    }
    function N(e, t, n) {
        var r, o, a, i, u = e.style;
        return n = n || $e(e), "" !== (i = n ? n.getPropertyValue(t) || n[t] : void 0) && void 0 !== i || re.contains(e.ownerDocument, e) || (i = re.style(e, t)), 
        n && !ne.pixelMarginRight() && ze.test(i) && We.test(t) && (r = u.width, o = u.minWidth, 
        a = u.maxWidth, u.minWidth = u.maxWidth = u.width = i, i = n.width, u.width = r, 
        u.minWidth = o, u.maxWidth = a), void 0 !== i ? i + "" : i;
    }
    function T(e, t) {
        return {
            get: function() {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get;
            }
        };
    }
    function I(e) {
        if (e in et) return e;
        for (var t = e[0].toUpperCase() + e.slice(1), n = Ze.length; n--; ) if ((e = Ze[n] + t) in et) return e;
    }
    function M(e, t, n) {
        var r = Te.exec(t);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t;
    }
    function P(e, t, n, r, o) {
        for (var a = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, i = 0; a < 4; a += 2) "margin" === n && (i += re.css(e, n + Ie[a], !0, o)), 
        r ? ("content" === n && (i -= re.css(e, "padding" + Ie[a], !0, o)), "margin" !== n && (i -= re.css(e, "border" + Ie[a] + "Width", !0, o))) : (i += re.css(e, "padding" + Ie[a], !0, o), 
        "padding" !== n && (i += re.css(e, "border" + Ie[a] + "Width", !0, o)));
        return i;
    }
    function O(e, t, n) {
        var r = !0, o = "width" === t ? e.offsetWidth : e.offsetHeight, a = $e(e), i = "border-box" === re.css(e, "boxSizing", !1, a);
        if (o <= 0 || null == o) {
            if (((o = N(e, t, a)) < 0 || null == o) && (o = e.style[t]), ze.test(o)) return o;
            r = i && (ne.boxSizingReliable() || o === e.style[t]), o = parseFloat(o) || 0;
        }
        return o + P(e, t, n || (i ? "border" : "content"), r, a) + "px";
    }
    function D(e, t) {
        for (var n, r, o, a = [], i = 0, u = e.length; i < u; i++) (r = e[i]).style && (a[i] = Se.get(r, "olddisplay"), 
        n = r.style.display, t ? (a[i] || "none" !== n || (r.style.display = ""), "" === r.style.display && Me(r) && (a[i] = Se.access(r, "olddisplay", A(r.nodeName)))) : (o = Me(r), 
        "none" === n && o || Se.set(r, "olddisplay", o ? n : re.css(r, "display"))));
        for (i = 0; i < u; i++) (r = e[i]).style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? a[i] || "" : "none"));
        return e;
    }
    function L(e, t, n, r, o) {
        return new L.prototype.init(e, t, n, r, o);
    }
    function R() {
        return e.setTimeout(function() {
            tt = void 0;
        }), tt = re.now();
    }
    function E(e, t) {
        var n, r = 0, o = {
            height: e
        };
        for (t = t ? 1 : 0; r < 4; r += 2 - t) o["margin" + (n = Ie[r])] = o["padding" + n] = e;
        return t && (o.opacity = o.width = e), o;
    }
    function V(e, t, n) {
        for (var r, o = (q.tweeners[t] || []).concat(q.tweeners["*"]), a = 0, i = o.length; a < i; a++) if (r = o[a].call(n, t, e)) return r;
    }
    function F(e, t) {
        var n, r, o, a, i;
        for (n in e) if (r = re.camelCase(n), o = t[r], a = e[n], re.isArray(a) && (o = a[1], 
        a = e[n] = a[0]), n !== r && (e[r] = a, delete e[n]), (i = re.cssHooks[r]) && "expand" in i) {
            a = i.expand(a), delete e[r];
            for (n in a) n in e || (e[n] = a[n], t[n] = o);
        } else t[r] = o;
    }
    function q(e, t, n) {
        var r, o, a = 0, i = q.prefilters.length, u = re.Deferred().always(function() {
            delete s.elem;
        }), s = function() {
            if (o) return !1;
            for (var t = tt || R(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), a = 0, i = l.tweens.length; a < i; a++) l.tweens[a].run(r);
            return u.notifyWith(e, [ l, r, n ]), r < 1 && i ? n : (u.resolveWith(e, [ l ]), 
            !1);
        }, l = u.promise({
            elem: e,
            props: re.extend({}, t),
            opts: re.extend(!0, {
                specialEasing: {},
                easing: re.easing._default
            }, n),
            originalProperties: t,
            originalOptions: n,
            startTime: tt || R(),
            duration: n.duration,
            tweens: [],
            createTween: function(t, n) {
                var r = re.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing);
                return l.tweens.push(r), r;
            },
            stop: function(t) {
                var n = 0, r = t ? l.tweens.length : 0;
                if (o) return this;
                for (o = !0; n < r; n++) l.tweens[n].run(1);
                return t ? (u.notifyWith(e, [ l, 1, 0 ]), u.resolveWith(e, [ l, t ])) : u.rejectWith(e, [ l, t ]), 
                this;
            }
        }), c = l.props;
        for (F(c, l.opts.specialEasing); a < i; a++) if (r = q.prefilters[a].call(l, e, c, l.opts)) return re.isFunction(r.stop) && (re._queueHooks(l.elem, l.opts.queue).stop = re.proxy(r.stop, r)), 
        r;
        return re.map(c, V, l), re.isFunction(l.opts.start) && l.opts.start.call(e, l), 
        re.fx.timer(re.extend(s, {
            elem: e,
            anim: l,
            queue: l.opts.queue
        })), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always);
    }
    function B(e) {
        return e.getAttribute && e.getAttribute("class") || "";
    }
    function _(e) {
        return function(t, n) {
            "string" != typeof t && (n = t, t = "*");
            var r, o = 0, a = t.toLowerCase().match(ye) || [];
            if (re.isFunction(n)) for (;r = a[o++]; ) "+" === r[0] ? (r = r.slice(1) || "*", 
            (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n);
        };
    }
    function G(e, t, n, r) {
        function o(u) {
            var s;
            return a[u] = !0, re.each(e[u] || [], function(e, u) {
                var l = u(t, n, r);
                return "string" != typeof l || i || a[l] ? i ? !(s = l) : void 0 : (t.dataTypes.unshift(l), 
                o(l), !1);
            }), s;
        }
        var a = {}, i = e === wt;
        return o(t.dataTypes[0]) || !a["*"] && o("*");
    }
    function j(e, t) {
        var n, r, o = re.ajaxSettings.flatOptions || {};
        for (n in t) void 0 !== t[n] && ((o[n] ? e : r || (r = {}))[n] = t[n]);
        return r && re.extend(!0, e, r), e;
    }
    function U(e, t, n) {
        for (var r, o, a, i, u = e.contents, s = e.dataTypes; "*" === s[0]; ) s.shift(), 
        void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
        if (r) for (o in u) if (u[o] && u[o].test(r)) {
            s.unshift(o);
            break;
        }
        if (s[0] in n) a = s[0]; else {
            for (o in n) {
                if (!s[0] || e.converters[o + " " + s[0]]) {
                    a = o;
                    break;
                }
                i || (i = o);
            }
            a = a || i;
        }
        if (a) return a !== s[0] && s.unshift(a), n[a];
    }
    function H(e, t, n, r) {
        var o, a, i, u, s, l = {}, c = e.dataTypes.slice();
        if (c[1]) for (i in e.converters) l[i.toLowerCase()] = e.converters[i];
        for (a = c.shift(); a; ) if (e.responseFields[a] && (n[e.responseFields[a]] = t), 
        !s && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), s = a, a = c.shift()) if ("*" === a) a = s; else if ("*" !== s && s !== a) {
            if (!(i = l[s + " " + a] || l["* " + a])) for (o in l) if ((u = o.split(" "))[1] === a && (i = l[s + " " + u[0]] || l["* " + u[0]])) {
                !0 === i ? i = l[o] : !0 !== l[o] && (a = u[0], c.unshift(u[1]));
                break;
            }
            if (!0 !== i) if (i && e.throws) t = i(t); else try {
                t = i(t);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: i ? e : "No conversion from " + s + " to " + a
                };
            }
        }
        return {
            state: "success",
            data: t
        };
    }
    function W(e, t, n, r) {
        var o;
        if (re.isArray(t)) re.each(t, function(t, o) {
            n || Tt.test(e) ? r(e, o) : W(e + "[" + ("object" == typeof o && null != o ? t : "") + "]", o, n, r);
        }); else if (n || "object" !== re.type(t)) r(e, t); else for (o in t) W(e + "[" + o + "]", t[o], n, r);
    }
    function z(e) {
        return re.isWindow(e) ? e : 9 === e.nodeType && e.defaultView;
    }
    var $ = [], K = e.document, X = $.slice, J = $.concat, Q = $.push, Y = $.indexOf, Z = {}, ee = Z.toString, te = Z.hasOwnProperty, ne = {}, re = function(e, t) {
        return new re.fn.init(e, t);
    }, oe = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ae = /^-ms-/, ie = /-([\da-z])/gi, ue = function(e, t) {
        return t.toUpperCase();
    };
    re.fn = re.prototype = {
        jquery: "2.2.4",
        constructor: re,
        selector: "",
        length: 0,
        toArray: function() {
            return X.call(this);
        },
        get: function(e) {
            return null != e ? e < 0 ? this[e + this.length] : this[e] : X.call(this);
        },
        pushStack: function(e) {
            var t = re.merge(this.constructor(), e);
            return t.prevObject = this, t.context = this.context, t;
        },
        each: function(e) {
            return re.each(this, e);
        },
        map: function(e) {
            return this.pushStack(re.map(this, function(t, n) {
                return e.call(t, n, t);
            }));
        },
        slice: function() {
            return this.pushStack(X.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(e) {
            var t = this.length, n = +e + (e < 0 ? t : 0);
            return this.pushStack(n >= 0 && n < t ? [ this[n] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: Q,
        sort: $.sort,
        splice: $.splice
    }, re.extend = re.fn.extend = function() {
        var e, t, n, r, o, a, i = arguments[0] || {}, u = 1, s = arguments.length, l = !1;
        for ("boolean" == typeof i && (l = i, i = arguments[u] || {}, u++), "object" == typeof i || re.isFunction(i) || (i = {}), 
        u === s && (i = this, u--); u < s; u++) if (null != (e = arguments[u])) for (t in e) n = i[t], 
        i !== (r = e[t]) && (l && r && (re.isPlainObject(r) || (o = re.isArray(r))) ? (o ? (o = !1, 
        a = n && re.isArray(n) ? n : []) : a = n && re.isPlainObject(n) ? n : {}, i[t] = re.extend(l, a, r)) : void 0 !== r && (i[t] = r));
        return i;
    }, re.extend({
        expando: "jQuery" + ("2.2.4" + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) {
            throw new Error(e);
        },
        noop: function() {},
        isFunction: function(e) {
            return "function" === re.type(e);
        },
        isArray: Array.isArray,
        isWindow: function(e) {
            return null != e && e === e.window;
        },
        isNumeric: function(e) {
            var t = e && e.toString();
            return !re.isArray(e) && t - parseFloat(t) + 1 >= 0;
        },
        isPlainObject: function(e) {
            var t;
            if ("object" !== re.type(e) || e.nodeType || re.isWindow(e)) return !1;
            if (e.constructor && !te.call(e, "constructor") && !te.call(e.constructor.prototype || {}, "isPrototypeOf")) return !1;
            for (t in e) ;
            return void 0 === t || te.call(e, t);
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e) return !1;
            return !0;
        },
        type: function(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? Z[ee.call(e)] || "object" : typeof e;
        },
        globalEval: function(e) {
            var t, n = eval;
            (e = re.trim(e)) && (1 === e.indexOf("use strict") ? ((t = K.createElement("script")).text = e, 
            K.head.appendChild(t).parentNode.removeChild(t)) : n(e));
        },
        camelCase: function(e) {
            return e.replace(ae, "ms-").replace(ie, ue);
        },
        nodeName: function(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
        },
        each: function(e, t) {
            var r, o = 0;
            if (n(e)) for (r = e.length; o < r && !1 !== t.call(e[o], o, e[o]); o++) ; else for (o in e) if (!1 === t.call(e[o], o, e[o])) break;
            return e;
        },
        trim: function(e) {
            return null == e ? "" : (e + "").replace(oe, "");
        },
        makeArray: function(e, t) {
            var r = t || [];
            return null != e && (n(Object(e)) ? re.merge(r, "string" == typeof e ? [ e ] : e) : Q.call(r, e)), 
            r;
        },
        inArray: function(e, t, n) {
            return null == t ? -1 : Y.call(t, e, n);
        },
        merge: function(e, t) {
            for (var n = +t.length, r = 0, o = e.length; r < n; r++) e[o++] = t[r];
            return e.length = o, e;
        },
        grep: function(e, t, n) {
            for (var r = [], o = 0, a = e.length, i = !n; o < a; o++) !t(e[o], o) !== i && r.push(e[o]);
            return r;
        },
        map: function(e, t, r) {
            var o, a, i = 0, u = [];
            if (n(e)) for (o = e.length; i < o; i++) null != (a = t(e[i], i, r)) && u.push(a); else for (i in e) null != (a = t(e[i], i, r)) && u.push(a);
            return J.apply([], u);
        },
        guid: 1,
        proxy: function(e, t) {
            var n, r, o;
            if ("string" == typeof t && (n = e[t], t = e, e = n), re.isFunction(e)) return r = X.call(arguments, 2), 
            o = function() {
                return e.apply(t || this, r.concat(X.call(arguments)));
            }, o.guid = e.guid = e.guid || re.guid++, o;
        },
        now: Date.now,
        support: ne
    }), "function" == typeof Symbol && (re.fn[Symbol.iterator] = $[Symbol.iterator]), 
    re.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
        Z["[object " + t + "]"] = t.toLowerCase();
    });
    var se = function(e) {
        function t(e, t, n, r) {
            var o, a, i, u, l, f, d, p, m = t && t.ownerDocument, g = t ? t.nodeType : 9;
            if (n = n || [], "string" != typeof e || !e || 1 !== g && 9 !== g && 11 !== g) return n;
            if (!r && ((t ? t.ownerDocument || t : q) !== P && M(t), t = t || P, D)) {
                if (11 !== g && (f = ge.exec(e))) if (o = f[1]) {
                    if (9 === g) {
                        if (!(i = t.getElementById(o))) return n;
                        if (i.id === o) return n.push(i), n;
                    } else if (m && (i = m.getElementById(o)) && V(t, i) && i.id === o) return n.push(i), 
                    n;
                } else {
                    if (f[2]) return J.apply(n, t.getElementsByTagName(e)), n;
                    if ((o = f[3]) && k.getElementsByClassName && t.getElementsByClassName) return J.apply(n, t.getElementsByClassName(o)), 
                    n;
                }
                if (k.qsa && !U[e + " "] && (!L || !L.test(e))) {
                    if (1 !== g) m = t, p = e; else if ("object" !== t.nodeName.toLowerCase()) {
                        for ((u = t.getAttribute("id")) ? u = u.replace(ve, "\\$&") : t.setAttribute("id", u = F), 
                        a = (d = w(e)).length, l = ce.test(u) ? "#" + u : "[id='" + u + "']"; a--; ) d[a] = l + " " + c(d[a]);
                        p = d.join(","), m = he.test(e) && s(t.parentNode) || t;
                    }
                    if (p) try {
                        return J.apply(n, m.querySelectorAll(p)), n;
                    } catch (e) {} finally {
                        u === F && t.removeAttribute("id");
                    }
                }
            }
            return A(e.replace(ae, "$1"), t, n, r);
        }
        function n() {
            function e(n, r) {
                return t.push(n + " ") > b.cacheLength && delete e[t.shift()], e[n + " "] = r;
            }
            var t = [];
            return e;
        }
        function r(e) {
            return e[F] = !0, e;
        }
        function o(e) {
            var t = P.createElement("div");
            try {
                return !!e(t);
            } catch (e) {
                return !1;
            } finally {
                t.parentNode && t.parentNode.removeChild(t), t = null;
            }
        }
        function a(e, t) {
            for (var n = e.split("|"), r = n.length; r--; ) b.attrHandle[n[r]] = t;
        }
        function i(e, t) {
            var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || W) - (~e.sourceIndex || W);
            if (r) return r;
            if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
            return e ? 1 : -1;
        }
        function u(e) {
            return r(function(t) {
                return t = +t, r(function(n, r) {
                    for (var o, a = e([], n.length, t), i = a.length; i--; ) n[o = a[i]] && (n[o] = !(r[o] = n[o]));
                });
            });
        }
        function s(e) {
            return e && void 0 !== e.getElementsByTagName && e;
        }
        function l() {}
        function c(e) {
            for (var t = 0, n = e.length, r = ""; t < n; t++) r += e[t].value;
            return r;
        }
        function f(e, t, n) {
            var r = t.dir, o = n && "parentNode" === r, a = _++;
            return t.first ? function(t, n, a) {
                for (;t = t[r]; ) if (1 === t.nodeType || o) return e(t, n, a);
            } : function(t, n, i) {
                var u, s, l, c = [ B, a ];
                if (i) {
                    for (;t = t[r]; ) if ((1 === t.nodeType || o) && e(t, n, i)) return !0;
                } else for (;t = t[r]; ) if (1 === t.nodeType || o) {
                    if (l = t[F] || (t[F] = {}), s = l[t.uniqueID] || (l[t.uniqueID] = {}), (u = s[r]) && u[0] === B && u[1] === a) return c[2] = u[2];
                    if (s[r] = c, c[2] = e(t, n, i)) return !0;
                }
            };
        }
        function d(e) {
            return e.length > 1 ? function(t, n, r) {
                for (var o = e.length; o--; ) if (!e[o](t, n, r)) return !1;
                return !0;
            } : e[0];
        }
        function p(e, n, r) {
            for (var o = 0, a = n.length; o < a; o++) t(e, n[o], r);
            return r;
        }
        function m(e, t, n, r, o) {
            for (var a, i = [], u = 0, s = e.length, l = null != t; u < s; u++) (a = e[u]) && (n && !n(a, r, o) || (i.push(a), 
            l && t.push(u)));
            return i;
        }
        function g(e, t, n, o, a, i) {
            return o && !o[F] && (o = g(o)), a && !a[F] && (a = g(a, i)), r(function(r, i, u, s) {
                var l, c, f, d = [], g = [], h = i.length, v = r || p(t || "*", u.nodeType ? [ u ] : u, []), y = !e || !r && t ? v : m(v, d, e, u, s), k = n ? a || (r ? e : h || o) ? [] : i : y;
                if (n && n(y, k, u, s), o) for (l = m(k, g), o(l, [], u, s), c = l.length; c--; ) (f = l[c]) && (k[g[c]] = !(y[g[c]] = f));
                if (r) {
                    if (a || e) {
                        if (a) {
                            for (l = [], c = k.length; c--; ) (f = k[c]) && l.push(y[c] = f);
                            a(null, k = [], l, s);
                        }
                        for (c = k.length; c--; ) (f = k[c]) && (l = a ? Y(r, f) : d[c]) > -1 && (r[l] = !(i[l] = f));
                    }
                } else k = m(k === i ? k.splice(h, k.length) : k), a ? a(null, i, k, s) : J.apply(i, k);
            });
        }
        function h(e) {
            for (var t, n, r, o = e.length, a = b.relative[e[0].type], i = a || b.relative[" "], u = a ? 1 : 0, s = f(function(e) {
                return e === t;
            }, i, !0), l = f(function(e) {
                return Y(t, e) > -1;
            }, i, !0), p = [ function(e, n, r) {
                var o = !a && (r || n !== N) || ((t = n).nodeType ? s(e, n, r) : l(e, n, r));
                return t = null, o;
            } ]; u < o; u++) if (n = b.relative[e[u].type]) p = [ f(d(p), n) ]; else {
                if ((n = b.filter[e[u].type].apply(null, e[u].matches))[F]) {
                    for (r = ++u; r < o && !b.relative[e[r].type]; r++) ;
                    return g(u > 1 && d(p), u > 1 && c(e.slice(0, u - 1).concat({
                        value: " " === e[u - 2].type ? "*" : ""
                    })).replace(ae, "$1"), n, u < r && h(e.slice(u, r)), r < o && h(e = e.slice(r)), r < o && c(e));
                }
                p.push(n);
            }
            return d(p);
        }
        function v(e, n) {
            var o = n.length > 0, a = e.length > 0, i = function(r, i, u, s, l) {
                var c, f, d, p = 0, g = "0", h = r && [], v = [], y = N, k = r || a && b.find.TAG("*", l), x = B += null == y ? 1 : Math.random() || .1, S = k.length;
                for (l && (N = i === P || i || l); g !== S && null != (c = k[g]); g++) {
                    if (a && c) {
                        for (f = 0, i || c.ownerDocument === P || (M(c), u = !D); d = e[f++]; ) if (d(c, i || P, u)) {
                            s.push(c);
                            break;
                        }
                        l && (B = x);
                    }
                    o && ((c = !d && c) && p--, r && h.push(c));
                }
                if (p += g, o && g !== p) {
                    for (f = 0; d = n[f++]; ) d(h, v, i, u);
                    if (r) {
                        if (p > 0) for (;g--; ) h[g] || v[g] || (v[g] = K.call(s));
                        v = m(v);
                    }
                    J.apply(s, v), l && !r && v.length > 0 && p + n.length > 1 && t.uniqueSort(s);
                }
                return l && (B = x, N = y), h;
            };
            return o ? r(i) : i;
        }
        var y, k, b, x, S, w, C, A, N, T, I, M, P, O, D, L, R, E, V, F = "sizzle" + 1 * new Date(), q = e.document, B = 0, _ = 0, G = n(), j = n(), U = n(), H = function(e, t) {
            return e === t && (I = !0), 0;
        }, W = 1 << 31, z = {}.hasOwnProperty, $ = [], K = $.pop, X = $.push, J = $.push, Q = $.slice, Y = function(e, t) {
            for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
            return -1;
        }, Z = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", ee = "[\\x20\\t\\r\\n\\f]", te = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", ne = "\\[" + ee + "*(" + te + ")(?:" + ee + "*([*^$|!~]?=)" + ee + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + te + "))|)" + ee + "*\\]", re = ":(" + te + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ne + ")*)|.*)\\)|)", oe = new RegExp(ee + "+", "g"), ae = new RegExp("^" + ee + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ee + "+$", "g"), ie = new RegExp("^" + ee + "*," + ee + "*"), ue = new RegExp("^" + ee + "*([>+~]|" + ee + ")" + ee + "*"), se = new RegExp("=" + ee + "*([^\\]'\"]*?)" + ee + "*\\]", "g"), le = new RegExp(re), ce = new RegExp("^" + te + "$"), fe = {
            ID: new RegExp("^#(" + te + ")"),
            CLASS: new RegExp("^\\.(" + te + ")"),
            TAG: new RegExp("^(" + te + "|[*])"),
            ATTR: new RegExp("^" + ne),
            PSEUDO: new RegExp("^" + re),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ee + "*(even|odd|(([+-]|)(\\d*)n|)" + ee + "*(?:([+-]|)" + ee + "*(\\d+)|))" + ee + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + Z + ")$", "i"),
            needsContext: new RegExp("^" + ee + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ee + "*((?:-\\d)?\\d*)" + ee + "*\\)|)(?=[^-]|$)", "i")
        }, de = /^(?:input|select|textarea|button)$/i, pe = /^h\d$/i, me = /^[^{]+\{\s*\[native \w/, ge = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, he = /[+~]/, ve = /'|\\/g, ye = new RegExp("\\\\([\\da-f]{1,6}" + ee + "?|(" + ee + ")|.)", "ig"), ke = function(e, t, n) {
            var r = "0x" + t - 65536;
            return r !== r || n ? t : r < 0 ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320);
        }, be = function() {
            M();
        };
        try {
            J.apply($ = Q.call(q.childNodes), q.childNodes), $[q.childNodes.length].nodeType;
        } catch (e) {
            J = {
                apply: $.length ? function(e, t) {
                    X.apply(e, Q.call(t));
                } : function(e, t) {
                    for (var n = e.length, r = 0; e[n++] = t[r++]; ) ;
                    e.length = n - 1;
                }
            };
        }
        k = t.support = {}, S = t.isXML = function(e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return !!t && "HTML" !== t.nodeName;
        }, M = t.setDocument = function(e) {
            var t, n, r = e ? e.ownerDocument || e : q;
            return r !== P && 9 === r.nodeType && r.documentElement ? (P = r, O = P.documentElement, 
            D = !S(P), (n = P.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", be, !1) : n.attachEvent && n.attachEvent("onunload", be)), 
            k.attributes = o(function(e) {
                return e.className = "i", !e.getAttribute("className");
            }), k.getElementsByTagName = o(function(e) {
                return e.appendChild(P.createComment("")), !e.getElementsByTagName("*").length;
            }), k.getElementsByClassName = me.test(P.getElementsByClassName), k.getById = o(function(e) {
                return O.appendChild(e).id = F, !P.getElementsByName || !P.getElementsByName(F).length;
            }), k.getById ? (b.find.ID = function(e, t) {
                if (void 0 !== t.getElementById && D) {
                    var n = t.getElementById(e);
                    return n ? [ n ] : [];
                }
            }, b.filter.ID = function(e) {
                var t = e.replace(ye, ke);
                return function(e) {
                    return e.getAttribute("id") === t;
                };
            }) : (delete b.find.ID, b.filter.ID = function(e) {
                var t = e.replace(ye, ke);
                return function(e) {
                    var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                    return n && n.value === t;
                };
            }), b.find.TAG = k.getElementsByTagName ? function(e, t) {
                return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : k.qsa ? t.querySelectorAll(e) : void 0;
            } : function(e, t) {
                var n, r = [], o = 0, a = t.getElementsByTagName(e);
                if ("*" === e) {
                    for (;n = a[o++]; ) 1 === n.nodeType && r.push(n);
                    return r;
                }
                return a;
            }, b.find.CLASS = k.getElementsByClassName && function(e, t) {
                if (void 0 !== t.getElementsByClassName && D) return t.getElementsByClassName(e);
            }, R = [], L = [], (k.qsa = me.test(P.querySelectorAll)) && (o(function(e) {
                O.appendChild(e).innerHTML = "<a id='" + F + "'></a><select id='" + F + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
                e.querySelectorAll("[msallowcapture^='']").length && L.push("[*^$]=" + ee + "*(?:''|\"\")"), 
                e.querySelectorAll("[selected]").length || L.push("\\[" + ee + "*(?:value|" + Z + ")"), 
                e.querySelectorAll("[id~=" + F + "-]").length || L.push("~="), e.querySelectorAll(":checked").length || L.push(":checked"), 
                e.querySelectorAll("a#" + F + "+*").length || L.push(".#.+[+~]");
            }), o(function(e) {
                var t = P.createElement("input");
                t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && L.push("name" + ee + "*[*^$|!~]?="), 
                e.querySelectorAll(":enabled").length || L.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), 
                L.push(",.*:");
            })), (k.matchesSelector = me.test(E = O.matches || O.webkitMatchesSelector || O.mozMatchesSelector || O.oMatchesSelector || O.msMatchesSelector)) && o(function(e) {
                k.disconnectedMatch = E.call(e, "div"), E.call(e, "[s!='']:x"), R.push("!=", re);
            }), L = L.length && new RegExp(L.join("|")), R = R.length && new RegExp(R.join("|")), 
            t = me.test(O.compareDocumentPosition), V = t || me.test(O.contains) ? function(e, t) {
                var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode;
                return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
            } : function(e, t) {
                if (t) for (;t = t.parentNode; ) if (t === e) return !0;
                return !1;
            }, H = t ? function(e, t) {
                if (e === t) return I = !0, 0;
                var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !k.sortDetached && t.compareDocumentPosition(e) === n ? e === P || e.ownerDocument === q && V(q, e) ? -1 : t === P || t.ownerDocument === q && V(q, t) ? 1 : T ? Y(T, e) - Y(T, t) : 0 : 4 & n ? -1 : 1);
            } : function(e, t) {
                if (e === t) return I = !0, 0;
                var n, r = 0, o = e.parentNode, a = t.parentNode, u = [ e ], s = [ t ];
                if (!o || !a) return e === P ? -1 : t === P ? 1 : o ? -1 : a ? 1 : T ? Y(T, e) - Y(T, t) : 0;
                if (o === a) return i(e, t);
                for (n = e; n = n.parentNode; ) u.unshift(n);
                for (n = t; n = n.parentNode; ) s.unshift(n);
                for (;u[r] === s[r]; ) r++;
                return r ? i(u[r], s[r]) : u[r] === q ? -1 : s[r] === q ? 1 : 0;
            }, P) : P;
        }, t.matches = function(e, n) {
            return t(e, null, null, n);
        }, t.matchesSelector = function(e, n) {
            if ((e.ownerDocument || e) !== P && M(e), n = n.replace(se, "='$1']"), k.matchesSelector && D && !U[n + " "] && (!R || !R.test(n)) && (!L || !L.test(n))) try {
                var r = E.call(e, n);
                if (r || k.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r;
            } catch (e) {}
            return t(n, P, null, [ e ]).length > 0;
        }, t.contains = function(e, t) {
            return (e.ownerDocument || e) !== P && M(e), V(e, t);
        }, t.attr = function(e, t) {
            (e.ownerDocument || e) !== P && M(e);
            var n = b.attrHandle[t.toLowerCase()], r = n && z.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !D) : void 0;
            return void 0 !== r ? r : k.attributes || !D ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }, t.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e);
        }, t.uniqueSort = function(e) {
            var t, n = [], r = 0, o = 0;
            if (I = !k.detectDuplicates, T = !k.sortStable && e.slice(0), e.sort(H), I) {
                for (;t = e[o++]; ) t === e[o] && (r = n.push(o));
                for (;r--; ) e.splice(n[r], 1);
            }
            return T = null, e;
        }, x = t.getText = function(e) {
            var t, n = "", r = 0, o = e.nodeType;
            if (o) {
                if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) n += x(e);
                } else if (3 === o || 4 === o) return e.nodeValue;
            } else for (;t = e[r++]; ) n += x(t);
            return n;
        }, (b = t.selectors = {
            cacheLength: 50,
            createPseudo: r,
            match: fe,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace(ye, ke), e[3] = (e[3] || e[4] || e[5] || "").replace(ye, ke), 
                    "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4);
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), 
                    e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), 
                    e;
                },
                PSEUDO: function(e) {
                    var t, n = !e[6] && e[2];
                    return fe.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && le.test(n) && (t = w(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), 
                    e[2] = n.slice(0, t)), e.slice(0, 3));
                }
            },
            filter: {
                TAG: function(e) {
                    var t = e.replace(ye, ke).toLowerCase();
                    return "*" === e ? function() {
                        return !0;
                    } : function(e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t;
                    };
                },
                CLASS: function(e) {
                    var t = G[e + " "];
                    return t || (t = new RegExp("(^|" + ee + ")" + e + "(" + ee + "|$)")) && G(e, function(e) {
                        return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "");
                    });
                },
                ATTR: function(e, n, r) {
                    return function(o) {
                        var a = t.attr(o, e);
                        return null == a ? "!=" === n : !n || (a += "", "=" === n ? a === r : "!=" === n ? a !== r : "^=" === n ? r && 0 === a.indexOf(r) : "*=" === n ? r && a.indexOf(r) > -1 : "$=" === n ? r && a.slice(-r.length) === r : "~=" === n ? (" " + a.replace(oe, " ") + " ").indexOf(r) > -1 : "|=" === n && (a === r || a.slice(0, r.length + 1) === r + "-"));
                    };
                },
                CHILD: function(e, t, n, r, o) {
                    var a = "nth" !== e.slice(0, 3), i = "last" !== e.slice(-4), u = "of-type" === t;
                    return 1 === r && 0 === o ? function(e) {
                        return !!e.parentNode;
                    } : function(t, n, s) {
                        var l, c, f, d, p, m, g = a !== i ? "nextSibling" : "previousSibling", h = t.parentNode, v = u && t.nodeName.toLowerCase(), y = !s && !u, k = !1;
                        if (h) {
                            if (a) {
                                for (;g; ) {
                                    for (d = t; d = d[g]; ) if (u ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                    m = g = "only" === e && !m && "nextSibling";
                                }
                                return !0;
                            }
                            if (m = [ i ? h.firstChild : h.lastChild ], i && y) {
                                for (k = (p = (l = (c = (f = (d = h)[F] || (d[F] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] || [])[0] === B && l[1]) && l[2], 
                                d = p && h.childNodes[p]; d = ++p && d && d[g] || (k = p = 0) || m.pop(); ) if (1 === d.nodeType && ++k && d === t) {
                                    c[e] = [ B, p, k ];
                                    break;
                                }
                            } else if (y && (k = p = (l = (c = (f = (d = t)[F] || (d[F] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] || [])[0] === B && l[1]), 
                            !1 === k) for (;(d = ++p && d && d[g] || (k = p = 0) || m.pop()) && ((u ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++k || (y && ((c = (f = d[F] || (d[F] = {}))[d.uniqueID] || (f[d.uniqueID] = {}))[e] = [ B, k ]), 
                            d !== t)); ) ;
                            return (k -= o) === r || k % r == 0 && k / r >= 0;
                        }
                    };
                },
                PSEUDO: function(e, n) {
                    var o, a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                    return a[F] ? a(n) : a.length > 1 ? (o = [ e, e, "", n ], b.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function(e, t) {
                        for (var r, o = a(e, n), i = o.length; i--; ) e[r = Y(e, o[i])] = !(t[r] = o[i]);
                    }) : function(e) {
                        return a(e, 0, o);
                    }) : a;
                }
            },
            pseudos: {
                not: r(function(e) {
                    var t = [], n = [], o = C(e.replace(ae, "$1"));
                    return o[F] ? r(function(e, t, n, r) {
                        for (var a, i = o(e, null, r, []), u = e.length; u--; ) (a = i[u]) && (e[u] = !(t[u] = a));
                    }) : function(e, r, a) {
                        return t[0] = e, o(t, null, a, n), t[0] = null, !n.pop();
                    };
                }),
                has: r(function(e) {
                    return function(n) {
                        return t(e, n).length > 0;
                    };
                }),
                contains: r(function(e) {
                    return e = e.replace(ye, ke), function(t) {
                        return (t.textContent || t.innerText || x(t)).indexOf(e) > -1;
                    };
                }),
                lang: r(function(e) {
                    return ce.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(ye, ke).toLowerCase(), 
                    function(t) {
                        var n;
                        do {
                            if (n = D ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-");
                        } while ((t = t.parentNode) && 1 === t.nodeType);
                        return !1;
                    };
                }),
                target: function(t) {
                    var n = e.location && e.location.hash;
                    return n && n.slice(1) === t.id;
                },
                root: function(e) {
                    return e === O;
                },
                focus: function(e) {
                    return e === P.activeElement && (!P.hasFocus || P.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                },
                enabled: function(e) {
                    return !1 === e.disabled;
                },
                disabled: function(e) {
                    return !0 === e.disabled;
                },
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected;
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
                },
                empty: function(e) {
                    for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(e) {
                    return !b.pseudos.empty(e);
                },
                header: function(e) {
                    return pe.test(e.nodeName);
                },
                input: function(e) {
                    return de.test(e.nodeName);
                },
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t;
                },
                text: function(e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
                },
                first: u(function() {
                    return [ 0 ];
                }),
                last: u(function(e, t) {
                    return [ t - 1 ];
                }),
                eq: u(function(e, t, n) {
                    return [ n < 0 ? n + t : n ];
                }),
                even: u(function(e, t) {
                    for (var n = 0; n < t; n += 2) e.push(n);
                    return e;
                }),
                odd: u(function(e, t) {
                    for (var n = 1; n < t; n += 2) e.push(n);
                    return e;
                }),
                lt: u(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; --r >= 0; ) e.push(r);
                    return e;
                }),
                gt: u(function(e, t, n) {
                    for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
                    return e;
                })
            }
        }).pseudos.nth = b.pseudos.eq;
        for (y in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) b.pseudos[y] = function(e) {
            return function(t) {
                return "input" === t.nodeName.toLowerCase() && t.type === e;
            };
        }(y);
        for (y in {
            submit: !0,
            reset: !0
        }) b.pseudos[y] = function(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && t.type === e;
            };
        }(y);
        return l.prototype = b.filters = b.pseudos, b.setFilters = new l(), w = t.tokenize = function(e, n) {
            var r, o, a, i, u, s, l, c = j[e + " "];
            if (c) return n ? 0 : c.slice(0);
            for (u = e, s = [], l = b.preFilter; u; ) {
                r && !(o = ie.exec(u)) || (o && (u = u.slice(o[0].length) || u), s.push(a = [])), 
                r = !1, (o = ue.exec(u)) && (r = o.shift(), a.push({
                    value: r,
                    type: o[0].replace(ae, " ")
                }), u = u.slice(r.length));
                for (i in b.filter) !(o = fe[i].exec(u)) || l[i] && !(o = l[i](o)) || (r = o.shift(), 
                a.push({
                    value: r,
                    type: i,
                    matches: o
                }), u = u.slice(r.length));
                if (!r) break;
            }
            return n ? u.length : u ? t.error(e) : j(e, s).slice(0);
        }, C = t.compile = function(e, t) {
            var n, r = [], o = [], a = U[e + " "];
            if (!a) {
                for (t || (t = w(e)), n = t.length; n--; ) (a = h(t[n]))[F] ? r.push(a) : o.push(a);
                (a = U(e, v(o, r))).selector = e;
            }
            return a;
        }, A = t.select = function(e, t, n, r) {
            var o, a, i, u, l, f = "function" == typeof e && e, d = !r && w(e = f.selector || e);
            if (n = n || [], 1 === d.length) {
                if ((a = d[0] = d[0].slice(0)).length > 2 && "ID" === (i = a[0]).type && k.getById && 9 === t.nodeType && D && b.relative[a[1].type]) {
                    if (!(t = (b.find.ID(i.matches[0].replace(ye, ke), t) || [])[0])) return n;
                    f && (t = t.parentNode), e = e.slice(a.shift().value.length);
                }
                for (o = fe.needsContext.test(e) ? 0 : a.length; o-- && (i = a[o], !b.relative[u = i.type]); ) if ((l = b.find[u]) && (r = l(i.matches[0].replace(ye, ke), he.test(a[0].type) && s(t.parentNode) || t))) {
                    if (a.splice(o, 1), !(e = r.length && c(a))) return J.apply(n, r), n;
                    break;
                }
            }
            return (f || C(e, d))(r, t, !D, n, !t || he.test(e) && s(t.parentNode) || t), n;
        }, k.sortStable = F.split("").sort(H).join("") === F, k.detectDuplicates = !!I, 
        M(), k.sortDetached = o(function(e) {
            return 1 & e.compareDocumentPosition(P.createElement("div"));
        }), o(function(e) {
            return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href");
        }) || a("type|href|height|width", function(e, t, n) {
            if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
        }), k.attributes && o(function(e) {
            return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value");
        }) || a("value", function(e, t, n) {
            if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
        }), o(function(e) {
            return null == e.getAttribute("disabled");
        }) || a(Z, function(e, t, n) {
            var r;
            if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        }), t;
    }(e);
    re.find = se, re.expr = se.selectors, re.expr[":"] = re.expr.pseudos, re.uniqueSort = re.unique = se.uniqueSort, 
    re.text = se.getText, re.isXMLDoc = se.isXML, re.contains = se.contains;
    var le = function(e, t, n) {
        for (var r = [], o = void 0 !== n; (e = e[t]) && 9 !== e.nodeType; ) if (1 === e.nodeType) {
            if (o && re(e).is(n)) break;
            r.push(e);
        }
        return r;
    }, ce = function(e, t) {
        for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
        return n;
    }, fe = re.expr.match.needsContext, de = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, pe = /^.[^:#\[\.,]*$/;
    re.filter = function(e, t, n) {
        var r = t[0];
        return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? re.find.matchesSelector(r, e) ? [ r ] : [] : re.find.matches(e, re.grep(t, function(e) {
            return 1 === e.nodeType;
        }));
    }, re.fn.extend({
        find: function(e) {
            var t, n = this.length, r = [], o = this;
            if ("string" != typeof e) return this.pushStack(re(e).filter(function() {
                for (t = 0; t < n; t++) if (re.contains(o[t], this)) return !0;
            }));
            for (t = 0; t < n; t++) re.find(e, o[t], r);
            return r = this.pushStack(n > 1 ? re.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, 
            r;
        },
        filter: function(e) {
            return this.pushStack(r(this, e || [], !1));
        },
        not: function(e) {
            return this.pushStack(r(this, e || [], !0));
        },
        is: function(e) {
            return !!r(this, "string" == typeof e && fe.test(e) ? re(e) : e || [], !1).length;
        }
    });
    var me, ge = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
    (re.fn.init = function(e, t, n) {
        var r, o;
        if (!e) return this;
        if (n = n || me, "string" == typeof e) {
            if (!(r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [ null, e, null ] : ge.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
            if (r[1]) {
                if (t = t instanceof re ? t[0] : t, re.merge(this, re.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : K, !0)), 
                de.test(r[1]) && re.isPlainObject(t)) for (r in t) re.isFunction(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this;
            }
            return (o = K.getElementById(r[2])) && o.parentNode && (this.length = 1, this[0] = o), 
            this.context = K, this.selector = e, this;
        }
        return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : re.isFunction(e) ? void 0 !== n.ready ? n.ready(e) : e(re) : (void 0 !== e.selector && (this.selector = e.selector, 
        this.context = e.context), re.makeArray(e, this));
    }).prototype = re.fn, me = re(K);
    var he = /^(?:parents|prev(?:Until|All))/, ve = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    re.fn.extend({
        has: function(e) {
            var t = re(e, this), n = t.length;
            return this.filter(function() {
                for (var e = 0; e < n; e++) if (re.contains(this, t[e])) return !0;
            });
        },
        closest: function(e, t) {
            for (var n, r = 0, o = this.length, a = [], i = fe.test(e) || "string" != typeof e ? re(e, t || this.context) : 0; r < o; r++) for (n = this[r]; n && n !== t; n = n.parentNode) if (n.nodeType < 11 && (i ? i.index(n) > -1 : 1 === n.nodeType && re.find.matchesSelector(n, e))) {
                a.push(n);
                break;
            }
            return this.pushStack(a.length > 1 ? re.uniqueSort(a) : a);
        },
        index: function(e) {
            return e ? "string" == typeof e ? Y.call(re(e), this[0]) : Y.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(e, t) {
            return this.pushStack(re.uniqueSort(re.merge(this.get(), re(e, t))));
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
        }
    }), re.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null;
        },
        parents: function(e) {
            return le(e, "parentNode");
        },
        parentsUntil: function(e, t, n) {
            return le(e, "parentNode", n);
        },
        next: function(e) {
            return o(e, "nextSibling");
        },
        prev: function(e) {
            return o(e, "previousSibling");
        },
        nextAll: function(e) {
            return le(e, "nextSibling");
        },
        prevAll: function(e) {
            return le(e, "previousSibling");
        },
        nextUntil: function(e, t, n) {
            return le(e, "nextSibling", n);
        },
        prevUntil: function(e, t, n) {
            return le(e, "previousSibling", n);
        },
        siblings: function(e) {
            return ce((e.parentNode || {}).firstChild, e);
        },
        children: function(e) {
            return ce(e.firstChild);
        },
        contents: function(e) {
            return e.contentDocument || re.merge([], e.childNodes);
        }
    }, function(e, t) {
        re.fn[e] = function(n, r) {
            var o = re.map(this, t, n);
            return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (o = re.filter(r, o)), 
            this.length > 1 && (ve[e] || re.uniqueSort(o), he.test(e) && o.reverse()), this.pushStack(o);
        };
    });
    var ye = /\S+/g;
    re.Callbacks = function(e) {
        e = "string" == typeof e ? a(e) : re.extend({}, e);
        var t, n, r, o, i = [], u = [], s = -1, l = function() {
            for (o = e.once, r = t = !0; u.length; s = -1) for (n = u.shift(); ++s < i.length; ) !1 === i[s].apply(n[0], n[1]) && e.stopOnFalse && (s = i.length, 
            n = !1);
            e.memory || (n = !1), t = !1, o && (i = n ? [] : "");
        }, c = {
            add: function() {
                return i && (n && !t && (s = i.length - 1, u.push(n)), function t(n) {
                    re.each(n, function(n, r) {
                        re.isFunction(r) ? e.unique && c.has(r) || i.push(r) : r && r.length && "string" !== re.type(r) && t(r);
                    });
                }(arguments), n && !t && l()), this;
            },
            remove: function() {
                return re.each(arguments, function(e, t) {
                    for (var n; (n = re.inArray(t, i, n)) > -1; ) i.splice(n, 1), n <= s && s--;
                }), this;
            },
            has: function(e) {
                return e ? re.inArray(e, i) > -1 : i.length > 0;
            },
            empty: function() {
                return i && (i = []), this;
            },
            disable: function() {
                return o = u = [], i = n = "", this;
            },
            disabled: function() {
                return !i;
            },
            lock: function() {
                return o = u = [], n || (i = n = ""), this;
            },
            locked: function() {
                return !!o;
            },
            fireWith: function(e, n) {
                return o || (n = [ e, (n = n || []).slice ? n.slice() : n ], u.push(n), t || l()), 
                this;
            },
            fire: function() {
                return c.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!r;
            }
        };
        return c;
    }, re.extend({
        Deferred: function(e) {
            var t = [ [ "resolve", "done", re.Callbacks("once memory"), "resolved" ], [ "reject", "fail", re.Callbacks("once memory"), "rejected" ], [ "notify", "progress", re.Callbacks("memory") ] ], n = "pending", r = {
                state: function() {
                    return n;
                },
                always: function() {
                    return o.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var e = arguments;
                    return re.Deferred(function(n) {
                        re.each(t, function(t, a) {
                            var i = re.isFunction(e[t]) && e[t];
                            o[a[1]](function() {
                                var e = i && i.apply(this, arguments);
                                e && re.isFunction(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[a[0] + "With"](this === r ? n.promise() : this, i ? [ e ] : arguments);
                            });
                        }), e = null;
                    }).promise();
                },
                promise: function(e) {
                    return null != e ? re.extend(e, r) : r;
                }
            }, o = {};
            return r.pipe = r.then, re.each(t, function(e, a) {
                var i = a[2], u = a[3];
                r[a[1]] = i.add, u && i.add(function() {
                    n = u;
                }, t[1 ^ e][2].disable, t[2][2].lock), o[a[0]] = function() {
                    return o[a[0] + "With"](this === o ? r : this, arguments), this;
                }, o[a[0] + "With"] = i.fireWith;
            }), r.promise(o), e && e.call(o, o), o;
        },
        when: function(e) {
            var t, n, r, o = 0, a = X.call(arguments), i = a.length, u = 1 !== i || e && re.isFunction(e.promise) ? i : 0, s = 1 === u ? e : re.Deferred(), l = function(e, n, r) {
                return function(o) {
                    n[e] = this, r[e] = arguments.length > 1 ? X.call(arguments) : o, r === t ? s.notifyWith(n, r) : --u || s.resolveWith(n, r);
                };
            };
            if (i > 1) for (t = new Array(i), n = new Array(i), r = new Array(i); o < i; o++) a[o] && re.isFunction(a[o].promise) ? a[o].promise().progress(l(o, n, t)).done(l(o, r, a)).fail(s.reject) : --u;
            return u || s.resolveWith(r, a), s.promise();
        }
    });
    var ke;
    re.fn.ready = function(e) {
        return re.ready.promise().done(e), this;
    }, re.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(e) {
            e ? re.readyWait++ : re.ready(!0);
        },
        ready: function(e) {
            (!0 === e ? --re.readyWait : re.isReady) || (re.isReady = !0, !0 !== e && --re.readyWait > 0 || (ke.resolveWith(K, [ re ]), 
            re.fn.triggerHandler && (re(K).triggerHandler("ready"), re(K).off("ready"))));
        }
    }), re.ready.promise = function(t) {
        return ke || (ke = re.Deferred(), "complete" === K.readyState || "loading" !== K.readyState && !K.documentElement.doScroll ? e.setTimeout(re.ready) : (K.addEventListener("DOMContentLoaded", i), 
        e.addEventListener("load", i))), ke.promise(t);
    }, re.ready.promise();
    var be = function(e, t, n, r, o, a, i) {
        var u = 0, s = e.length, l = null == n;
        if ("object" === re.type(n)) {
            o = !0;
            for (u in n) be(e, t, u, n[u], !0, a, i);
        } else if (void 0 !== r && (o = !0, re.isFunction(r) || (i = !0), l && (i ? (t.call(e, r), 
        t = null) : (l = t, t = function(e, t, n) {
            return l.call(re(e), n);
        })), t)) for (;u < s; u++) t(e[u], n, i ? r : r.call(e[u], u, t(e[u], n)));
        return o ? e : l ? t.call(e) : s ? t(e[0], n) : a;
    }, xe = function(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
    };
    u.uid = 1, u.prototype = {
        register: function(e, t) {
            var n = t || {};
            return e.nodeType ? e[this.expando] = n : Object.defineProperty(e, this.expando, {
                value: n,
                writable: !0,
                configurable: !0
            }), e[this.expando];
        },
        cache: function(e) {
            if (!xe(e)) return {};
            var t = e[this.expando];
            return t || (t = {}, xe(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
            }))), t;
        },
        set: function(e, t, n) {
            var r, o = this.cache(e);
            if ("string" == typeof t) o[t] = n; else for (r in t) o[r] = t[r];
            return o;
        },
        get: function(e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][t];
        },
        access: function(e, t, n) {
            var r;
            return void 0 === t || t && "string" == typeof t && void 0 === n ? void 0 !== (r = this.get(e, t)) ? r : this.get(e, re.camelCase(t)) : (this.set(e, t, n), 
            void 0 !== n ? n : t);
        },
        remove: function(e, t) {
            var n, r, o, a = e[this.expando];
            if (void 0 !== a) {
                if (void 0 === t) this.register(e); else {
                    re.isArray(t) ? r = t.concat(t.map(re.camelCase)) : (o = re.camelCase(t), r = t in a ? [ t, o ] : (r = o) in a ? [ r ] : r.match(ye) || []), 
                    n = r.length;
                    for (;n--; ) delete a[r[n]];
                }
                (void 0 === t || re.isEmptyObject(a)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]);
            }
        },
        hasData: function(e) {
            var t = e[this.expando];
            return void 0 !== t && !re.isEmptyObject(t);
        }
    };
    var Se = new u(), we = new u(), Ce = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, Ae = /[A-Z]/g;
    re.extend({
        hasData: function(e) {
            return we.hasData(e) || Se.hasData(e);
        },
        data: function(e, t, n) {
            return we.access(e, t, n);
        },
        removeData: function(e, t) {
            we.remove(e, t);
        },
        _data: function(e, t, n) {
            return Se.access(e, t, n);
        },
        _removeData: function(e, t) {
            Se.remove(e, t);
        }
    }), re.fn.extend({
        data: function(e, t) {
            var n, r, o, a = this[0], i = a && a.attributes;
            if (void 0 === e) {
                if (this.length && (o = we.get(a), 1 === a.nodeType && !Se.get(a, "hasDataAttrs"))) {
                    for (n = i.length; n--; ) i[n] && 0 === (r = i[n].name).indexOf("data-") && (r = re.camelCase(r.slice(5)), 
                    s(a, r, o[r]));
                    Se.set(a, "hasDataAttrs", !0);
                }
                return o;
            }
            return "object" == typeof e ? this.each(function() {
                we.set(this, e);
            }) : be(this, function(t) {
                var n, r;
                if (a && void 0 === t) {
                    if (void 0 !== (n = we.get(a, e) || we.get(a, e.replace(Ae, "-$&").toLowerCase()))) return n;
                    if (r = re.camelCase(e), void 0 !== (n = we.get(a, r))) return n;
                    if (void 0 !== (n = s(a, r, void 0))) return n;
                } else r = re.camelCase(e), this.each(function() {
                    var n = we.get(this, r);
                    we.set(this, r, t), e.indexOf("-") > -1 && void 0 !== n && we.set(this, e, t);
                });
            }, null, t, arguments.length > 1, null, !0);
        },
        removeData: function(e) {
            return this.each(function() {
                we.remove(this, e);
            });
        }
    }), re.extend({
        queue: function(e, t, n) {
            var r;
            if (e) return t = (t || "fx") + "queue", r = Se.get(e, t), n && (!r || re.isArray(n) ? r = Se.access(e, t, re.makeArray(n)) : r.push(n)), 
            r || [];
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = re.queue(e, t), r = n.length, o = n.shift(), a = re._queueHooks(e, t);
            "inprogress" === o && (o = n.shift(), r--), o && ("fx" === t && n.unshift("inprogress"), 
            delete a.stop, o.call(e, function() {
                re.dequeue(e, t);
            }, a)), !r && a && a.empty.fire();
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return Se.get(e, n) || Se.access(e, n, {
                empty: re.Callbacks("once memory").add(function() {
                    Se.remove(e, [ t + "queue", n ]);
                })
            });
        }
    }), re.fn.extend({
        queue: function(e, t) {
            var n = 2;
            return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? re.queue(this[0], e) : void 0 === t ? this : this.each(function() {
                var n = re.queue(this, e, t);
                re._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && re.dequeue(this, e);
            });
        },
        dequeue: function(e) {
            return this.each(function() {
                re.dequeue(this, e);
            });
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", []);
        },
        promise: function(e, t) {
            var n, r = 1, o = re.Deferred(), a = this, i = this.length, u = function() {
                --r || o.resolveWith(a, [ a ]);
            };
            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; i--; ) (n = Se.get(a[i], e + "queueHooks")) && n.empty && (r++, 
            n.empty.add(u));
            return u(), o.promise(t);
        }
    });
    var Ne = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Te = new RegExp("^(?:([+-])=|)(" + Ne + ")([a-z%]*)$", "i"), Ie = [ "Top", "Right", "Bottom", "Left" ], Me = function(e, t) {
        return e = t || e, "none" === re.css(e, "display") || !re.contains(e.ownerDocument, e);
    }, Pe = /^(?:checkbox|radio)$/i, Oe = /<([\w:-]+)/, De = /^$|\/(?:java|ecma)script/i, Le = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    Le.optgroup = Le.option, Le.tbody = Le.tfoot = Le.colgroup = Le.caption = Le.thead, 
    Le.th = Le.td;
    var Re = /<|&#?\w+;/;
    !function() {
        var e = K.createDocumentFragment().appendChild(K.createElement("div")), t = K.createElement("input");
        t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), 
        e.appendChild(t), ne.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        e.innerHTML = "<textarea>x</textarea>", ne.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue;
    }();
    var Ee = /^key/, Ve = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Fe = /^([^.]*)(?:\.(.+)|)/;
    re.event = {
        global: {},
        add: function(e, t, n, r, o) {
            var a, i, u, s, l, c, f, d, p, m, g, h = Se.get(e);
            if (h) for (n.handler && (n = (a = n).handler, o = a.selector), n.guid || (n.guid = re.guid++), 
            (s = h.events) || (s = h.events = {}), (i = h.handle) || (i = h.handle = function(t) {
                return void 0 !== re && re.event.triggered !== t.type ? re.event.dispatch.apply(e, arguments) : void 0;
            }), l = (t = (t || "").match(ye) || [ "" ]).length; l--; ) p = g = (u = Fe.exec(t[l]) || [])[1], 
            m = (u[2] || "").split(".").sort(), p && (f = re.event.special[p] || {}, p = (o ? f.delegateType : f.bindType) || p, 
            f = re.event.special[p] || {}, c = re.extend({
                type: p,
                origType: g,
                data: r,
                handler: n,
                guid: n.guid,
                selector: o,
                needsContext: o && re.expr.match.needsContext.test(o),
                namespace: m.join(".")
            }, a), (d = s[p]) || ((d = s[p] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, m, i) || e.addEventListener && e.addEventListener(p, i)), 
            f.add && (f.add.call(e, c), c.handler.guid || (c.handler.guid = n.guid)), o ? d.splice(d.delegateCount++, 0, c) : d.push(c), 
            re.event.global[p] = !0);
        },
        remove: function(e, t, n, r, o) {
            var a, i, u, s, l, c, f, d, p, m, g, h = Se.hasData(e) && Se.get(e);
            if (h && (s = h.events)) {
                for (l = (t = (t || "").match(ye) || [ "" ]).length; l--; ) if (u = Fe.exec(t[l]) || [], 
                p = g = u[1], m = (u[2] || "").split(".").sort(), p) {
                    for (f = re.event.special[p] || {}, d = s[p = (r ? f.delegateType : f.bindType) || p] || [], 
                    u = u[2] && new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = a = d.length; a--; ) c = d[a], 
                    !o && g !== c.origType || n && n.guid !== c.guid || u && !u.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (d.splice(a, 1), 
                    c.selector && d.delegateCount--, f.remove && f.remove.call(e, c));
                    i && !d.length && (f.teardown && !1 !== f.teardown.call(e, m, h.handle) || re.removeEvent(e, p, h.handle), 
                    delete s[p]);
                } else for (p in s) re.event.remove(e, p + t[l], n, r, !0);
                re.isEmptyObject(s) && Se.remove(e, "handle events");
            }
        },
        dispatch: function(e) {
            e = re.event.fix(e);
            var t, n, r, o, a, i = [], u = X.call(arguments), s = (Se.get(this, "events") || {})[e.type] || [], l = re.event.special[e.type] || {};
            if (u[0] = e, e.delegateTarget = this, !l.preDispatch || !1 !== l.preDispatch.call(this, e)) {
                for (i = re.event.handlers.call(this, e, s), t = 0; (o = i[t++]) && !e.isPropagationStopped(); ) for (e.currentTarget = o.elem, 
                n = 0; (a = o.handlers[n++]) && !e.isImmediatePropagationStopped(); ) e.rnamespace && !e.rnamespace.test(a.namespace) || (e.handleObj = a, 
                e.data = a.data, void 0 !== (r = ((re.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, u)) && !1 === (e.result = r) && (e.preventDefault(), 
                e.stopPropagation()));
                return l.postDispatch && l.postDispatch.call(this, e), e.result;
            }
        },
        handlers: function(e, t) {
            var n, r, o, a, i = [], u = t.delegateCount, s = e.target;
            if (u && s.nodeType && ("click" !== e.type || isNaN(e.button) || e.button < 1)) for (;s !== this; s = s.parentNode || this) if (1 === s.nodeType && (!0 !== s.disabled || "click" !== e.type)) {
                for (r = [], n = 0; n < u; n++) void 0 === r[o = (a = t[n]).selector + " "] && (r[o] = a.needsContext ? re(o, this).index(s) > -1 : re.find(o, this, null, [ s ]).length), 
                r[o] && r.push(a);
                r.length && i.push({
                    elem: s,
                    handlers: r
                });
            }
            return u < t.length && i.push({
                elem: this,
                handlers: t.slice(u)
            }), i;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(e, t) {
                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), 
                e;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(e, t) {
                var n, r, o, a = t.button;
                return null == e.pageX && null != t.clientX && (r = (n = e.target.ownerDocument || K).documentElement, 
                o = n.body, e.pageX = t.clientX + (r && r.scrollLeft || o && o.scrollLeft || 0) - (r && r.clientLeft || o && o.clientLeft || 0), 
                e.pageY = t.clientY + (r && r.scrollTop || o && o.scrollTop || 0) - (r && r.clientTop || o && o.clientTop || 0)), 
                e.which || void 0 === a || (e.which = 1 & a ? 1 : 2 & a ? 3 : 4 & a ? 2 : 0), e;
            }
        },
        fix: function(e) {
            if (e[re.expando]) return e;
            var t, n, r, o = e.type, a = e, i = this.fixHooks[o];
            for (i || (this.fixHooks[o] = i = Ve.test(o) ? this.mouseHooks : Ee.test(o) ? this.keyHooks : {}), 
            r = i.props ? this.props.concat(i.props) : this.props, e = new re.Event(a), t = r.length; t--; ) e[n = r[t]] = a[n];
            return e.target || (e.target = K), 3 === e.target.nodeType && (e.target = e.target.parentNode), 
            i.filter ? i.filter(e, a) : e;
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== g() && this.focus) return this.focus(), !1;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === g() && this.blur) return this.blur(), !1;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && re.nodeName(this, "input")) return this.click(), 
                    !1;
                },
                _default: function(e) {
                    return re.nodeName(e.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result);
                }
            }
        }
    }, re.removeEvent = function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n);
    }, re.Event = function(e, t) {
        if (!(this instanceof re.Event)) return new re.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? p : m) : this.type = e, 
        t && re.extend(this, t), this.timeStamp = e && e.timeStamp || re.now(), this[re.expando] = !0;
    }, re.Event.prototype = {
        constructor: re.Event,
        isDefaultPrevented: m,
        isPropagationStopped: m,
        isImmediatePropagationStopped: m,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = p, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = p, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = p, e && !this.isSimulated && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, re.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(e, t) {
        re.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function(e) {
                var n, r = this, o = e.relatedTarget, a = e.handleObj;
                return o && (o === r || re.contains(r, o)) || (e.type = a.origType, n = a.handler.apply(this, arguments), 
                e.type = t), n;
            }
        };
    }), re.fn.extend({
        on: function(e, t, n, r) {
            return h(this, e, t, n, r);
        },
        one: function(e, t, n, r) {
            return h(this, e, t, n, r, 1);
        },
        off: function(e, t, n) {
            var r, o;
            if (e && e.preventDefault && e.handleObj) return r = e.handleObj, re(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), 
            this;
            if ("object" == typeof e) {
                for (o in e) this.off(o, t, e[o]);
                return this;
            }
            return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = m), 
            this.each(function() {
                re.event.remove(this, e, n, t);
            });
        }
    });
    var qe = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, Be = /<script|<style|<link/i, _e = /checked\s*(?:[^=]|=\s*.checked.)/i, Ge = /^true\/(.*)/, je = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    re.extend({
        htmlPrefilter: function(e) {
            return e.replace(qe, "<$1></$2>");
        },
        clone: function(e, t, n) {
            var r, o, a, i, u = e.cloneNode(!0), s = re.contains(e.ownerDocument, e);
            if (!(ne.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || re.isXMLDoc(e))) for (i = c(u), 
            r = 0, o = (a = c(e)).length; r < o; r++) x(a[r], i[r]);
            if (t) if (n) for (a = a || c(e), i = i || c(u), r = 0, o = a.length; r < o; r++) b(a[r], i[r]); else b(e, u);
            return (i = c(u, "script")).length > 0 && f(i, !s && c(e, "script")), u;
        },
        cleanData: function(e) {
            for (var t, n, r, o = re.event.special, a = 0; void 0 !== (n = e[a]); a++) if (xe(n)) {
                if (t = n[Se.expando]) {
                    if (t.events) for (r in t.events) o[r] ? re.event.remove(n, r) : re.removeEvent(n, r, t.handle);
                    n[Se.expando] = void 0;
                }
                n[we.expando] && (n[we.expando] = void 0);
            }
        }
    }), re.fn.extend({
        domManip: S,
        detach: function(e) {
            return w(this, e, !0);
        },
        remove: function(e) {
            return w(this, e);
        },
        text: function(e) {
            return be(this, function(e) {
                return void 0 === e ? re.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e);
                });
            }, null, e, arguments.length);
        },
        append: function() {
            return S(this, arguments, function(e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || v(this, e).appendChild(e);
            });
        },
        prepend: function() {
            return S(this, arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = v(this, e);
                    t.insertBefore(e, t.firstChild);
                }
            });
        },
        before: function() {
            return S(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this);
            });
        },
        after: function() {
            return S(this, arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling);
            });
        },
        empty: function() {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (re.cleanData(c(e, !1)), 
            e.textContent = "");
            return this;
        },
        clone: function(e, t) {
            return e = null != e && e, t = null == t ? e : t, this.map(function() {
                return re.clone(this, e, t);
            });
        },
        html: function(e) {
            return be(this, function(e) {
                var t = this[0] || {}, n = 0, r = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Be.test(e) && !Le[(Oe.exec(e) || [ "", "" ])[1].toLowerCase()]) {
                    e = re.htmlPrefilter(e);
                    try {
                        for (;n < r; n++) 1 === (t = this[n] || {}).nodeType && (re.cleanData(c(t, !1)), 
                        t.innerHTML = e);
                        t = 0;
                    } catch (e) {}
                }
                t && this.empty().append(e);
            }, null, e, arguments.length);
        },
        replaceWith: function() {
            var e = [];
            return S(this, arguments, function(t) {
                var n = this.parentNode;
                re.inArray(this, e) < 0 && (re.cleanData(c(this)), n && n.replaceChild(t, this));
            }, e);
        }
    }), re.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, t) {
        re.fn[e] = function(e) {
            for (var n, r = [], o = re(e), a = o.length - 1, i = 0; i <= a; i++) n = i === a ? this : this.clone(!0), 
            re(o[i])[t](n), Q.apply(r, n.get());
            return this.pushStack(r);
        };
    });
    var Ue, He = {
        HTML: "block",
        BODY: "block"
    }, We = /^margin/, ze = new RegExp("^(" + Ne + ")(?!px)[a-z%]+$", "i"), $e = function(t) {
        var n = t.ownerDocument.defaultView;
        return n && n.opener || (n = e), n.getComputedStyle(t);
    }, Ke = function(e, t, n, r) {
        var o, a, i = {};
        for (a in t) i[a] = e.style[a], e.style[a] = t[a];
        o = n.apply(e, r || []);
        for (a in t) e.style[a] = i[a];
        return o;
    }, Xe = K.documentElement;
    !function() {
        function t() {
            u.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", 
            u.innerHTML = "", Xe.appendChild(i);
            var t = e.getComputedStyle(u);
            n = "1%" !== t.top, a = "2px" === t.marginLeft, r = "4px" === t.width, u.style.marginRight = "50%", 
            o = "4px" === t.marginRight, Xe.removeChild(i);
        }
        var n, r, o, a, i = K.createElement("div"), u = K.createElement("div");
        u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", 
        ne.clearCloneStyle = "content-box" === u.style.backgroundClip, i.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", 
        i.appendChild(u), re.extend(ne, {
            pixelPosition: function() {
                return t(), n;
            },
            boxSizingReliable: function() {
                return null == r && t(), r;
            },
            pixelMarginRight: function() {
                return null == r && t(), o;
            },
            reliableMarginLeft: function() {
                return null == r && t(), a;
            },
            reliableMarginRight: function() {
                var t, n = u.appendChild(K.createElement("div"));
                return n.style.cssText = u.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
                n.style.marginRight = n.style.width = "0", u.style.width = "1px", Xe.appendChild(i), 
                t = !parseFloat(e.getComputedStyle(n).marginRight), Xe.removeChild(i), u.removeChild(n), 
                t;
            }
        }));
    }();
    var Je = /^(none|table(?!-c[ea]).+)/, Qe = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Ye = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ze = [ "Webkit", "O", "Moz", "ms" ], et = K.createElement("div").style;
    re.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = N(e, "opacity");
                        return "" === n ? "1" : n;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(e, t, n, r) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var o, a, i, u = re.camelCase(t), s = e.style;
                if (t = re.cssProps[u] || (re.cssProps[u] = I(u) || u), i = re.cssHooks[t] || re.cssHooks[u], 
                void 0 === n) return i && "get" in i && void 0 !== (o = i.get(e, !1, r)) ? o : s[t];
                "string" == (a = typeof n) && (o = Te.exec(n)) && o[1] && (n = l(e, t, o), a = "number"), 
                null != n && n === n && ("number" === a && (n += o && o[3] || (re.cssNumber[u] ? "" : "px")), 
                ne.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (s[t] = "inherit"), 
                i && "set" in i && void 0 === (n = i.set(e, n, r)) || (s[t] = n));
            }
        },
        css: function(e, t, n, r) {
            var o, a, i, u = re.camelCase(t);
            return t = re.cssProps[u] || (re.cssProps[u] = I(u) || u), (i = re.cssHooks[t] || re.cssHooks[u]) && "get" in i && (o = i.get(e, !0, n)), 
            void 0 === o && (o = N(e, t, r)), "normal" === o && t in Ye && (o = Ye[t]), "" === n || n ? (a = parseFloat(o), 
            !0 === n || isFinite(a) ? a || 0 : o) : o;
        }
    }), re.each([ "height", "width" ], function(e, t) {
        re.cssHooks[t] = {
            get: function(e, n, r) {
                if (n) return Je.test(re.css(e, "display")) && 0 === e.offsetWidth ? Ke(e, Qe, function() {
                    return O(e, t, r);
                }) : O(e, t, r);
            },
            set: function(e, n, r) {
                var o, a = r && $e(e), i = r && P(e, t, r, "border-box" === re.css(e, "boxSizing", !1, a), a);
                return i && (o = Te.exec(n)) && "px" !== (o[3] || "px") && (e.style[t] = n, n = re.css(e, t)), 
                M(0, n, i);
            }
        };
    }), re.cssHooks.marginLeft = T(ne.reliableMarginLeft, function(e, t) {
        if (t) return (parseFloat(N(e, "marginLeft")) || e.getBoundingClientRect().left - Ke(e, {
            marginLeft: 0
        }, function() {
            return e.getBoundingClientRect().left;
        })) + "px";
    }), re.cssHooks.marginRight = T(ne.reliableMarginRight, function(e, t) {
        if (t) return Ke(e, {
            display: "inline-block"
        }, N, [ e, "marginRight" ]);
    }), re.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(e, t) {
        re.cssHooks[e + t] = {
            expand: function(n) {
                for (var r = 0, o = {}, a = "string" == typeof n ? n.split(" ") : [ n ]; r < 4; r++) o[e + Ie[r] + t] = a[r] || a[r - 2] || a[0];
                return o;
            }
        }, We.test(e) || (re.cssHooks[e + t].set = M);
    }), re.fn.extend({
        css: function(e, t) {
            return be(this, function(e, t, n) {
                var r, o, a = {}, i = 0;
                if (re.isArray(t)) {
                    for (r = $e(e), o = t.length; i < o; i++) a[t[i]] = re.css(e, t[i], !1, r);
                    return a;
                }
                return void 0 !== n ? re.style(e, t, n) : re.css(e, t);
            }, e, t, arguments.length > 1);
        },
        show: function() {
            return D(this, !0);
        },
        hide: function() {
            return D(this);
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                Me(this) ? re(this).show() : re(this).hide();
            });
        }
    }), re.Tween = L, L.prototype = {
        constructor: L,
        init: function(e, t, n, r, o, a) {
            this.elem = e, this.prop = n, this.easing = o || re.easing._default, this.options = t, 
            this.start = this.now = this.cur(), this.end = r, this.unit = a || (re.cssNumber[n] ? "" : "px");
        },
        cur: function() {
            var e = L.propHooks[this.prop];
            return e && e.get ? e.get(this) : L.propHooks._default.get(this);
        },
        run: function(e) {
            var t, n = L.propHooks[this.prop];
            return this.options.duration ? this.pos = t = re.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, 
            this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            n && n.set ? n.set(this) : L.propHooks._default.set(this), this;
        }
    }, L.prototype.init.prototype = L.prototype, L.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = re.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0;
            },
            set: function(e) {
                re.fx.step[e.prop] ? re.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[re.cssProps[e.prop]] && !re.cssHooks[e.prop] ? e.elem[e.prop] = e.now : re.style(e.elem, e.prop, e.now + e.unit);
            }
        }
    }, L.propHooks.scrollTop = L.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now);
        }
    }, re.easing = {
        linear: function(e) {
            return e;
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2;
        },
        _default: "swing"
    }, re.fx = L.prototype.init, re.fx.step = {};
    var tt, nt, rt = /^(?:toggle|show|hide)$/, ot = /queueHooks$/;
    re.Animation = re.extend(q, {
        tweeners: {
            "*": [ function(e, t) {
                var n = this.createTween(e, t);
                return l(n.elem, e, Te.exec(t), n), n;
            } ]
        },
        tweener: function(e, t) {
            re.isFunction(e) ? (t = e, e = [ "*" ]) : e = e.match(ye);
            for (var n, r = 0, o = e.length; r < o; r++) n = e[r], q.tweeners[n] = q.tweeners[n] || [], 
            q.tweeners[n].unshift(t);
        },
        prefilters: [ function(e, t, n) {
            var r, o, a, i, u, s, l, c = this, f = {}, d = e.style, p = e.nodeType && Me(e), m = Se.get(e, "fxshow");
            n.queue || (null == (u = re._queueHooks(e, "fx")).unqueued && (u.unqueued = 0, s = u.empty.fire, 
            u.empty.fire = function() {
                u.unqueued || s();
            }), u.unqueued++, c.always(function() {
                c.always(function() {
                    u.unqueued--, re.queue(e, "fx").length || u.empty.fire();
                });
            })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [ d.overflow, d.overflowX, d.overflowY ], 
            "inline" === ("none" === (l = re.css(e, "display")) ? Se.get(e, "olddisplay") || A(e.nodeName) : l) && "none" === re.css(e, "float") && (d.display = "inline-block")), 
            n.overflow && (d.overflow = "hidden", c.always(function() {
                d.overflow = n.overflow[0], d.overflowX = n.overflow[1], d.overflowY = n.overflow[2];
            }));
            for (r in t) if (o = t[r], rt.exec(o)) {
                if (delete t[r], a = a || "toggle" === o, o === (p ? "hide" : "show")) {
                    if ("show" !== o || !m || void 0 === m[r]) continue;
                    p = !0;
                }
                f[r] = m && m[r] || re.style(e, r);
            } else l = void 0;
            if (re.isEmptyObject(f)) "inline" === ("none" === l ? A(e.nodeName) : l) && (d.display = l); else {
                m ? "hidden" in m && (p = m.hidden) : m = Se.access(e, "fxshow", {}), a && (m.hidden = !p), 
                p ? re(e).show() : c.done(function() {
                    re(e).hide();
                }), c.done(function() {
                    var t;
                    Se.remove(e, "fxshow");
                    for (t in f) re.style(e, t, f[t]);
                });
                for (r in f) i = V(p ? m[r] : 0, r, c), r in m || (m[r] = i.start, p && (i.end = i.start, 
                i.start = "width" === r || "height" === r ? 1 : 0));
            }
        } ],
        prefilter: function(e, t) {
            t ? q.prefilters.unshift(e) : q.prefilters.push(e);
        }
    }), re.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? re.extend({}, e) : {
            complete: n || !n && t || re.isFunction(e) && e,
            duration: e,
            easing: n && t || t && !re.isFunction(t) && t
        };
        return r.duration = re.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in re.fx.speeds ? re.fx.speeds[r.duration] : re.fx.speeds._default, 
        null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
            re.isFunction(r.old) && r.old.call(this), r.queue && re.dequeue(this, r.queue);
        }, r;
    }, re.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(Me).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r);
        },
        animate: function(e, t, n, r) {
            var o = re.isEmptyObject(e), a = re.speed(t, n, r), i = function() {
                var t = q(this, re.extend({}, e), a);
                (o || Se.get(this, "finish")) && t.stop(!0);
            };
            return i.finish = i, o || !1 === a.queue ? this.each(i) : this.queue(a.queue, i);
        },
        stop: function(e, t, n) {
            var r = function(e) {
                var t = e.stop;
                delete e.stop, t(n);
            };
            return "string" != typeof e && (n = t, t = e, e = void 0), t && !1 !== e && this.queue(e || "fx", []), 
            this.each(function() {
                var t = !0, o = null != e && e + "queueHooks", a = re.timers, i = Se.get(this);
                if (o) i[o] && i[o].stop && r(i[o]); else for (o in i) i[o] && i[o].stop && ot.test(o) && r(i[o]);
                for (o = a.length; o--; ) a[o].elem !== this || null != e && a[o].queue !== e || (a[o].anim.stop(n), 
                t = !1, a.splice(o, 1));
                !t && n || re.dequeue(this, e);
            });
        },
        finish: function(e) {
            return !1 !== e && (e = e || "fx"), this.each(function() {
                var t, n = Se.get(this), r = n[e + "queue"], o = n[e + "queueHooks"], a = re.timers, i = r ? r.length : 0;
                for (n.finish = !0, re.queue(this, e, []), o && o.stop && o.stop.call(this, !0), 
                t = a.length; t--; ) a[t].elem === this && a[t].queue === e && (a[t].anim.stop(!0), 
                a.splice(t, 1));
                for (t = 0; t < i; t++) r[t] && r[t].finish && r[t].finish.call(this);
                delete n.finish;
            });
        }
    }), re.each([ "toggle", "show", "hide" ], function(e, t) {
        var n = re.fn[t];
        re.fn[t] = function(e, r, o) {
            return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(E(t, !0), e, r, o);
        };
    }), re.each({
        slideDown: E("show"),
        slideUp: E("hide"),
        slideToggle: E("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, t) {
        re.fn[e] = function(e, n, r) {
            return this.animate(t, e, n, r);
        };
    }), re.timers = [], re.fx.tick = function() {
        var e, t = 0, n = re.timers;
        for (tt = re.now(); t < n.length; t++) (e = n[t])() || n[t] !== e || n.splice(t--, 1);
        n.length || re.fx.stop(), tt = void 0;
    }, re.fx.timer = function(e) {
        re.timers.push(e), e() ? re.fx.start() : re.timers.pop();
    }, re.fx.interval = 13, re.fx.start = function() {
        nt || (nt = e.setInterval(re.fx.tick, re.fx.interval));
    }, re.fx.stop = function() {
        e.clearInterval(nt), nt = null;
    }, re.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, re.fn.delay = function(t, n) {
        return t = re.fx ? re.fx.speeds[t] || t : t, n = n || "fx", this.queue(n, function(n, r) {
            var o = e.setTimeout(n, t);
            r.stop = function() {
                e.clearTimeout(o);
            };
        });
    }, function() {
        var e = K.createElement("input"), t = K.createElement("select"), n = t.appendChild(K.createElement("option"));
        e.type = "checkbox", ne.checkOn = "" !== e.value, ne.optSelected = n.selected, t.disabled = !0, 
        ne.optDisabled = !n.disabled, (e = K.createElement("input")).value = "t", e.type = "radio", 
        ne.radioValue = "t" === e.value;
    }();
    var at, it = re.expr.attrHandle;
    re.fn.extend({
        attr: function(e, t) {
            return be(this, re.attr, e, t, arguments.length > 1);
        },
        removeAttr: function(e) {
            return this.each(function() {
                re.removeAttr(this, e);
            });
        }
    }), re.extend({
        attr: function(e, t, n) {
            var r, o, a = e.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return void 0 === e.getAttribute ? re.prop(e, t, n) : (1 === a && re.isXMLDoc(e) || (t = t.toLowerCase(), 
            o = re.attrHooks[t] || (re.expr.match.bool.test(t) ? at : void 0)), void 0 !== n ? null === n ? void re.removeAttr(e, t) : o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), 
            n) : o && "get" in o && null !== (r = o.get(e, t)) ? r : null == (r = re.find.attr(e, t)) ? void 0 : r);
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!ne.radioValue && "radio" === t && re.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t;
                    }
                }
            }
        },
        removeAttr: function(e, t) {
            var n, r, o = 0, a = t && t.match(ye);
            if (a && 1 === e.nodeType) for (;n = a[o++]; ) r = re.propFix[n] || n, re.expr.match.bool.test(n) && (e[r] = !1), 
            e.removeAttribute(n);
        }
    }), at = {
        set: function(e, t, n) {
            return !1 === t ? re.removeAttr(e, n) : e.setAttribute(n, n), n;
        }
    }, re.each(re.expr.match.bool.source.match(/\w+/g), function(e, t) {
        var n = it[t] || re.find.attr;
        it[t] = function(e, t, r) {
            var o, a;
            return r || (a = it[t], it[t] = o, o = null != n(e, t, r) ? t.toLowerCase() : null, 
            it[t] = a), o;
        };
    });
    var ut = /^(?:input|select|textarea|button)$/i, st = /^(?:a|area)$/i;
    re.fn.extend({
        prop: function(e, t) {
            return be(this, re.prop, e, t, arguments.length > 1);
        },
        removeProp: function(e) {
            return this.each(function() {
                delete this[re.propFix[e] || e];
            });
        }
    }), re.extend({
        prop: function(e, t, n) {
            var r, o, a = e.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return 1 === a && re.isXMLDoc(e) || (t = re.propFix[t] || t, 
            o = re.propHooks[t]), void 0 !== n ? o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : e[t] = n : o && "get" in o && null !== (r = o.get(e, t)) ? r : e[t];
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var t = re.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : ut.test(e.nodeName) || st.test(e.nodeName) && e.href ? 0 : -1;
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }), ne.optSelected || (re.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex, null;
        },
        set: function(e) {
            var t = e.parentNode;
            t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex);
        }
    }), re.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        re.propFix[this.toLowerCase()] = this;
    });
    var lt = /[\t\r\n\f]/g;
    re.fn.extend({
        addClass: function(e) {
            var t, n, r, o, a, i, u, s = 0;
            if (re.isFunction(e)) return this.each(function(t) {
                re(this).addClass(e.call(this, t, B(this)));
            });
            if ("string" == typeof e && e) for (t = e.match(ye) || []; n = this[s++]; ) if (o = B(n), 
            r = 1 === n.nodeType && (" " + o + " ").replace(lt, " ")) {
                for (i = 0; a = t[i++]; ) r.indexOf(" " + a + " ") < 0 && (r += a + " ");
                o !== (u = re.trim(r)) && n.setAttribute("class", u);
            }
            return this;
        },
        removeClass: function(e) {
            var t, n, r, o, a, i, u, s = 0;
            if (re.isFunction(e)) return this.each(function(t) {
                re(this).removeClass(e.call(this, t, B(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof e && e) for (t = e.match(ye) || []; n = this[s++]; ) if (o = B(n), 
            r = 1 === n.nodeType && (" " + o + " ").replace(lt, " ")) {
                for (i = 0; a = t[i++]; ) for (;r.indexOf(" " + a + " ") > -1; ) r = r.replace(" " + a + " ", " ");
                o !== (u = re.trim(r)) && n.setAttribute("class", u);
            }
            return this;
        },
        toggleClass: function(e, t) {
            var n = typeof e;
            return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : re.isFunction(e) ? this.each(function(n) {
                re(this).toggleClass(e.call(this, n, B(this), t), t);
            }) : this.each(function() {
                var t, r, o, a;
                if ("string" === n) for (r = 0, o = re(this), a = e.match(ye) || []; t = a[r++]; ) o.hasClass(t) ? o.removeClass(t) : o.addClass(t); else void 0 !== e && "boolean" !== n || ((t = B(this)) && Se.set(this, "__className__", t), 
                this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : Se.get(this, "__className__") || ""));
            });
        },
        hasClass: function(e) {
            var t, n, r = 0;
            for (t = " " + e + " "; n = this[r++]; ) if (1 === n.nodeType && (" " + B(n) + " ").replace(lt, " ").indexOf(t) > -1) return !0;
            return !1;
        }
    });
    var ct = /\r/g, ft = /[\x20\t\r\n\f]+/g;
    re.fn.extend({
        val: function(e) {
            var t, n, r, o = this[0];
            {
                if (arguments.length) return r = re.isFunction(e), this.each(function(n) {
                    var o;
                    1 === this.nodeType && (null == (o = r ? e.call(this, n, re(this).val()) : e) ? o = "" : "number" == typeof o ? o += "" : re.isArray(o) && (o = re.map(o, function(e) {
                        return null == e ? "" : e + "";
                    })), (t = re.valHooks[this.type] || re.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, o, "value") || (this.value = o));
                });
                if (o) return (t = re.valHooks[o.type] || re.valHooks[o.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(o, "value")) ? n : "string" == typeof (n = o.value) ? n.replace(ct, "") : null == n ? "" : n;
            }
        }
    }), re.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = re.find.attr(e, "value");
                    return null != t ? t : re.trim(re.text(e)).replace(ft, " ");
                }
            },
            select: {
                get: function(e) {
                    for (var t, n, r = e.options, o = e.selectedIndex, a = "select-one" === e.type || o < 0, i = a ? null : [], u = a ? o + 1 : r.length, s = o < 0 ? u : a ? o : 0; s < u; s++) if (((n = r[s]).selected || s === o) && (ne.optDisabled ? !n.disabled : null === n.getAttribute("disabled")) && (!n.parentNode.disabled || !re.nodeName(n.parentNode, "optgroup"))) {
                        if (t = re(n).val(), a) return t;
                        i.push(t);
                    }
                    return i;
                },
                set: function(e, t) {
                    for (var n, r, o = e.options, a = re.makeArray(t), i = o.length; i--; ) ((r = o[i]).selected = re.inArray(re.valHooks.option.get(r), a) > -1) && (n = !0);
                    return n || (e.selectedIndex = -1), a;
                }
            }
        }
    }), re.each([ "radio", "checkbox" ], function() {
        re.valHooks[this] = {
            set: function(e, t) {
                if (re.isArray(t)) return e.checked = re.inArray(re(e).val(), t) > -1;
            }
        }, ne.checkOn || (re.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on" : e.value;
        });
    });
    var dt = /^(?:focusinfocus|focusoutblur)$/;
    re.extend(re.event, {
        trigger: function(t, n, r, o) {
            var a, i, u, s, l, c, f, d = [ r || K ], p = te.call(t, "type") ? t.type : t, m = te.call(t, "namespace") ? t.namespace.split(".") : [];
            if (i = u = r = r || K, 3 !== r.nodeType && 8 !== r.nodeType && !dt.test(p + re.event.triggered) && (p.indexOf(".") > -1 && (p = (m = p.split(".")).shift(), 
            m.sort()), l = p.indexOf(":") < 0 && "on" + p, t = t[re.expando] ? t : new re.Event(p, "object" == typeof t && t), 
            t.isTrigger = o ? 2 : 3, t.namespace = m.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            t.result = void 0, t.target || (t.target = r), n = null == n ? [ t ] : re.makeArray(n, [ t ]), 
            f = re.event.special[p] || {}, o || !f.trigger || !1 !== f.trigger.apply(r, n))) {
                if (!o && !f.noBubble && !re.isWindow(r)) {
                    for (s = f.delegateType || p, dt.test(s + p) || (i = i.parentNode); i; i = i.parentNode) d.push(i), 
                    u = i;
                    u === (r.ownerDocument || K) && d.push(u.defaultView || u.parentWindow || e);
                }
                for (a = 0; (i = d[a++]) && !t.isPropagationStopped(); ) t.type = a > 1 ? s : f.bindType || p, 
                (c = (Se.get(i, "events") || {})[t.type] && Se.get(i, "handle")) && c.apply(i, n), 
                (c = l && i[l]) && c.apply && xe(i) && (t.result = c.apply(i, n), !1 === t.result && t.preventDefault());
                return t.type = p, o || t.isDefaultPrevented() || f._default && !1 !== f._default.apply(d.pop(), n) || !xe(r) || l && re.isFunction(r[p]) && !re.isWindow(r) && ((u = r[l]) && (r[l] = null), 
                re.event.triggered = p, r[p](), re.event.triggered = void 0, u && (r[l] = u)), t.result;
            }
        },
        simulate: function(e, t, n) {
            var r = re.extend(new re.Event(), n, {
                type: e,
                isSimulated: !0
            });
            re.event.trigger(r, null, t);
        }
    }), re.fn.extend({
        trigger: function(e, t) {
            return this.each(function() {
                re.event.trigger(e, t, this);
            });
        },
        triggerHandler: function(e, t) {
            var n = this[0];
            if (n) return re.event.trigger(e, t, n, !0);
        }
    }), re.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
        re.fn[t] = function(e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
        };
    }), re.fn.extend({
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e);
        }
    }), ne.focusin = "onfocusin" in e, ne.focusin || re.each({
        focus: "focusin",
        blur: "focusout"
    }, function(e, t) {
        var n = function(e) {
            re.event.simulate(t, e.target, re.event.fix(e));
        };
        re.event.special[t] = {
            setup: function() {
                var r = this.ownerDocument || this, o = Se.access(r, t);
                o || r.addEventListener(e, n, !0), Se.access(r, t, (o || 0) + 1);
            },
            teardown: function() {
                var r = this.ownerDocument || this, o = Se.access(r, t) - 1;
                o ? Se.access(r, t, o) : (r.removeEventListener(e, n, !0), Se.remove(r, t));
            }
        };
    });
    var pt = e.location, mt = re.now(), gt = /\?/;
    re.parseJSON = function(e) {
        return JSON.parse(e + "");
    }, re.parseXML = function(t) {
        var n;
        if (!t || "string" != typeof t) return null;
        try {
            n = new e.DOMParser().parseFromString(t, "text/xml");
        } catch (e) {
            n = void 0;
        }
        return n && !n.getElementsByTagName("parsererror").length || re.error("Invalid XML: " + t), 
        n;
    };
    var ht = /#.*$/, vt = /([?&])_=[^&]*/, yt = /^(.*?):[ \t]*([^\r\n]*)$/gm, kt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, bt = /^(?:GET|HEAD)$/, xt = /^\/\//, St = {}, wt = {}, Ct = "*/".concat("*"), At = K.createElement("a");
    At.href = pt.href, re.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: pt.href,
            type: "GET",
            isLocal: kt.test(pt.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Ct,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": re.parseJSON,
                "text xml": re.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? j(j(e, re.ajaxSettings), t) : j(re.ajaxSettings, e);
        },
        ajaxPrefilter: _(St),
        ajaxTransport: _(wt),
        ajax: function(t, n) {
            function r(t, n, r, u) {
                var l, f, y, k, x, w = n;
                2 !== b && (b = 2, s && e.clearTimeout(s), o = void 0, i = u || "", S.readyState = t > 0 ? 4 : 0, 
                l = t >= 200 && t < 300 || 304 === t, r && (k = U(d, S, r)), k = H(d, k, S, l), 
                l ? (d.ifModified && ((x = S.getResponseHeader("Last-Modified")) && (re.lastModified[a] = x), 
                (x = S.getResponseHeader("etag")) && (re.etag[a] = x)), 204 === t || "HEAD" === d.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = k.state, 
                f = k.data, l = !(y = k.error))) : (y = w, !t && w || (w = "error", t < 0 && (t = 0))), 
                S.status = t, S.statusText = (n || w) + "", l ? g.resolveWith(p, [ f, w, S ]) : g.rejectWith(p, [ S, w, y ]), 
                S.statusCode(v), v = void 0, c && m.trigger(l ? "ajaxSuccess" : "ajaxError", [ S, d, l ? f : y ]), 
                h.fireWith(p, [ S, w ]), c && (m.trigger("ajaxComplete", [ S, d ]), --re.active || re.event.trigger("ajaxStop")));
            }
            "object" == typeof t && (n = t, t = void 0), n = n || {};
            var o, a, i, u, s, l, c, f, d = re.ajaxSetup({}, n), p = d.context || d, m = d.context && (p.nodeType || p.jquery) ? re(p) : re.event, g = re.Deferred(), h = re.Callbacks("once memory"), v = d.statusCode || {}, y = {}, k = {}, b = 0, x = "canceled", S = {
                readyState: 0,
                getResponseHeader: function(e) {
                    var t;
                    if (2 === b) {
                        if (!u) for (u = {}; t = yt.exec(i); ) u[t[1].toLowerCase()] = t[2];
                        t = u[e.toLowerCase()];
                    }
                    return null == t ? null : t;
                },
                getAllResponseHeaders: function() {
                    return 2 === b ? i : null;
                },
                setRequestHeader: function(e, t) {
                    var n = e.toLowerCase();
                    return b || (e = k[n] = k[n] || e, y[e] = t), this;
                },
                overrideMimeType: function(e) {
                    return b || (d.mimeType = e), this;
                },
                statusCode: function(e) {
                    var t;
                    if (e) if (b < 2) for (t in e) v[t] = [ v[t], e[t] ]; else S.always(e[S.status]);
                    return this;
                },
                abort: function(e) {
                    var t = e || x;
                    return o && o.abort(t), r(0, t), this;
                }
            };
            if (g.promise(S).complete = h.add, S.success = S.done, S.error = S.fail, d.url = ((t || d.url || pt.href) + "").replace(ht, "").replace(xt, pt.protocol + "//"), 
            d.type = n.method || n.type || d.method || d.type, d.dataTypes = re.trim(d.dataType || "*").toLowerCase().match(ye) || [ "" ], 
            null == d.crossDomain) {
                l = K.createElement("a");
                try {
                    l.href = d.url, l.href = l.href, d.crossDomain = At.protocol + "//" + At.host != l.protocol + "//" + l.host;
                } catch (e) {
                    d.crossDomain = !0;
                }
            }
            if (d.data && d.processData && "string" != typeof d.data && (d.data = re.param(d.data, d.traditional)), 
            G(St, d, n, S), 2 === b) return S;
            (c = re.event && d.global) && 0 == re.active++ && re.event.trigger("ajaxStart"), 
            d.type = d.type.toUpperCase(), d.hasContent = !bt.test(d.type), a = d.url, d.hasContent || (d.data && (a = d.url += (gt.test(a) ? "&" : "?") + d.data, 
            delete d.data), !1 === d.cache && (d.url = vt.test(a) ? a.replace(vt, "$1_=" + mt++) : a + (gt.test(a) ? "&" : "?") + "_=" + mt++)), 
            d.ifModified && (re.lastModified[a] && S.setRequestHeader("If-Modified-Since", re.lastModified[a]), 
            re.etag[a] && S.setRequestHeader("If-None-Match", re.etag[a])), (d.data && d.hasContent && !1 !== d.contentType || n.contentType) && S.setRequestHeader("Content-Type", d.contentType), 
            S.setRequestHeader("Accept", d.dataTypes[0] && d.accepts[d.dataTypes[0]] ? d.accepts[d.dataTypes[0]] + ("*" !== d.dataTypes[0] ? ", " + Ct + "; q=0.01" : "") : d.accepts["*"]);
            for (f in d.headers) S.setRequestHeader(f, d.headers[f]);
            if (d.beforeSend && (!1 === d.beforeSend.call(p, S, d) || 2 === b)) return S.abort();
            x = "abort";
            for (f in {
                success: 1,
                error: 1,
                complete: 1
            }) S[f](d[f]);
            if (o = G(wt, d, n, S)) {
                if (S.readyState = 1, c && m.trigger("ajaxSend", [ S, d ]), 2 === b) return S;
                d.async && d.timeout > 0 && (s = e.setTimeout(function() {
                    S.abort("timeout");
                }, d.timeout));
                try {
                    b = 1, o.send(y, r);
                } catch (e) {
                    if (!(b < 2)) throw e;
                    r(-1, e);
                }
            } else r(-1, "No Transport");
            return S;
        },
        getJSON: function(e, t, n) {
            return re.get(e, t, n, "json");
        },
        getScript: function(e, t) {
            return re.get(e, void 0, t, "script");
        }
    }), re.each([ "get", "post" ], function(e, t) {
        re[t] = function(e, n, r, o) {
            return re.isFunction(n) && (o = o || r, r = n, n = void 0), re.ajax(re.extend({
                url: e,
                type: t,
                dataType: o,
                data: n,
                success: r
            }, re.isPlainObject(e) && e));
        };
    }), re._evalUrl = function(e) {
        return re.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, re.fn.extend({
        wrapAll: function(e) {
            var t;
            return re.isFunction(e) ? this.each(function(t) {
                re(this).wrapAll(e.call(this, t));
            }) : (this[0] && (t = re(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), 
            t.map(function() {
                for (var e = this; e.firstElementChild; ) e = e.firstElementChild;
                return e;
            }).append(this)), this);
        },
        wrapInner: function(e) {
            return re.isFunction(e) ? this.each(function(t) {
                re(this).wrapInner(e.call(this, t));
            }) : this.each(function() {
                var t = re(this), n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e);
            });
        },
        wrap: function(e) {
            var t = re.isFunction(e);
            return this.each(function(n) {
                re(this).wrapAll(t ? e.call(this, n) : e);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                re.nodeName(this, "body") || re(this).replaceWith(this.childNodes);
            }).end();
        }
    }), re.expr.filters.hidden = function(e) {
        return !re.expr.filters.visible(e);
    }, re.expr.filters.visible = function(e) {
        return e.offsetWidth > 0 || e.offsetHeight > 0 || e.getClientRects().length > 0;
    };
    var Nt = /%20/g, Tt = /\[\]$/, It = /\r?\n/g, Mt = /^(?:submit|button|image|reset|file)$/i, Pt = /^(?:input|select|textarea|keygen)/i;
    re.param = function(e, t) {
        var n, r = [], o = function(e, t) {
            t = re.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t);
        };
        if (void 0 === t && (t = re.ajaxSettings && re.ajaxSettings.traditional), re.isArray(e) || e.jquery && !re.isPlainObject(e)) re.each(e, function() {
            o(this.name, this.value);
        }); else for (n in e) W(n, e[n], t, o);
        return r.join("&").replace(Nt, "+");
    }, re.fn.extend({
        serialize: function() {
            return re.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var e = re.prop(this, "elements");
                return e ? re.makeArray(e) : this;
            }).filter(function() {
                var e = this.type;
                return this.name && !re(this).is(":disabled") && Pt.test(this.nodeName) && !Mt.test(e) && (this.checked || !Pe.test(e));
            }).map(function(e, t) {
                var n = re(this).val();
                return null == n ? null : re.isArray(n) ? re.map(n, function(e) {
                    return {
                        name: t.name,
                        value: e.replace(It, "\r\n")
                    };
                }) : {
                    name: t.name,
                    value: n.replace(It, "\r\n")
                };
            }).get();
        }
    }), re.ajaxSettings.xhr = function() {
        try {
            return new e.XMLHttpRequest();
        } catch (e) {}
    };
    var Ot = {
        0: 200,
        1223: 204
    }, Dt = re.ajaxSettings.xhr();
    ne.cors = !!Dt && "withCredentials" in Dt, ne.ajax = Dt = !!Dt, re.ajaxTransport(function(t) {
        var n, r;
        if (ne.cors || Dt && !t.crossDomain) return {
            send: function(o, a) {
                var i, u = t.xhr();
                if (u.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (i in t.xhrFields) u[i] = t.xhrFields[i];
                t.mimeType && u.overrideMimeType && u.overrideMimeType(t.mimeType), t.crossDomain || o["X-Requested-With"] || (o["X-Requested-With"] = "XMLHttpRequest");
                for (i in o) u.setRequestHeader(i, o[i]);
                n = function(e) {
                    return function() {
                        n && (n = r = u.onload = u.onerror = u.onabort = u.onreadystatechange = null, "abort" === e ? u.abort() : "error" === e ? "number" != typeof u.status ? a(0, "error") : a(u.status, u.statusText) : a(Ot[u.status] || u.status, u.statusText, "text" !== (u.responseType || "text") || "string" != typeof u.responseText ? {
                            binary: u.response
                        } : {
                            text: u.responseText
                        }, u.getAllResponseHeaders()));
                    };
                }, u.onload = n(), r = u.onerror = n("error"), void 0 !== u.onabort ? u.onabort = r : u.onreadystatechange = function() {
                    4 === u.readyState && e.setTimeout(function() {
                        n && r();
                    });
                }, n = n("abort");
                try {
                    u.send(t.hasContent && t.data || null);
                } catch (e) {
                    if (n) throw e;
                }
            },
            abort: function() {
                n && n();
            }
        };
    }), re.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(e) {
                return re.globalEval(e), e;
            }
        }
    }), re.ajaxPrefilter("script", function(e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET");
    }), re.ajaxTransport("script", function(e) {
        if (e.crossDomain) {
            var t, n;
            return {
                send: function(r, o) {
                    t = re("<script>").prop({
                        charset: e.scriptCharset,
                        src: e.url
                    }).on("load error", n = function(e) {
                        t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type);
                    }), K.head.appendChild(t[0]);
                },
                abort: function() {
                    n && n();
                }
            };
        }
    });
    var Lt = [], Rt = /(=)\?(?=&|$)|\?\?/;
    re.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Lt.pop() || re.expando + "_" + mt++;
            return this[e] = !0, e;
        }
    }), re.ajaxPrefilter("json jsonp", function(t, n, r) {
        var o, a, i, u = !1 !== t.jsonp && (Rt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Rt.test(t.data) && "data");
        if (u || "jsonp" === t.dataTypes[0]) return o = t.jsonpCallback = re.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, 
        u ? t[u] = t[u].replace(Rt, "$1" + o) : !1 !== t.jsonp && (t.url += (gt.test(t.url) ? "&" : "?") + t.jsonp + "=" + o), 
        t.converters["script json"] = function() {
            return i || re.error(o + " was not called"), i[0];
        }, t.dataTypes[0] = "json", a = e[o], e[o] = function() {
            i = arguments;
        }, r.always(function() {
            void 0 === a ? re(e).removeProp(o) : e[o] = a, t[o] && (t.jsonpCallback = n.jsonpCallback, 
            Lt.push(o)), i && re.isFunction(a) && a(i[0]), i = a = void 0;
        }), "script";
    }), re.parseHTML = function(e, t, n) {
        if (!e || "string" != typeof e) return null;
        "boolean" == typeof t && (n = t, t = !1), t = t || K;
        var r = de.exec(e), o = !n && [];
        return r ? [ t.createElement(r[1]) ] : (r = d([ e ], t, o), o && o.length && re(o).remove(), 
        re.merge([], r.childNodes));
    };
    var Et = re.fn.load;
    re.fn.load = function(e, t, n) {
        if ("string" != typeof e && Et) return Et.apply(this, arguments);
        var r, o, a, i = this, u = e.indexOf(" ");
        return u > -1 && (r = re.trim(e.slice(u)), e = e.slice(0, u)), re.isFunction(t) ? (n = t, 
        t = void 0) : t && "object" == typeof t && (o = "POST"), i.length > 0 && re.ajax({
            url: e,
            type: o || "GET",
            dataType: "html",
            data: t
        }).done(function(e) {
            a = arguments, i.html(r ? re("<div>").append(re.parseHTML(e)).find(r) : e);
        }).always(n && function(e, t) {
            i.each(function() {
                n.apply(this, a || [ e.responseText, t, e ]);
            });
        }), this;
    }, re.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(e, t) {
        re.fn[t] = function(e) {
            return this.on(t, e);
        };
    }), re.expr.filters.animated = function(e) {
        return re.grep(re.timers, function(t) {
            return e === t.elem;
        }).length;
    }, re.offset = {
        setOffset: function(e, t, n) {
            var r, o, a, i, u, s, l = re.css(e, "position"), c = re(e), f = {};
            "static" === l && (e.style.position = "relative"), u = c.offset(), a = re.css(e, "top"), 
            s = re.css(e, "left"), ("absolute" === l || "fixed" === l) && (a + s).indexOf("auto") > -1 ? (i = (r = c.position()).top, 
            o = r.left) : (i = parseFloat(a) || 0, o = parseFloat(s) || 0), re.isFunction(t) && (t = t.call(e, n, re.extend({}, u))), 
            null != t.top && (f.top = t.top - u.top + i), null != t.left && (f.left = t.left - u.left + o), 
            "using" in t ? t.using.call(e, f) : c.css(f);
        }
    }, re.fn.extend({
        offset: function(e) {
            if (arguments.length) return void 0 === e ? this : this.each(function(t) {
                re.offset.setOffset(this, e, t);
            });
            var t, n, r = this[0], o = {
                top: 0,
                left: 0
            }, a = r && r.ownerDocument;
            if (a) return t = a.documentElement, re.contains(t, r) ? (o = r.getBoundingClientRect(), 
            n = z(a), {
                top: o.top + n.pageYOffset - t.clientTop,
                left: o.left + n.pageXOffset - t.clientLeft
            }) : o;
        },
        position: function() {
            if (this[0]) {
                var e, t, n = this[0], r = {
                    top: 0,
                    left: 0
                };
                return "fixed" === re.css(n, "position") ? t = n.getBoundingClientRect() : (e = this.offsetParent(), 
                t = this.offset(), re.nodeName(e[0], "html") || (r = e.offset()), r.top += re.css(e[0], "borderTopWidth", !0), 
                r.left += re.css(e[0], "borderLeftWidth", !0)), {
                    top: t.top - r.top - re.css(n, "marginTop", !0),
                    left: t.left - r.left - re.css(n, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var e = this.offsetParent; e && "static" === re.css(e, "position"); ) e = e.offsetParent;
                return e || Xe;
            });
        }
    }), re.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(e, t) {
        var n = "pageYOffset" === t;
        re.fn[e] = function(r) {
            return be(this, function(e, r, o) {
                var a = z(e);
                if (void 0 === o) return a ? a[t] : e[r];
                a ? a.scrollTo(n ? a.pageXOffset : o, n ? o : a.pageYOffset) : e[r] = o;
            }, e, r, arguments.length);
        };
    }), re.each([ "top", "left" ], function(e, t) {
        re.cssHooks[t] = T(ne.pixelPosition, function(e, n) {
            if (n) return n = N(e, t), ze.test(n) ? re(e).position()[t] + "px" : n;
        });
    }), re.each({
        Height: "height",
        Width: "width"
    }, function(e, t) {
        re.each({
            padding: "inner" + e,
            content: t,
            "": "outer" + e
        }, function(n, r) {
            re.fn[r] = function(r, o) {
                var a = arguments.length && (n || "boolean" != typeof r), i = n || (!0 === r || !0 === o ? "margin" : "border");
                return be(this, function(t, n, r) {
                    var o;
                    return re.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (o = t.documentElement, 
                    Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e])) : void 0 === r ? re.css(t, n, i) : re.style(t, n, r, i);
                }, t, a ? r : void 0, a, null);
            };
        });
    }), re.fn.extend({
        bind: function(e, t, n) {
            return this.on(e, null, t, n);
        },
        unbind: function(e, t) {
            return this.off(e, null, t);
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r);
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
        },
        size: function() {
            return this.length;
        }
    }), re.fn.andSelf = re.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return re;
    });
    var Vt = e.jQuery, Ft = e.$;
    return re.noConflict = function(t) {
        return e.$ === re && (e.$ = Ft), t && e.jQuery === re && (e.jQuery = Vt), re;
    }, t || (e.jQuery = e.$ = re), re;
});

var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(e, t) {
    "use strict";
    function n(e, t, n, r) {
        for (var o = e[n], a = 0; a < r.length - 1; ++a) o = r[a + 1](o, n);
        t[n] = o;
    }
    function r(e, n, r, o) {
        for (var a = 0; a < r; ++a) e = o(e, n[a], a, t.makeArray(n));
        return e;
    }
    function o(e, t, n, o) {
        for (var a = [], i = 0; i < e.length; ++i) {
            var u = r(e[i], t, n, o[i]);
            void 0 !== u && a.push(u);
        }
        return a;
    }
    t.version = "Infusion 3.0.0", t.Error = Error, t.environment = {
        fluid: t
    }, t.global = t.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
    t.invokeLater = function(e) {
        return setTimeout(e, 1);
    }, t.defeatLogging = !0, t.activityTracing = !1, t.activityTrace = [];
    var a = /(%\w+)/g;
    t.renderOneActivity = function(e, t) {
        for (var n = !0 === t ? [] : [ "    while " ], r = e.message, o = a.lastIndex = 0; ;) {
            var i = a.exec(r);
            if (!i) break;
            var u = i[1].substring(1);
            n.push(r.substring(o, i.index)), n.push(e.args[u]), o = a.lastIndex;
        }
        return o < r.length && n.push(r.substring(o)), n;
    }, t.renderActivity = function(e, n) {
        return n = n || t.renderOneActivity, t.transform(e, n);
    }, t.singleThreadLocal = function(e) {
        var t = e();
        return function(e) {
            return void 0 === e ? t : t = e;
        };
    }, t.threadLocal = t.singleThreadLocal, t.globalThreadLocal = t.threadLocal(function() {
        return {};
    }), t.getActivityStack = function() {
        var e = t.globalThreadLocal();
        return e.activityStack || (e.activityStack = []), e.activityStack;
    }, t.describeActivity = t.getActivityStack, t.logActivity = function(e) {
        e = e || t.describeActivity();
        var n = t.renderActivity(e).reverse();
        t.log("Current activity: "), t.each(n, function(e) {
            t.doLog(e);
        });
    }, t.pushActivity = function(e, n, r) {
        var o = {
            type: e,
            message: n,
            args: r,
            time: new Date().getTime()
        };
        t.activityTracing && t.activityTrace.push(o), t.passLogLevel(t.logLevel.TRACE) && t.doLog(t.renderOneActivity(o, !0)), 
        t.getActivityStack().push(o);
    }, t.popActivity = function(e) {
        e = e || 1, t.activityTracing && t.activityTrace.push({
            pop: e
        });
        var n = t.getActivityStack(), r = n.length - e;
        n.length = r < 0 ? 0 : r;
    }, t.FluidError = function() {
        var e = Error.apply(this, arguments);
        this.message = e.message;
        try {
            throw e;
        } catch (e) {
            this.stack = e.stack;
        }
        return this;
    }, t.FluidError.prototype = Object.create(Error.prototype), t.logFailure = function(e, n) {
        t.log.apply(null, [ t.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), t.logActivity(n);
    }, t.renderLoggingArg = function(e) {
        return void 0 === e ? "undefined" : t.isPrimitive(e) || !t.isPlainObject(e) ? e : JSON.stringify(e);
    }, t.builtinFail = function(e) {
        var n = t.transform(e, t.renderLoggingArg).join("");
        throw new t.FluidError("Assertion failure - check console for more details: " + n);
    }, t.fail = function() {
        var e = t.makeArray(arguments), n = t.makeArray(t.describeActivity());
        t.popActivity(n.length), t.failureEvent ? t.failureEvent.fire(e, n) : (t.logFailure(e, n), 
        t.builtinFail(e, n));
    }, t.expect = function(e, n, r) {
        t.transform(t.makeArray(r), function(r) {
            void 0 === n[r] && t.fail(e + " missing required parameter " + r);
        });
    }, t.isLogging = function() {
        return i[0].priority > t.logLevel.IMPORTANT.priority;
    }, t.isLogLevel = function(e) {
        return t.isMarker(e) && void 0 !== e.priority;
    }, t.passLogLevel = function(e) {
        return e.priority <= i[0].priority;
    }, t.setLogging = function(e) {
        var n;
        "boolean" == typeof e ? n = t.logLevel[e ? "INFO" : "IMPORTANT"] : t.isLogLevel(e) ? n = e : t.fail("Unrecognised fluid logging level ", e), 
        i.unshift(n), t.defeatLogging = !t.isLogging();
    }, t.setLogLevel = t.setLogging, t.popLogging = function() {
        var e = 1 === i.length ? i[0] : i.shift();
        return t.defeatLogging = !t.isLogging(), e;
    }, t.doLog = function(e) {
        "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
    }, t.log = function() {
        var e = t.makeArray(arguments), n = t.logLevel.INFO;
        if (t.isLogLevel(e[0]) && (n = e.shift()), t.passLogLevel(n)) {
            var r = [ t.renderTimestamp(new Date()) + ":  " ].concat(e);
            t.doLog(r);
        }
    }, t.isValue = function(e) {
        return void 0 !== e && null !== e;
    }, t.isPrimitive = function(e) {
        var t = typeof e;
        return !e || "string" === t || "boolean" === t || "number" === t || "function" === t;
    }, t.isArrayable = function(e) {
        return e && (e.jquery || "[object Array]" === Object.prototype.toString.call(e));
    }, t.isPlainObject = function(e, t) {
        var n = Object.prototype.toString.call(e);
        return "[object Array]" === n ? !t : "[object Object]" === n && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
    }, t.typeCode = function(e) {
        return t.isPrimitive(e) || !t.isPlainObject(e) ? "primitive" : t.isArrayable(e) ? "array" : "object";
    }, t.isIoCReference = function(e) {
        return "string" == typeof e && "{" === e.charAt(0) && e.indexOf("}") > 0;
    }, t.isDOMNode = function(e) {
        return e && "number" == typeof e.nodeType;
    }, t.isComponent = function(e) {
        return e && e.constructor === t.componentConstructor;
    }, t.isUncopyable = function(e) {
        return t.isPrimitive(e) || !t.isPlainObject(e);
    }, t.isApplicable = function(e) {
        return e.apply && "function" == typeof e.apply;
    }, t.identity = function(e) {
        return e;
    }, t.notImplemented = function() {
        t.fail("This operation is not implemented");
    }, t.firstDefined = function(e, t) {
        return void 0 === e ? t : e;
    }, t.freshContainer = function(e) {
        return t.isArrayable(e) ? [] : {};
    }, t.copyRecurse = function(e, n) {
        return n.length > t.strategyRecursionBailout && t.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + t.strategyRecursionBailout + " via path of " + n.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
        t.isUncopyable(e) ? e : t.transform(e, function(e, r) {
            n.push(r);
            var o = t.copyRecurse(e, n);
            return n.pop(), o;
        });
    }, t.copy = function(e) {
        return t.copyRecurse(e, []);
    }, t.extend = e.extend, t.makeArray = function(e) {
        var n = [];
        if (null !== e && void 0 !== e) if (t.isPrimitive(e) || t.isPlainObject(e, !0) || "number" != typeof e.length) n.push(e); else for (var r = 0; r < e.length; ++r) n[r] = e[r];
        return n;
    }, t.pushArray = function(e, n, r) {
        var o = e[n] ? e[n] : e[n] = [];
        t.isArrayable(r) ? o.push.apply(o, r) : o.push(r);
    }, t.transform = function(e) {
        if (t.isPrimitive(e)) return e;
        var r = t.freshContainer(e);
        if (t.isArrayable(e)) for (var o = 0; o < e.length; ++o) n(e, r, o, arguments); else for (var a in e) n(e, r, a, arguments);
        return r;
    }, t.each = function(e, n) {
        if (t.isArrayable(e)) for (var r = 0; r < e.length; ++r) n(e[r], r); else for (var o in e) n(e[o], o);
    }, t.make_find = function(e) {
        var n = !e && void 0;
        return function(r, o, a) {
            var i;
            if (t.isArrayable(r)) {
                for (var u = 0; u < r.length; ++u) if ((i = o(r[u], u)) !== n) return e ? r[u] : i;
            } else for (var s in r) if ((i = o(r[s], s)) !== n) return e ? r[s] : i;
            return a;
        };
    }, t.find = t.make_find(!1), t.find_if = t.make_find(!0), t.accumulate = function(e, t, n) {
        for (var r = 0; r < e.length; ++r) n = t(e[r], n, r);
        return n;
    }, t.add = function(e, t) {
        return e + t;
    }, t.remove_if = function(e, n, r) {
        if (t.isArrayable(e)) for (var o = e.length - 1; o >= 0; --o) n(e[o], o) && (r && r.unshift(e[o]), 
        e.splice(o, 1)); else for (var a in e) n(e[a], a) && (r && (r[a] = e[a]), delete e[a]);
        return r || e;
    }, t.generate = function(e, t, n) {
        for (var r = [], o = 0; o < e; ++o) r[o] = n ? t(o) : t;
        return r;
    }, t.iota = function(e, t) {
        t = t || 0;
        for (var n = [], r = 0; r < e; ++r) n[n.length] = t++;
        return n;
    }, t.getMembers = function(e, n) {
        return t.transform(e, function(e) {
            return t.get(e, n);
        });
    }, t.filterKeys = function(n, r, o) {
        return t.remove_if(e.extend({}, n), function(e, t) {
            return o ^ -1 === r.indexOf(t);
        });
    }, t.censorKeys = function(e, n) {
        return t.filterKeys(e, n, !0);
    }, t.keys = function(e) {
        var t = [];
        for (var n in e) t.push(n);
        return t;
    }, t.values = function(e) {
        var t = [];
        for (var n in e) t.push(e[n]);
        return t;
    }, t.contains = function(e, n) {
        return e ? t.isArrayable(e) ? -1 !== e.indexOf(n) : t.find(e, function(e) {
            if (n === e) return !0;
        }) : void 0;
    }, t.keyForValue = function(e, n) {
        return t.find(e, function(e, t) {
            if (n === e) return t;
        });
    }, t.arrayToHash = function(e) {
        var n = {};
        return t.each(e, function(e) {
            n[e] = !0;
        }), n;
    }, t.stableSort = function(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r, o = e[n];
            for (r = n; r > 0 && t(o, e[r - 1]) < 0; r--) e[r] = e[r - 1];
            e[r] = o;
        }
    }, t.hashToArray = function(n, r, o) {
        var a = [];
        return t.each(n, function(t, n) {
            var i = {};
            i[r] = n, o ? i = o(i, t, n) || i : e.extend(!0, i, t), a.push(i);
        }), a;
    }, t.flatten = function(e) {
        var n = [];
        return t.each(e, function(e) {
            t.isArrayable(e) ? n = n.concat(e) : n.push(e);
        }), n;
    }, t.clear = function(e) {
        if (t.isArrayable(e)) e.length = 0; else for (var n in e) delete e[n];
    }, t.compareStringLength = function(e) {
        return e ? function(e, t) {
            return e.length - t.length;
        } : function(e, t) {
            return t.length - e.length;
        };
    }, t.parseInteger = function(e) {
        return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
    }, t.roundToDecimal = function(e, t, n) {
        if (t = t && t >= 0 ? Math.round(t) : 0, "ceil" === n || "floor" === n) return Number(Math[n](e + "e" + t) + "e-" + t);
        var r = e >= 0 ? 1 : -1;
        return Number(r * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
    }, t.debounce = function(e, t, n) {
        var r, o;
        return function() {
            var a = this, i = arguments, u = n && !r;
            return clearTimeout(r), r = setTimeout(function() {
                r = null, n || (o = e.apply(a, i));
            }, t), u && (o = e.apply(a, i)), o;
        };
    }, t.freezeRecursive = function(e) {
        return t.isPlainObject(e) ? (t.each(e, function(e) {
            t.freezeRecursive(e);
        }), Object.freeze(e)) : e;
    }, t.marker = function() {}, t.makeMarker = function(n, r) {
        var o = Object.create(t.marker.prototype);
        return o.value = n, e.extend(o, r), Object.freeze(o);
    }, t.VALUE = t.makeMarker("VALUE"), t.NO_VALUE = t.makeMarker("NO_VALUE"), t.EXPAND = t.makeMarker("EXPAND"), 
    t.isMarker = function(e, n) {
        return e instanceof t.marker && (!n || e.value === n.value);
    }, t.logLevelsSpec = {
        FATAL: 0,
        FAIL: 5,
        WARN: 10,
        IMPORTANT: 12,
        INFO: 15,
        TRACE: 20
    }, t.logLevel = t.transform(t.logLevelsSpec, function(e, n) {
        return t.makeMarker(n, {
            priority: e
        });
    });
    var i = [ t.logLevel.IMPORTANT ];
    t.model = {}, t.model.copyModel = function(n, r) {
        t.clear(n), e.extend(!0, n, r);
    }, t.model.parseEL = function(e) {
        return "" === e ? [] : String(e).split(".");
    }, t.model.composePath = function(e, t) {
        return "" === e ? t : "" === t ? e : e + "." + t;
    }, t.model.composeSegments = function() {
        return t.makeArray(arguments).join(".");
    }, t.lastDotIndex = function(e) {
        return e.lastIndexOf(".");
    }, t.model.getToTailPath = function(e) {
        var n = t.lastDotIndex(e);
        return -1 === n ? "" : e.substring(0, n);
    }, t.model.getTailPath = function(e) {
        var n = t.lastDotIndex(e);
        return e.substring(n + 1);
    }, t.path = t.model.composeSegments, t.composePath = t.model.composePath, t.requireDataBinding = function() {
        t.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    }, t.model.setWithStrategy = t.model.getWithStrategy = t.requireDataBinding, t.model.resolvePathSegment = function(e, t, n, r) {
        if (!r && e.resolvePathSegment) {
            var o = e.resolvePathSegment(t);
            if (void 0 !== o) return o;
        }
        return n && void 0 === e[t] ? e[t] = {} : e[t];
    }, t.model.parseToSegments = function(e, n, r) {
        return "number" == typeof e || "string" == typeof e ? n(e) : r ? t.makeArray(e) : e;
    }, t.model.pathToSegments = function(e, n) {
        var r = n && n.parser ? n.parser.parse : t.model.parseEL;
        return t.model.parseToSegments(e, r);
    }, t.model.accessImpl = function(e, n, r, o, a, i, u) {
        var s = t.model.pathToSegments(n, o), l = 0;
        if (a && (l = a.length, s = a.concat(s)), e = u(e, s, l, o, r === t.NO_VALUE ? 0 : 1), 
        r === t.NO_VALUE || r === t.VALUE) return i ? {
            root: e,
            segs: s
        } : e;
        e[s[s.length - 1]] = r;
    }, t.model.accessSimple = function(e, n, r, o, a, i) {
        return t.model.accessImpl(e, n, r, o, a, i, t.model.traverseSimple);
    }, t.model.traverseSimple = function(e, n, r, o, a) {
        for (var i = o, u = n.length - a, s = 0; s < u; ++s) {
            if (!e) return;
            var l = n[s];
            e = o && o[l] ? o[l] : t.model.resolvePathSegment(e, l, 1 === a, i), o = null;
        }
        return e;
    }, t.model.setSimple = function(e, n, r, o, a) {
        t.model.accessSimple(e, n, r, o, a, !1);
    }, t.model.getSimple = function(e, n, r, o) {
        return null === n || void 0 === n || 0 === n.length ? e : t.model.accessSimple(e, n, t.NO_VALUE, r, o, !1);
    }, t.getImmediate = function(e, t, n) {
        for (var r = void 0 === n ? t.length : n + 1, o = 0; o < r; ++o) e = e ? e[t[o]] : void 0;
        return e;
    }, t.decodeAccessorArg = function(e) {
        return e && e !== t.model.defaultGetConfig && e !== t.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
    }, t.set = function(e, n, r, o, a) {
        var i = t.decodeAccessorArg(o);
        void 0 === i ? t.model.setWithStrategy(e, n, r, o, a) : t.model.setSimple(e, n, r, i, a);
    }, t.get = function(e, n, r, o) {
        var a = t.decodeAccessorArg(r);
        return void 0 === a ? t.model.getWithStrategy(e, n, r, o) : t.model.accessImpl(e, n, t.NO_VALUE, a, null, !1, t.model.traverseSimple);
    }, t.getGlobalValue = function(e, n) {
        if (e) return n = n || t.environment, t.get(t.global, e, {
            type: "environment",
            value: n
        });
    }, t.bind = function(e, n, r) {
        return e[n].apply(e, t.makeArray(r));
    }, t.invokeGlobalFunction = function(e, n, r) {
        var o = t.getGlobalValue(e, r);
        if (o) return o.apply(null, t.isArrayable(n) ? n : t.makeArray(n));
        t.fail("Error invoking global function: " + e + " could not be located");
    }, t.registerGlobalFunction = function(e, n, r) {
        r = r || t.environment, t.set(t.global, e, n, {
            type: "environment",
            value: r
        });
    }, t.setGlobalValue = t.registerGlobalFunction, t.registerNamespace = function(e, n) {
        n = n || t.environment;
        var r = t.getGlobalValue(e, n);
        return r || (r = {}, t.setGlobalValue(e, r, n)), r;
    }, t.dumpEl = t.identity, t.renderTimestamp = t.identity, t.generateUniquePrefix = function() {
        return Math.floor(1e12 * Math.random()).toString(36) + "-";
    };
    var u = t.generateUniquePrefix();
    t.fluidInstance = u;
    var s = 1;
    t.allocateGuid = function() {
        return u + s++;
    }, t.registerNamespace("fluid.event"), t.extremePriority = 4e9, t.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    }, t.extremalPriorities = {
        none: 0,
        testing: 10,
        authoring: 20
    }, t.parsePriorityConstraint = function(e, n, r) {
        var o = e.split(":"), a = o[0], i = t.priorityTypes[a];
        return void 0 === i && t.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + t.keys(t.priorityTypes).join(", ") + " or numeric"), 
        n && 0 === i && t.fail("Constraint type in priority field " + e + " is not supported in a " + r + " record - you must use either a numeric value or first, last"), 
        {
            type: o[0],
            target: o[1]
        };
    }, t.parsePriority = function(e, n, r, o) {
        e = e || 0;
        var a = {
            count: n || 0,
            fixed: null,
            constraint: null,
            site: o
        };
        "number" == typeof e ? a.fixed = -e : a.constraint = t.parsePriorityConstraint(e, r, o);
        var i = a.constraint ? t.priorityTypes[a.constraint.type] : 0;
        if (0 !== i) {
            var u = a.constraint.target || "none", s = t.extremalPriorities[u];
            void 0 === s && t.fail("Unrecognised extremal priority target " + u + ": the currently supported values are " + t.keys(t.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
            a.fixed = i * (t.extremePriority + s);
        }
        return null !== a.fixed && (a.fixed += a.count / 1024), a;
    }, t.renderPriority = function(e) {
        return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
    }, t.compareByPriority = function(e, t) {
        return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
    }, t.honourConstraint = function(e, n, r) {
        var o = e[r].priority.constraint, a = t.find(e, function(e, t) {
            return e.namespace === o.target ? t : void 0;
        }, -1);
        if (-1 === a) return !0;
        if (a >= n) return !1;
        for (var i = a + ("after" === o.type ? 1 : 0), u = e[r], s = r; s >= i; --s) e[s] = e[s - 1];
        return e[i] = u, !0;
    }, t.sortByPriority = function(e) {
        t.stableSort(e, t.compareByPriority);
        for (var n = t.find(e, function(e, n) {
            return e.priority.constraint && 0 === t.priorityTypes[e.priority.constraint.type] ? n : void 0;
        }, e.length); ;) {
            if (n === e.length) return e;
            for (var r = n, o = n; o < e.length; ++o) t.honourConstraint(e, n, o) && ++n;
            if (n === r) {
                var a = e.slice(n);
                t.fail("Could not find targets for any constraints in " + a[0].priority.site + " ", a, ": none of the targets (" + t.getMembers(a, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, n), ") - this is caused by either an invalid or circular reference");
            }
        }
    }, t.parsePriorityRecords = function(n, r) {
        var o = t.hashToArray(n, "namespace", function(n, o, a) {
            e.extend(n, o), n.priority = t.parsePriority(o.priority, a, !1, r);
        });
        return t.sortByPriority(o), o;
    }, t.event.identifyListener = function(e, n) {
        return "string" == typeof e || e.$$fluid_guid || n || (e.$$fluid_guid = t.allocateGuid()), 
        e.$$fluid_guid;
    }, t.event.impersonateListener = function(e, n) {
        t.event.identifyListener(e), n.$$fluid_guid = e.$$fluid_guid;
    }, t.event.sortListeners = function(e) {
        var n = [];
        return t.each(e, function(e) {
            for (var t, r = 0; r < e.length; ++r) {
                var o = e[r];
                o.softNamespace || t || (t = o);
            }
            t ? n.push(t) : n = n.concat(e);
        }), t.sortByPriority(n);
    }, t.event.resolveListener = function(e) {
        var n = e.globalName || ("string" == typeof e ? e : null);
        if (n) {
            var r = t.getGlobalValue(n);
            r ? e = r : t.fail("Unable to look up name " + n + " as a global function");
        }
        return e;
    }, t.nameComponent = function(e) {
        return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
    }, t.event.nameEvent = function(e, n) {
        return n + " of " + t.nameComponent(e);
    }, t.makeEventFirer = function(n) {
        var r, o = (n = n || {}).name || "<anonymous>", a = function() {
            r.listeners = {}, r.byId = {}, r.sortedListeners = [], r.addListener = function(n, o, a, i, u) {
                var s;
                if (r.destroyed && t.fail("Cannot add listener to destroyed event firer " + r.name), 
                n) {
                    t.isPlainObject(n, !0) && !t.isApplicable(n) && (n = (s = n).listener, o = s.namespace, 
                    a = s.priority, i = s.softNamespace, u = s.listenerId), "string" == typeof n && (n = {
                        globalName: n
                    });
                    var l = u || t.event.identifyListener(n);
                    o = o || l, s = e.extend(s || {}, {
                        namespace: o,
                        listener: n,
                        softNamespace: i,
                        listenerId: u,
                        priority: t.parsePriority(a, r.sortedListeners.length, !1, "listeners")
                    }), r.byId[l] = s, (r.listeners[o] = t.makeArray(r.listeners[o]))[i ? "push" : "unshift"](s), 
                    r.sortedListeners = t.event.sortListeners(r.listeners);
                }
            }, r.addListener.apply(null, arguments);
        };
        return r = {
            eventId: t.allocateGuid(),
            name: o,
            ownerId: n.ownerId,
            typeName: "fluid.event.firer",
            destroy: function() {
                r.destroyed = !0;
            },
            addListener: function() {
                a.apply(null, arguments);
            },
            removeListener: function(e) {
                if (r.listeners) {
                    var n, o, a;
                    "string" == typeof e ? (n = e, (a = r.listeners[n]) || (o = n, n = null)) : "function" == typeof e && ((o = t.event.identifyListener(e, !0)) || t.fail("Cannot remove unregistered listener function ", e, " from event " + r.name));
                    var i = r.byId[o], u = i && i.softNamespace;
                    n = n || i && i.namespace || o, delete r.byId[o], (a = r.listeners[n]) && (u ? t.remove_if(a, function(e) {
                        return e.listener.$$fluid_guid === o || e.listenerId === o;
                    }) : a.shift(), 0 === a.length && delete r.listeners[n]), r.sortedListeners = t.event.sortListeners(r.listeners);
                }
            },
            fire: function() {
                var e = r.sortedListeners;
                if (e && !r.destroyed) {
                    t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Firing event " + o + " to list of " + e.length + " listeners");
                    for (var a = 0; a < e.length; ++a) {
                        var i = e[a];
                        i.listener = t.event.resolveListener(i.listener);
                        var u, s = i.listener.apply(null, arguments);
                        if ((n.preventable && !1 === s || r.destroyed) && (u = !1), void 0 !== u) return u;
                    }
                }
            }
        };
    }, t.fireEvent = function(e, n, r) {
        var o = e.events[n];
        o && o.fire.apply(null, t.makeArray(r));
    }, t.event.addListenerToFirer = function(e, n, r, o) {
        if (o = o || t.identity, t.isArrayable(n)) for (var a = 0; a < n.length; ++a) t.event.addListenerToFirer(e, n[a], r, o); else "function" == typeof n || "string" == typeof n ? o(e).addListener(n, r) : n && "object" == typeof n && o(e).addListener(n.listener, r || n.namespace, n.priority, n.softNamespace, n.listenerId);
    }, t.event.resolveListenerRecord = function(e) {
        return {
            records: e
        };
    }, t.expandImmediate = function(e) {
        t.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
    }, t.mergeListeners = function(e, n, r) {
        t.each(r, function(r, o) {
            var a, i;
            if (t.isIoCReference(o)) (a = t.expandImmediate(o, e)) || t.fail("Error in listener record: key " + o + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                var u = o.indexOf(".");
                -1 !== u && (i = o.substring(u + 1), o = o.substring(0, u)), n[o] || t.fail("Listener registered for event " + o + " which is not defined for this component"), 
                a = n[o];
            }
            var s = t.event.resolveListenerRecord(r, e, o, i, !0);
            t.event.addListenerToFirer(a, s.records, i, s.adderWrapper);
        });
    }, t.eventFromRecord = function(e, n, r) {
        var o;
        return e && ("string" != typeof e || t.isIoCReference(e)) ? t.event.resolveEvent ? o = t.event.resolveEvent(r, n, e) : t.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : o = t.makeEventFirer({
            name: t.event.nameEvent(r, n),
            preventable: "preventable" === e,
            ownerId: r.id
        }), o;
    }, t.instantiateFirers = function(e, n) {
        t.each(n.events, function(n, r) {
            e.events[r] = t.eventFromRecord(n, r, e);
        });
    }, t.mergeListenerPolicy = function(e, n, r) {
        return "string" != typeof r && t.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + r + " from ", n), 
        !t.isIoCReference(r) && -1 !== r.indexOf(".") ? n || e : t.arrayConcatPolicy(e, n);
    }, t.makeMergeListenersPolicy = function(e, n) {
        return function(r, o) {
            return r = r || {}, n && (t.isArrayable(o) || "string" == typeof o.target) ? r[""] = e(r[""], o, "") : t.each(o, function(t, n) {
                r[n] = e(r[n], t, n);
            }), r;
        };
    }, t.validateListenersImplemented = function(e) {
        var n = [];
        return t.each(e.events, function(r, o) {
            t.each(r.sortedListeners, function(r) {
                r.listener !== t.notImplemented && "fluid.notImplemented" !== r.listener.globalName || n.push({
                    name: o,
                    namespace: r.namespace,
                    componentSource: t.model.getSimple(e.options.listeners, [ o + "." + r.namespace, 0, "componentSource" ])
                });
            });
        }), n;
    }, t.unique = function(e) {
        return t.remove_if(e, function(t, n) {
            return !t || n > 0 && t === e[n - 1];
        });
    }, t.arrayConcatPolicy = function(e, n) {
        return t.makeArray(e).concat(t.makeArray(n));
    }, t.failureEvent = t.makeEventFirer({
        name: "failure event"
    }), t.failureEvent.addListener(t.builtinFail, "fail"), t.failureEvent.addListener(t.logFailure, "log", "before:fail"), 
    t.pushSoftFailure = function(e) {
        "function" == typeof e ? t.failureEvent.addListener(e, "fail") : -1 === e ? t.failureEvent.removeListener("fail") : "boolean" == typeof e && t.fail("pushSoftFailure with boolean value is no longer supported");
    }, t.componentConstructor = function() {}, t.typeTag = function(e) {
        var n = Object.create(t.componentConstructor.prototype);
        return n.typeName = e, n.id = t.allocateGuid(), n;
    };
    var l = 1, c = {};
    t.defaultsStore = {}, t.resolveGradesImpl = function(e, n) {
        for (var r = (n = t.makeArray(n)).length - 1; r >= 0; --r) {
            var o = n[r];
            if (o && !e.gradeHash[o]) {
                var a = (t.isIoCReference(o) ? null : t.rawDefaults(o)) || {}, i = c[o] || l - 1;
                e.lastTick = Math.max(e.lastTick, i), e.gradeHash[o] = !0, e.gradeChain.push(o);
                for (var u = t.makeArray(a.gradeNames), s = u.length - 1; s >= 0; --s) t.resolveGradesImpl(e, u[s]);
            }
        }
        return e;
    }, t.resolveGradeStructure = function(e, n) {
        var r = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {}
        };
        return t.resolveGradesImpl(r, [ e ].concat(t.makeArray(n))), r.gradeChain.reverse(), 
        r;
    }, t.hasGrade = function(e, n) {
        return !(!e || !e.gradeNames) && t.contains(e.gradeNames, n);
    }, t.resolveGrade = function(n, r, o) {
        var a = t.resolveGradeStructure(r, o), i = t.transform(a.gradeChain, t.rawDefaults, t.copy);
        t.remove_if(i, function(e) {
            return !e;
        });
        for (var u = {}, s = 0; s < i.length; ++s) i[s] && i[s].mergePolicy && (u = e.extend(!0, u, i[s].mergePolicy));
        i = [ u, {} ].concat(i);
        var l = t.merge.apply(null, i);
        return l.gradeNames = a.gradeChain, t.freezeRecursive(l), {
            defaults: l,
            lastTick: a.lastTick
        };
    }, t.mergedDefaultsCache = {}, t.gradeNamesToKey = function(e, t) {
        return e + "|" + t.join("|");
    }, t.getMergedDefaults = function(e, n) {
        n = t.makeArray(n);
        var r = t.gradeNamesToKey(e, n), o = t.mergedDefaultsCache[r];
        if (o) {
            for (var a = 0, i = o.defaults.gradeNames || [], u = 0; u < i.length; ++u) a = Math.max(a, c[i[u]] || 0);
            a > o.lastTick && (t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", i), 
            o = null);
        }
        if (!o) {
            var s = t.rawDefaults(e);
            if (!s) return s;
            o = t.mergedDefaultsCache[r] = t.resolveGrade(s, e, n);
        }
        return o.defaults;
    }, t.upgradePrimitiveFunc = function(e, n) {
        if (e && t.isPrimitive(e)) {
            var r = {};
            return r[n || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
            r.args = t.NO_VALUE, r;
        }
        return e;
    }, t.annotateListeners = function(e, n) {
        n.listeners = t.transform(n.listeners, function(n) {
            var r = t.makeArray(n);
            return t.transform(r, function(n) {
                return n = t.upgradePrimitiveFunc(n, "listener"), n.componentSource = e, n;
            });
        }), n.invokers = t.transform(n.invokers, function(n) {
            return (n = t.upgradePrimitiveFunc(n)) && (n.componentSource = e), n;
        });
    }, t.rawDefaults = function(e) {
        var n = t.defaultsStore[e];
        return n && n.options;
    }, t.registerRawDefaults = function(e, n) {
        t.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
            componentName: e,
            options: n
        });
        var r = t.expandCompact ? t.expandCompact(n) : t.copy(n);
        t.annotateListeners(e, r);
        var o = t.getCallerInfo && t.getCallerInfo(6);
        t.defaultsStore[e] = {
            options: r,
            callerInfo: o
        }, c[e] = l++, t.popActivity();
    }, t.doIndexDefaults = function(e, n, r, o) {
        for (var a = t.makeArray(o.gradeNames), i = 0; i < a.length; ++i) if (!t.hasGrade(n, a[i])) return;
        for (var u = ("function" == typeof o.indexFunc ? o.indexFunc : t.getGlobalValue(o.indexFunc))(n) || [], s = 0; s < u.length; ++s) t.pushArray(r, u[s], e);
    }, t.indexDefaults = function(e, n) {
        var r = {};
        for (var o in t.defaultsStore) {
            var a = t.getMergedDefaults(o);
            t.doIndexDefaults(o, a, r, n);
        }
        return r;
    }, t.defaults = function(e, n) {
        if (void 0 === n) return t.getMergedDefaults(e);
        n && n.options && t.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', n), 
        t.registerRawDefaults(e, n);
        var r = t.getMergedDefaults(e);
        t.hasGrade(r, "fluid.function") || t.makeComponentCreator(e);
    }, t.makeComponentCreator = function(n) {
        var r = function() {
            var e = t.getMergedDefaults(n);
            if (e.gradeNames && 0 !== e.gradeNames.length) {
                if (e.initFunction) return t.initComponent(n, arguments);
                for (var r = [], o = 0; o < e.gradeNames.length; ++o) {
                    var a = e.gradeNames[o];
                    t.rawDefaults(a) || r.push(a);
                }
                0 === r.length ? t.fail("Cannot make component creator for type " + n + " which does not have an initFunction defined") : t.fail("The grade hierarchy of component with type " + n + " is incomplete - it inherits from the following grade(s): " + r.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
            } else t.fail("Cannot make component creator for type " + n + " which does not have any gradeNames defined");
        }, o = t.getGlobalValue(n);
        o && e.extend(r, o), t.setGlobalValue(n, r);
    }, t.emptyPolicy = t.freezeRecursive({}), t.derefMergePolicy = function(e) {
        return (e ? e["*"] : t.emptyPolicy) || t.emptyPolicy;
    }, t.compileMergePolicy = function(e) {
        var n = {}, r = {}, o = {
            builtins: n,
            defaultValues: r
        };
        return e ? (t.each(e, function(e, a) {
            var i = {}, u = !0;
            if ("function" == typeof e) i.func = e; else if ("object" == typeof e) i = e; else if (t.isDefaultValueMergePolicy(e)) t.set(r, a, "{that}.options." + e), 
            o.hasDefaults = !0, u = !1; else for (var s = e.split(/\s*,\s*/), l = 0; l < s.length; ++l) i[s[l]] = !0;
            u && t.set(n, t.composePath(a, "*"), i);
        }), o) : o;
    }, t.isDefaultValueMergePolicy = function(e) {
        return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
    }, t.mergeOneImpl = function(e, n, r, o, a, i, u) {
        var s = e, l = t.isPrimitive(e);
        return void 0 !== n && (a.func || null === n || !t.isPlainObject(n) || a.nomerge ? (o[r] = void 0, 
        s = a.func ? a.func.call(null, e, n, u[i - 1], u, i) : n) : l && (s = e = t.freshContainer(n))), 
        s;
    }, t.fetchMergeChildren = function(e, n, r, o, a, i) {
        for (var u = t.derefMergePolicy(a), s = o.length - 1; s >= 0; --s) {
            var l = o[s];
            if (void 0 !== l && (t.each(l, function(u, s) {
                var l = t.concreteTrundler(a, s);
                s in e && (!i.evaluateFully || void 0 !== l || t.isPrimitive(e[s])) || (r[n] = s, 
                i.strategy(e, s, n + 1, r, o, a));
            }), u.replace)) break;
        }
        return e;
    }, t.inEvaluationMarker = Object.freeze({
        __CURRENTLY_IN_EVALUATION__: !0
    }), t.strategyRecursionBailout = 50, t.makeMergeStrategy = function(e) {
        var n = function(n, a, i, u, s, l) {
            if (i > t.strategyRecursionBailout && t.fail("Overflow/circularity in options merging, current path is ", u, " at depth ", i, ' - please protect components from merging using the "nomerge" merge policy'), 
            !t.isPrimitive(n)) {
                t.isTracing && t.tracing.pathCount.push(t.path(u.slice(0, i)));
                var c;
                if (a in n) {
                    if (c = n[a], !e.evaluateFully) return c;
                } else n !== t.inEvaluationMarker && (n[a] = t.inEvaluationMarker);
                void 0 === s && (u = t.makeArray(u), s = o(e.sources, u, i - 1, e.sourceStrategies), 
                l = r(e.mergePolicy, u, i - 1, t.concreteTrundler));
                var f, d, p, m = t.concreteTrundler(l, a), g = t.derefMergePolicy(m);
                g.replace ? (f = 1 - s.length, d = 0, p = -1) : (f = 0, d = s.length - 1, p = 1);
                for (var h, v = [], y = f; y <= d; ++y) {
                    var k = p * y, b = e.sourceStrategies[k](s[k], a, i, u);
                    if (void 0 !== b && (t.isPrimitive(b) || (v[k] = b), void 0 === c)) {
                        if (-1 === p) {
                            h = n[a] = b;
                            break;
                        }
                        h = t.mergeOneImpl(h, b, y, v, g, i, u, e), n !== t.inEvaluationMarker && (n[a] = h);
                    }
                }
                return void 0 !== c && (h = c), v.length > 0 && t.isPlainObject(h) && t.fetchMergeChildren(h, i, u, v, m, e), 
                void 0 === c && 0 === v.length && delete n[a], h;
            }
        };
        return e.strategy = n, n;
    }, t.driveStrategy = function(e, n, r) {
        n = t.makeArray(n);
        for (var o = 0; o < n.length; ++o) {
            if (!e) return;
            e = r(e, n[o], o + 1, n);
        }
        return e;
    }, t.concreteTrundler = function(e, t) {
        return e ? e[t] : void 0;
    }, t.merge = function(e) {
        var n = Array.prototype.slice.call(arguments, 1), r = t.compileMergePolicy(e).builtins, o = t.makeMergeOptions(r, n, {});
        return o.initter(), o.target;
    }, t.simpleGingerBlock = function(e, n) {
        return {
            target: e,
            simple: !0,
            strategy: t.concreteTrundler,
            initter: t.identity,
            recordType: n,
            priority: t.mergeRecordTypes[n]
        };
    }, t.makeMergeOptions = function(n, r, o) {
        var a = {
            mergePolicy: n,
            sources: r
        };
        return a = e.extend(a, o), a.target = a.target || t.freshContainer(a.sources[0]), 
        a.sourceStrategies = a.sourceStrategies || t.generate(a.sources.length, t.concreteTrundler), 
        a.initter = function() {
            a.evaluateFully = !0, t.fetchMergeChildren(a.target, 0, [], a.sources, a.mergePolicy, a);
        }, t.makeMergeStrategy(a), a;
    }, t.transformOptions = function(e, n) {
        return t.expect("Options transformation record", n, [ "transformer", "config" ]), 
        t.getGlobalValue(n.transformer).call(null, e, n.config);
    }, t.findMergeBlocks = function(e, n) {
        return t.remove_if(t.makeArray(e), function(e) {
            return e.recordType !== n;
        });
    }, t.transformOptionsBlocks = function(e, n, r) {
        t.each(r, function(r) {
            var o = t.findMergeBlocks(e, r);
            t.each(o, function(e) {
                var r = e.source ? "source" : "target";
                e[e.simple || "target" === r ? "target" : "source"] = t.transformOptions(e[r], n);
            });
        });
    }, t.dedupeDistributionNamespaces = function(e) {
        var n = {};
        t.remove_if(e, function(e) {
            var t = e.namespace;
            if (t) {
                if (n[t] && n[t] !== e.contextThat.id) return !0;
                n[t] = e.contextThat.id;
            }
        });
    }, t.deliverOptionsStrategy = t.identity, t.computeComponentAccessor = t.identity, 
    t.computeDynamicComponents = t.identity, t.mergeRecordTypes = {
        defaults: 1e3,
        defaultValueMerge: 900,
        subcomponentRecord: 800,
        user: 700,
        distribution: 100
    }, t.model.applyChangeRequest = function(n, r) {
        var o = r.segs;
        if (0 === o.length) "ADD" === r.type ? e.extend(!0, n, r.value) : t.clear(n); else if ("ADD" === r.type) t.model.setSimple(n, r.segs, r.value); else {
            for (var a = 0; a < o.length - 1; ++a) if (!(n = n[o[a]])) return;
            delete n[o[o.length - 1]];
        }
    }, t.destroyValue = function(e, n) {
        e && t.model.applyChangeRequest(e, {
            type: "DELETE",
            segs: n
        });
    }, t.mergeComponentOptions = function(n, r, o, a) {
        function i() {
            y = t.driveStrategy(f, "mergePolicy", h.strategy), y = e.extend({}, t.rootMergePolicy, y), 
            v = t.compileMergePolicy(y), e.extend(!0, l, v.builtins);
        }
        var u = t.rawDefaults(r), s = t.getMergedDefaults(r, u && u.gradeNames ? null : a.gradeNames), l = {}, c = [];
        c = t.expandComponentOptions ? c.concat(t.expandComponentOptions(l, s, o, n)) : c.concat([ t.simpleGingerBlock(s, "defaults"), t.simpleGingerBlock(o, "user") ]);
        var f = {}, d = [], p = [], m = {
            target: f,
            sourceStrategies: d
        }, g = function() {
            t.each(c, function(e) {
                t.isPrimitive(e.priority) && (e.priority = t.parsePriority(e.priority, 0, !1, "options distribution"));
            }), t.sortByPriority(c), t.dedupeDistributionNamespaces(c), d.length = 0, p.length = 0, 
            t.each(c, function(e) {
                d.push(e.strategy), p.push(e.target);
            });
        };
        g();
        var h = t.makeMergeOptions(l, p, m);
        h.mergeBlocks = c, h.updateBlocks = g, h.destroyValue = function(e) {
            for (var n = 0; n < c.length; ++n) c[n].immutableTarget || t.destroyValue(c[n].target, e);
            t.destroyValue(m.target, e);
        };
        var v, y;
        i(), h.computeMergePolicy = i, v.hasDefaults && (t.generateExpandBlock ? (c.push(t.generateExpandBlock({
            options: v.defaultValues,
            recordType: "defaultValueMerge",
            priority: t.mergeRecordTypes.defaultValueMerge
        }, n, {})), g()) : t.fail("Cannot operate mergePolicy ", y, " for component ", n, " without including FluidIoC.js")), 
        n.options = f, t.driveStrategy(f, "gradeNames", h.strategy), t.deliverOptionsStrategy(n, f, h), 
        t.computeComponentAccessor(n, o && o.localRecord);
        var k = t.driveStrategy(f, "transformOptions", h.strategy);
        return k && (t.transformOptionsBlocks(c, k, [ "user", "subcomponentRecord" ]), g()), 
        m.target.mergePolicy || i(), h;
    }, t.defaults("fluid.function", {}), t.invokeGradedFunction = function(e, n) {
        var r = t.defaults(e);
        r && r.argumentMap && t.hasGrade(r, "fluid.function") || t.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", r);
        var o = [];
        return t.each(r.argumentMap, function(e, t) {
            o[e] = n[t];
        }), t.invokeGlobalFunction(e, o);
    }, t.noNamespaceDistributionPrefix = "no-namespace-distribution-", t.mergeOneDistribution = function(n, r, o) {
        var a = r.namespace || o || t.noNamespaceDistributionPrefix + t.allocateGuid();
        r.namespace = a, n[a] = e.extend(!0, {}, n[a], r);
    }, t.distributeOptionsPolicy = function(e, n) {
        if (e = e || {}, t.isArrayable(n)) for (var r = 0; r < n.length; ++r) t.mergeOneDistribution(e, n[r]); else "string" == typeof n.target ? t.mergeOneDistribution(e, n) : t.each(n, function(n, r) {
            t.mergeOneDistribution(e, n, r);
        });
        return e;
    }, t.mergingArray = function() {}, t.mergingArray.prototype = [], t.membersMergePolicy = function(e, n) {
        return e = e || {}, t.each(n, function(n, r) {
            e[r] || (e[r] = new t.mergingArray()), n instanceof t.mergingArray ? e[r].push.apply(e[r], n) : void 0 !== n && e[r].push(n);
        }), e;
    }, t.invokerStrategies = t.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
    t.invokersMergePolicy = function(n, r) {
        return n = n || {}, t.each(r, function(r, o) {
            if (r) {
                r = t.upgradePrimitiveFunc(r);
                var a = n[o];
                a || (a = n[o] = {});
                for (var i in t.invokerStrategies) if (i in r) for (var u in t.invokerStrategies) a[u] = void 0;
                e.extend(a, r);
            } else n[o] = r;
        }), n;
    }, t.rootMergePolicy = {
        gradeNames: t.arrayConcatPolicy,
        distributeOptions: t.distributeOptionsPolicy,
        members: {
            noexpand: !0,
            func: t.membersMergePolicy
        },
        invokers: {
            noexpand: !0,
            func: t.invokersMergePolicy
        },
        transformOptions: "replace",
        listeners: t.makeMergeListenersPolicy(t.mergeListenerPolicy)
    }, t.defaults("fluid.component", {
        initFunction: "fluid.initLittleComponent",
        mergePolicy: t.rootMergePolicy,
        argumentMap: {
            options: 0
        },
        events: {
            onCreate: null,
            onDestroy: null,
            afterDestroy: null
        }
    }), t.defaults("fluid.emptySubcomponent", {
        gradeNames: [ "fluid.component" ]
    }), t.computeNickName = function(e) {
        var n = t.model.parseEL(e);
        return n[n.length - 1];
    }, t.defaults("fluid.typeFount", {
        gradeNames: [ "fluid.component" ]
    }), t.initLittleComponent = function(e, n, r, o) {
        var a = t.typeTag(e);
        a.lifecycleStatus = "constructing", r = r || {
            gradeNames: "fluid.component"
        }, a.destroy = t.makeRootDestroy(a);
        var i = t.mergeComponentOptions(a, e, n, r);
        i.exceptions = {
            members: {
                model: !0,
                modelRelay: !0
            }
        };
        var u = a.options;
        a.events = {}, (o || t.identity)(a, u, i.strategy), t.computeDynamicComponents(a, i);
        for (var s = 0; s < i.mergeBlocks.length; ++s) i.mergeBlocks[s].initter();
        return i.initter(), delete u.mergePolicy, t.instantiateFirers(a, u), t.mergeListeners(a, a.events, u.listeners), 
        a;
    }, t.diagnoseFailedView = t.identity, t.makeRootDestroy = function(e) {
        return function() {
            t.doDestroy(e), t.fireEvent(e, "afterDestroy", [ e, "", null ]);
        };
    }, t.isDestroyed = function(e) {
        return "destroyed" === e.lifecycleStatus;
    }, t.doDestroy = function(e, n, r) {
        t.fireEvent(e, "onDestroy", [ e, n || "", r ]), e.lifecycleStatus = "destroyed";
        for (var o in e.events) "afterDestroy" !== o && "function" == typeof e.events[o].destroy && e.events[o].destroy();
        e.applier && e.applier.destroy();
    }, t.initComponent = function(e, n) {
        var r = t.defaults(e);
        r.gradeNames || t.fail("Cannot initialise component " + e + " which has no gradeName registered");
        var o, a = [ e ].concat(t.makeArray(n));
        t.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs", {
            componentName: e,
            initArgs: n
        }), o = t.invokeGlobalFunction(r.initFunction, a), t.diagnoseFailedView(e, o, r, a), 
        t.initDependents && t.initDependents(o);
        var i = t.validateListenersImplemented(o);
        return i.length > 0 && t.fail(t.transform(i, function(e) {
            return [ "Error constructing component ", o, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
        })).join("\n"), "constructing" === o.lifecycleStatus && (o.lifecycleStatus = "constructed"), 
        o.events.onCreate.fire(o), t.popActivity(), o;
    }, t.initSubcomponentImpl = function(e, n, r) {
        var o;
        if ("function" != typeof n) {
            var a = "string" == typeof n ? n : n.type;
            o = "fluid.emptySubcomponent" === a ? null : t.invokeGlobalFunction(a, r);
        } else o = n.apply(null, r);
        return o;
    };
    t.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)((?:[\\w\\u00c0-\\uFFFF*_-]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    }, t.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)((?:[\\w\\u00c0-\\uFFFF*_-]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };
    var f = new RegExp("\\s*(>)?\\s*", "g");
    t.parseSelector = function(e, n) {
        var r = [];
        e = e.trim();
        var o = n.regexp;
        o.lastIndex = 0;
        for (var a = 0; ;) {
            for (var i = [], u = !0; ;) {
                var s = o.exec(e);
                if (!s) break;
                if (s.index !== a) {
                    if (!u) break;
                    t.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(a));
                }
                var l = {}, c = s[2], d = n.charToTag[s[1]];
                d && (l[d] = c), i[i.length] = l, a = o.lastIndex, u = !1;
            }
            f.lastIndex = a;
            var p = {
                predList: i
            }, m = f.exec(e);
            if (m && m.index === a || t.fail("Error in selector string - can not match child selector expression at " + e.substring(a)), 
            ">" === m[1] && (p.child = !0), r[r.length] = p, f.lastIndex >= e.length) break;
            a = f.lastIndex, o.lastIndex = f.lastIndex;
        }
        return r;
    }, t.stringToRegExp = function(e, t) {
        return new RegExp(e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), t);
    }, t.stringTemplate = function(e, n) {
        var r = t.keys(n);
        r = r.sort(t.compareStringLength());
        for (var o = 0; o < r.length; ++o) {
            var a = r[o], i = t.stringToRegExp("%" + a, "g");
            e = e.replace(i, n[a]);
        }
        return e;
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(e, t) {
    "use strict";
    function n(e, r, o) {
        function a(e) {
            o.output += e;
        }
        var i = r + o.indentChars, u = "function" == typeof e;
        if (void 0 !== o.maxRenderChars && o.output.length > o.maxRenderChars) return !0;
        if (null === e) a("null"); else if (void 0 === e) a("undefined"); else if (e === t.SYNTHETIC_PROPERTY) a("[Synthetic property]"); else if (t.isPrimitive(e) && !u) a(JSON.stringify(e)); else {
            if (-1 !== o.stack.indexOf(e)) return void a("(CIRCULAR)");
            o.stack.push(e);
            var s;
            if (t.isArrayable(e)) if (0 === e.length) a("[]"); else {
                for (a("[\n" + i), s = 0; s < e.length; ++s) {
                    if (n(e[s], i, o)) return !0;
                    s !== e.length - 1 && a(",\n" + i);
                }
                a("\n" + r + "]");
            } else {
                a("{" + (u ? " Function" : "") + "\n" + i);
                var l = t.keys(e);
                for (s = 0; s < l.length; ++s) {
                    var c = l[s], f = t.getSafeProperty(e, c);
                    if (a(JSON.stringify(c) + ": "), n(f, i, o)) return !0;
                    s !== l.length - 1 && a(",\n" + i);
                }
                a("\n" + r + "}");
            }
            o.stack.pop();
        }
    }
    t.renderTimestamp = function(e) {
        var t = function(e, t) {
            t || (t = 2);
            var n = void 0 === e ? "" : e.toString();
            return "00000".substring(5 - t + n.length) + n;
        };
        return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
    }, t.isTracing = !1, t.registerNamespace("fluid.tracing"), t.tracing.pathCount = [], 
    t.tracing.summarisePathCount = function(e) {
        e = e || t.tracing.pathCount;
        for (var n = {}, r = 0; r < e.length; ++r) {
            var o = e[r];
            n[o] ? ++n[o] : n[o] = 1;
        }
        var a = [];
        return t.each(n, function(e, t) {
            a.push({
                path: t,
                count: e
            });
        }), a.sort(function(e, t) {
            return t.count - e.count;
        }), a;
    }, t.tracing.condensePathCount = function(e, n) {
        e = t.makeArray(e);
        var r = {};
        t.each(e, function(e) {
            r[e] = 0;
        });
        var o = [];
        return t.each(n, function(n) {
            var a = n.path;
            t.find(e, function(e) {
                if (0 === a.indexOf(e)) return r[e] += n.count, !0;
            }) || o.push(n);
        }), t.each(r, function(e, t) {
            o.unshift({
                path: t,
                count: e
            });
        }), o;
    }, t.detectStackStyle = function(e) {
        var t = "other", n = {
            offset: 0
        };
        return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
        n.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
        n.style = t, n;
    }, t.obtainException = function() {
        try {
            throw new Error("Trace exception");
        } catch (e) {
            return e;
        }
    };
    var r = t.detectStackStyle(t.obtainException());
    t.registerNamespace("fluid.exceptionDecoders"), t.decodeStack = function() {
        if ("firefox" !== r.style) return null;
        var e = t.obtainException();
        return t.exceptionDecoders[r.style](e);
    }, t.exceptionDecoders.firefox = function(e) {
        var n = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return t.transform(n, function(e) {
            var t = (e = e.replace(/\)/g, "")).indexOf("at ");
            return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
        });
    }, t.getCallerInfo = function(e) {
        e = (e || 3) - r.offset;
        var n = t.decodeStack(), o = n && n[e][0];
        if (o) {
            var a = o.lastIndexOf("/");
            -1 === a && (a = 0);
            var i = o.indexOf(":", a);
            return {
                path: o.substring(0, a),
                filename: o.substring(a + 1, i),
                index: o.substring(i + 1)
            };
        }
        return null;
    }, t.generatePadding = function(e, t) {
        for (var n = "", r = 0; r < t; ++r) n += e;
        return n;
    }, t.SYNTHETIC_PROPERTY = Object.freeze({}), t.getSafeProperty = function(e, n) {
        var r = Object.getOwnPropertyDescriptor(e, n);
        return r && !r.get ? e[n] : t.SYNTHETIC_PROPERTY;
    }, t.prettyPrintJSON = function(r, o) {
        return o = e.extend({
            indent: 4,
            stack: [],
            output: ""
        }, o), o.indentChars = t.generatePadding(" ", o.indent), n(r, "", o), o.output;
    }, t.dumpEl = function(n) {
        var r;
        if (!n) return "null";
        if (3 === n.nodeType || 8 === n.nodeType) return "[data: " + n.data + "]";
        if (9 === n.nodeType) return "[document: location " + n.location + "]";
        if (!n.nodeType && t.isArrayable(n)) {
            r = "[";
            for (var o = 0; o < n.length; ++o) r += t.dumpEl(n[o]), o < n.length - 1 && (r += ", ");
            return r + "]";
        }
        return n = e(n), r = n.get(0).tagName, n.id && (r += "#" + n.id), n.attr("class") && (r += "." + n.attr("class")), 
        r;
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    function n(e, n, r, o) {
        for (var a = 0; a < r; ++a) e = o(e, n[a], a, t.makeArray(n));
        return e;
    }
    t.visitComponentChildren = function(e, n, r, o) {
        o = o || [];
        for (var a in e) {
            var i = e[a];
            if (!(!t.isComponent(i) || r.visited && r.visited[i.id])) {
                if (o.push(a), r.visited && (r.visited[i.id] = !0), n(i, a, o, o.length - 1)) return !0;
                r.flat || t.visitComponentChildren(i, n, r, o), o.pop();
            }
        }
    }, t.getContextHash = function(e, t) {
        var n = e.idToShadow[t.id];
        return n && n.contextHash;
    }, t.componentHasGrade = function(e, n) {
        var r = t.getContextHash(t.globalInstantiator, e);
        return !(!r || !r[n]);
    }, t.visitComponentsForMatching = function(n, r, o) {
        var a = t.getInstantiator(n);
        r = e.extend({
            visited: {},
            instantiator: a
        }, r);
        var i = [ n ], u = [ t.getContextHash(a, n) ];
        t.visitComponentChildren(n, function(e, n, r) {
            i.length = 1, u.length = 1;
            for (var s = 0; s < r.length; ++s) {
                var l = i[s][r[s]];
                i[s + 1] = l, u[s + 1] = t.getContextHash(a, l) || {};
            }
            return o(e, i, u, r, r.length);
        }, r, []);
    }, t.getMemberNames = function(e, n) {
        if (0 === n.length) return [];
        var r = e.idToPath(n[n.length - 1].id), o = e.parseEL(r);
        return o.unshift.apply(o, t.generate(n.length - o.length, "")), o;
    }, t.visitComponentsForVisibility = function(e, n, r, o) {
        o = o || {
            visited: {},
            flat: !0,
            instantiator: e
        };
        for (var a = t.getMemberNames(e, n), i = n.length - 1; i >= 0; --i) {
            var u = n[i];
            if (o.visited[u.id] = !0, r(u, a[i], a, i)) return;
            if (t.visitComponentChildren(u, r, o, a)) return;
            a.pop();
        }
    }, t.mountStrategy = function(e, t, n) {
        var r = e.length;
        return function(t, o, a, i) {
            if (!(a <= e.length)) {
                for (var u = 0; u < e.length; ++u) if (i[u] !== e[u]) return;
                return n(t, o, a - e.length, i.slice(r));
            }
        };
    }, t.invokerFromRecord = function(e, n, r) {
        t.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
            name: n,
            record: e,
            that: r
        });
        var o = e ? t.makeInvoker(r, e, n) : void 0;
        return t.popActivity(), o;
    }, t.memberFromRecord = function(n, r, o) {
        for (var a, i = 0; i < n.length; ++i) {
            var u = t.expandImmediate(n[i], o);
            a = t.isPlainObject(a) ? e.extend(!0, a, u) : u;
        }
        return a;
    }, t.recordStrategy = function(e, n, r, o, a, i, u) {
        return i = i || [], {
            strategy: function(i, u, s) {
                if (1 === s) {
                    var l = t.driveStrategy(n, [ o, u ], r);
                    if (void 0 !== l) {
                        t.set(i, [ u ], t.inEvaluationMarker);
                        var c = a(l, u, e);
                        return t.set(i, [ u ], c), c;
                    }
                }
            },
            initter: function() {
                var a = t.driveStrategy(n, o, r) || {};
                for (var s in a) u && u[s] || t.getForComponent(e, i.concat([ s ]));
            }
        };
    }, t.instantiateFirers = function(e) {
        var n = t.shadowForComponent(e);
        (t.get(n, [ "eventStrategyBlock", "initter" ]) || t.identity)();
    }, t.makeDistributionRecord = function(n, r, o, a, i, u) {
        u = u || "distribution", t.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
            sourceRecord: r,
            sourcePath: o,
            targetSegs: a
        });
        var s = t.copy(t.get(r, o));
        t.each(i, function(e) {
            t.model.applyChangeRequest(s, {
                segs: e,
                type: "DELETE"
            });
        });
        var l = {
            options: {}
        };
        return t.model.applyChangeRequest(l, {
            segs: a,
            type: "ADD",
            value: s
        }), t.checkComponentRecord(l), t.popActivity(), e.extend(l, {
            contextThat: n,
            recordType: u
        });
    }, t.filterBlocks = function(n, r, o, a, i, u) {
        var s = [];
        return t.each(r, function(r) {
            var l = t.get(r.source, o);
            if (void 0 !== l) {
                s.push(t.makeDistributionRecord(n, r.source, o, a, i, r.recordType));
                var c = e.extend({}, l);
                u && t.model.applyChangeRequest(r.source, {
                    segs: o,
                    type: "DELETE"
                }), t.each(i, function(e) {
                    var n = t.get(c, e);
                    t.set(r.source, o.concat(e), n);
                });
            }
        }), s;
    }, t.noteCollectedDistribution = function(e, n, r) {
        t.model.setSimple(e, [ "collectedDistributions", n, r.id ], !0);
    }, t.isCollectedDistribution = function(e, n, r) {
        return t.model.getSimple(e, [ "collectedDistributions", n, r.id ]);
    }, t.clearCollectedDistributions = function(e, n) {
        t.model.applyChangeRequest(e, {
            segs: [ "collectedDistributions", n ],
            type: "DELETE"
        });
    }, t.collectDistributions = function(e, n, r, o, a, i, u) {
        var s = i[i.length - 1];
        !t.isCollectedDistribution(n, s, r) && t.matchIoCSelector(r.selector, o, a, i, u) && (e.push.apply(e, r.blocks), 
        t.noteCollectedDistribution(n, s, r));
    }, t.registerCollectedClearer = function(e, n, r) {
        !e.collectedClearer && n && (e.collectedClearer = function() {
            t.clearCollectedDistributions(n, r);
        });
    }, t.receiveDistributions = function(e, n, r, o) {
        var a = t.getInstantiator(e || o), i = a.getThatStack(e || o);
        i.unshift(t.rootComponent);
        var u = t.getMemberNames(a, i), s = t.transform(i, function(e) {
            return a.idToShadow[e.id];
        }), l = s[s.length - (e ? 1 : 2)], c = t.getMembers(s, "contextHash");
        e ? (u.push(r), c.push(t.gradeNamesToHash(n)), i.push(o)) : t.registerCollectedClearer(s[s.length - 1], l, u[u.length - 1]);
        for (var f = [], d = 0; d < i.length - 1; ++d) t.each(s[d].distributions, function(e) {
            t.collectDistributions(f, l, e, i, c, u, d);
        });
        return f;
    }, t.computeTreeDistance = function(e, t) {
        for (var n = 0; n < e.length && n < t.length && e[n] === t[n]; ) ++n;
        return e.length + t.length - 2 * n;
    }, t.computeDistributionPriority = function(e, n) {
        if (!n.priority) {
            var r = t.getInstantiator(e), o = r.getThatStack(e), a = t.getMemberNames(r, o), i = r.getThatStack(n.contextThat), u = t.getMemberNames(r, i), s = t.computeTreeDistance(a, u);
            n.priority = t.mergeRecordTypes.distribution - s;
        }
        return n;
    }, t.applyDistributions = function(e, n, r) {
        var o = t.transform(n, function(n) {
            return t.generateExpandBlock(n, e, r.mergePolicy);
        }, function(n) {
            return t.computeDistributionPriority(e, n);
        }), a = r.mergeOptions;
        return a.mergeBlocks.push.apply(a.mergeBlocks, o), a.updateBlocks(), o;
    }, t.matchIoCSelector = function(e, t, n, r, o) {
        for (var a = t.length - 1, i = e.length - 1; ;) {
            for (var u = a === t.length - 1 || e[i].child, s = t[a], l = e[i], c = !0, f = 0; f < l.predList.length; ++f) {
                var d = l.predList[f];
                if (d.context && !n[a][d.context] && r[a] !== d.context) {
                    c = !1;
                    break;
                }
                if (d.id && s.id !== d.id) {
                    c = !1;
                    break;
                }
            }
            if (0 === i && a > o && u && (c = !1), c) {
                if (0 === i) return !0;
                --a, --i;
            } else {
                if (u) return !1;
                --a;
            }
            if (a < o) return !1;
        }
    }, t.queryIoCSelector = function(e, n, r) {
        var o = t.parseSelector(n, t.IoCSSMatcher), a = [];
        return t.visitComponentsForMatching(e, {
            flat: r
        }, function(e, n, r, i, u) {
            t.matchIoCSelector(o, n, r, i, u) && a.push(e);
        }), a;
    }, t.isIoCSSSelector = function(e) {
        return -1 !== e.indexOf(" ");
    }, t.pushDistributions = function(e, n, r, o) {
        var a = t.shadowForComponent(e), i = t.allocateGuid(), u = {
            id: i,
            target: r,
            selector: n,
            blocks: o
        };
        return Object.freeze(u), Object.freeze(u.blocks), t.pushArray(a, "distributions", u), 
        i;
    }, t.clearDistribution = function(e, n) {
        var r = t.globalInstantiator.idToShadow[e];
        r && t.remove_if(r.distributions, function(e) {
            return e.id === n;
        });
    }, t.clearDistributions = function(e) {
        t.each(e.outDistributions, function(e) {
            t.clearDistribution(e.targetHeadId, e.distributionId);
        });
    }, t.extractSelectorHead = function(e) {
        var t = e[0].predList, n = t[0].context;
        return t.length = 0, n;
    }, t.parseExpectedOptionsPath = function(e, n) {
        var r = t.model.parseEL(e);
        return "options" !== r[0] && t.fail("Error in options distribution path ", e, " - only " + n + ' paths beginning with "options" are supported'), 
        r.slice(1);
    }, t.replicateProperty = function(e, n, r) {
        void 0 !== e[n] && t.each(r, function(t) {
            t[n] = e[n];
        });
    }, t.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions" ], 
    t.distributeOptions = function(e, n) {
        var r = t.shadowForComponent(e), o = t.driveStrategy(e.options, "distributeOptions", n);
        t.each(o, function(n) {
            t.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
                that: e,
                record: n
            }), "string" != typeof n.target && t.fail("Error in options distribution record ", n, ' a member named "target" must be supplied holding an IoC reference'), 
            "string" == typeof n.source ^ void 0 === n.record && t.fail("Error in options distribution record ", n, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
            var o, a, i, u = t.parseContextReference(n.target);
            if (t.isIoCSSSelector(u.context)) {
                a = t.parseSelector(u.context, t.IoCSSMatcher);
                var s = t.extractSelectorHead(a);
                "/" === s ? o = t.rootComponent : i = s;
            } else i = u.context;
            (o = o || t.resolveContext(i, e)) || t.fail("Error in options distribution record ", n, " - could not resolve context {" + i + "} to a head component");
            var l, c = t.model.parseEL(u.path);
            if (void 0 !== n.record) l = [ t.makeDistributionRecord(e, n.record, [], c, []) ]; else {
                var f = t.parseContextReference(n.source);
                "that" !== f.context && t.fail("Error in options distribution record ", n, " only a context of {that} is supported");
                var d = t.parseExpectedOptionsPath(f.path, "source"), p = t.makeArray(n.exclusions).concat(0 === d.length ? t.undistributableOptions : []), m = t.transform(p, function(e) {
                    return t.model.parseEL(e);
                });
                l = t.filterBlocks(e, r.mergeOptions.mergeBlocks, d, c, m, n.removeSource), r.mergeOptions.updateBlocks();
            }
            if (t.replicateProperty(n, "priority", l), t.replicateProperty(n, "namespace", l), 
            a) {
                var g = t.pushDistributions(o, a, n.target, l);
                r.outDistributions = r.outDistributions || [], r.outDistributions.push({
                    targetHeadId: o.id,
                    distributionId: g
                });
            } else {
                var h = t.shadowForComponent(o);
                t.applyDistributions(e, l, h);
            }
            t.popActivity();
        });
    }, t.gradeNamesToHash = function(e) {
        var n = {};
        return t.each(e, function(e) {
            n[e] = !0, n[t.computeNickName(e)] = !0;
        }), n;
    }, t.cacheShadowGrades = function(e, n) {
        var r = t.gradeNamesToHash(e.options.gradeNames);
        r[n.memberName] || (r[n.memberName] = "memberName"), n.contextHash = r, t.each(r, function(t, r) {
            n.ownScope[r] = e, n.parentShadow && "fluid.rootComponent" !== n.parentShadow.that.type && (n.parentShadow.childrenScope[r] = e);
        });
    }, t.deliverOptionsStrategy = function(e, n, r) {
        var o = t.shadowForComponent(e, o);
        t.cacheShadowGrades(e, o), o.mergeOptions = r;
    }, t.collectDistributedGrades = function(e) {
        var n = t.receiveDistributions(null, null, null, e.that);
        if (n.length > 0) {
            var r = t.applyDistributions(e.that, n, e.shadow), o = t.transform(t.getMembers(r, [ "source", "gradeNames" ]), t.makeArray);
            t.accumulateDynamicGrades(e, t.flatten(o));
        }
    }, t.applyDynamicGrades = function(e) {
        e.oldGradeNames = t.makeArray(e.gradeNames);
        var n = t.copy(t.getMergedDefaults(e.that.typeName, e.gradeNames));
        e.gradeNames.length = 0, e.gradeNames.push.apply(e.gradeNames, n.gradeNames), t.each(e.gradeNames, function(n) {
            t.isIoCReference(n) || (e.seenGrades[n] = !0);
        });
        var r = e.shadow;
        t.cacheShadowGrades(e.that, r), r.mergeOptions.destroyValue([ "mergePolicy" ]), 
        r.mergeOptions.destroyValue([ "components" ]), r.mergeOptions.destroyValue([ "invokers" ]), 
        e.defaultsBlock.source = n, r.mergeOptions.updateBlocks(), r.mergeOptions.computeMergePolicy(), 
        t.accumulateDynamicGrades(e, n.gradeNames);
    }, t.accumulateDynamicGrades = function(e, n) {
        t.each(n, function(n) {
            e.seenGrades[n] || (t.isIoCReference(n) ? (e.rawDynamic.push(n), e.seenGrades[n] = !0) : t.contains(e.oldGradeNames, n) || e.plainDynamic.push(n));
        });
    }, t.computeDynamicGrades = function(e, n, r) {
        delete e.options.gradeNames;
        var o = t.driveStrategy(e.options, "gradeNames", r);
        o.length = 0;
        var a = {
            that: e,
            shadow: n,
            defaultsBlock: t.findMergeBlocks(n.mergeOptions.mergeBlocks, "defaults")[0],
            gradeNames: o,
            seenGrades: {},
            plainDynamic: [],
            rawDynamic: []
        };
        for (t.each(n.mergeOptions.mergeBlocks, function(e) {
            o.push.apply(o, t.makeArray(e.target && e.target.gradeNames)), t.applyDynamicGrades(a);
        }), t.collectDistributedGrades(a); ;) {
            for (;a.plainDynamic.length > 0; ) o.push.apply(o, a.plainDynamic), a.plainDynamic.length = 0, 
            t.applyDynamicGrades(a), t.collectDistributedGrades(a);
            if (!(a.rawDynamic.length > 0)) break;
            var i = t.expandImmediate(a.rawDynamic.shift(), e, n.localDynamic);
            "function" == typeof i && (i = i()), i && (a.plainDynamic = a.plainDynamic.concat(i));
        }
        n.collectedClearer && (n.collectedClearer(), delete n.collectedClearer);
    }, t.computeDynamicComponentKey = function(e, t) {
        return e + (0 === t ? "" : "-" + t);
    }, t.registerDynamicRecord = function(e, n, r, o, a) {
        var i = t.computeDynamicComponentKey(n, r), u = t.copy(o);
        return delete u[a], t.set(e.options, [ "components", i ], u), i;
    }, t.computeDynamicComponents = function(e, n) {
        var r = t.shadowForComponent(e), o = r.subcomponentLocal = {}, a = t.driveStrategy(e.options, "dynamicComponents", n.strategy);
        t.each(a, function(n, a) {
            if (n.sources || n.createOnEvent || t.fail("Cannot process dynamicComponents record ", n, ' without a "sources" or "createOnEvent" entry'), 
            n.sources) {
                var i = t.expandOptions(n.sources, e);
                t.each(i, function(r, i) {
                    var u = t.registerDynamicRecord(e, a, i, n, "sources");
                    o[u] = {
                        source: r,
                        sourcePath: i
                    };
                });
            } else if (n.createOnEvent) {
                var u = t.event.expandOneEvent(e, n.createOnEvent);
                t.set(r, [ "dynamicComponentCount", a ], 0);
                var s = function() {
                    var o = t.registerDynamicRecord(e, a, r.dynamicComponentCount[a]++, n, "createOnEvent"), i = {
                        arguments: t.makeArray(arguments)
                    };
                    t.initDependent(e, o, i);
                };
                u.addListener(s), t.recordListener(u, s, r);
            }
        });
    }, t.computeComponentAccessor = function(e, n) {
        var r = t.globalInstantiator, o = t.shadowForComponent(e);
        o.localDynamic = n;
        var a = e.options, i = o.mergeOptions.strategy, u = t.mountStrategy([ "options" ], a, i);
        o.invokerStrategy = t.recordStrategy(e, a, i, "invokers", t.invokerFromRecord), 
        o.eventStrategyBlock = t.recordStrategy(e, a, i, "events", t.eventFromRecord, [ "events" ]);
        var s = t.mountStrategy([ "events" ], e, o.eventStrategyBlock.strategy, [ "events" ]);
        if (o.memberStrategy = t.recordStrategy(e, a, i, "members", t.memberFromRecord, null, {
            model: !0,
            modelRelay: !0
        }), o.getConfig = {
            strategies: [ t.model.funcResolverStrategy, t.makeGingerStrategy(e), u, o.invokerStrategy.strategy, o.memberStrategy.strategy, s ]
        }, t.computeDynamicGrades(e, o, i, o.mergeOptions.mergeBlocks), t.distributeOptions(e, i), 
        o.contextHash["fluid.resolveRoot"]) {
            var l;
            if (o.contextHash["fluid.resolveRootSingle"]) {
                var c = t.getForComponent(e, [ "options", "singleRootType" ]);
                c || t.fail("Cannot register object with grades " + Object.keys(o.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                l = t.typeNameToMemberName(c);
            } else l = t.computeGlobalMemberName(e);
            var f = t.resolveRootComponent;
            f[l] && r.clearComponent(f, l), r.recordKnownComponent(f, e, l, !1);
        }
        return o.getConfig;
    }, t.shadowForComponent = function(e) {
        var n = t.getInstantiator(e);
        return n && e ? n.idToShadow[e.id] : null;
    }, t.getForComponent = function(e, n) {
        var r = t.shadowForComponent(e), o = r ? r.getConfig : void 0;
        return t.get(e, n, o);
    }, t.makeGingerStrategy = function(e) {
        var n = t.getInstantiator(e);
        return function(e, r, o, a) {
            var i = e[r];
            if (i === t.inEvaluationMarker && o === a.length && t.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + r + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
            o > 1) return i;
            if (void 0 === i && e.hasOwnProperty(r)) return t.NO_VALUE;
            if (void 0 === i) {
                var u = n.idToShadow[e.id].path, s = n.composePath(u, r);
                i = n.pathToComponent[s];
            }
            if (void 0 === i) {
                var l = t.getForComponent(e, [ "options", "components", r ]);
                l && (l.createOnEvent && t.fail('Error resolving path segment "' + r + '" of path ' + a.join(".") + " since component with record ", l, ' has annotation "createOnEvent" - this very likely represents an implementation error. Either alter the reference so it does not  match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves'), 
                t.initDependent(e, r), i = e[r]);
            }
            return i;
        };
    }, t.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
    t.filterBuiltinGrades = function(e) {
        return t.remove_if(t.makeArray(e), function(e) {
            return -1 !== t.frameworkGrades.indexOf(e);
        });
    }, t.dumpGradeNames = function(e) {
        return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(t.filterBuiltinGrades(e.options.gradeNames)) : "";
    }, t.dumpThat = function(e) {
        return '{ typeName: "' + e.typeName + '"' + t.dumpGradeNames(e) + " id: " + e.id + "}";
    }, t.dumpThatStack = function(e, n) {
        return t.transform(e, function(e) {
            var r = n.idToPath(e.id);
            return t.dumpThat(e) + (r ? " - path: " + r : "");
        }).join("\n");
    }, t.dumpComponentPath = function(e) {
        var n = t.pathForComponent(e);
        return n ? t.pathUtil.composeSegments(n) : "** no path registered for component **";
    }, t.resolveContext = function(e, n, r) {
        if ("that" === e) return n;
        if ("object" == typeof e) {
            var o = t.resolveContext(e.context, n, r);
            t.isComponent(o) || t.triggerMismatchedPathError(e.context, n);
            var a = t.getForComponent(o, e.path), i = t.expandOptions(a, n);
            return t.isComponent(i) || t.fail("Unable to resolve recursive context expression " + t.renderContextReference(e) + ": the directly resolved value of " + a + " did not resolve to a component in the scope of component ", n, ": got ", i), 
            i;
        }
        var u, s = t.globalInstantiator;
        if (r) return s.idToShadow[n.id].ownScope[e];
        var l = s.getFullStack(n);
        return t.visitComponentsForVisibility(s, l, function(n, r) {
            var o = t.shadowForComponent(n);
            return e === r || o && o.contextHash && o.contextHash[e] || e === n.typeName ? (u = n, 
            !0) : t.getForComponent(n, [ "options", "components", e ]) && !n[e] ? (u = t.getForComponent(n, e), 
            !0) : void 0;
        }), u;
    }, t.triggerMismatchedPathError = function(e, n) {
        var r = t.renderContextReference(e);
        t.fail("Failed to resolve reference " + r + " - could not match context with name " + e.context + " from component " + t.dumpThat(n) + " at path " + t.dumpComponentPath(n) + " component: ", n);
    }, t.makeStackFetcher = function(e, n, r) {
        return function(o) {
            e && "destroyed" === e.lifecycleStatus && t.fail("Cannot resolve reference " + t.renderContextReference(o) + " from component " + t.dumpThat(e) + " which has been destroyed");
            var a = o.context;
            if (n && a in n) return t.get(n[a], o.path);
            var i = t.resolveContext(a, e, r);
            return i || "" === o.path || t.triggerMismatchedPathError(o, e), t.getForComponent(i, o.path);
        };
    }, t.makeStackResolverOptions = function(n, r, o) {
        return e.extend(t.copy(t.rawDefaults("fluid.makeExpandOptions")), {
            localRecord: r || {},
            fetcher: t.makeStackFetcher(n, r, o),
            contextThat: n,
            exceptions: {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            }
        });
    }, t.clearListeners = function(e) {
        t.each(e.listeners, function(e) {
            e.event.removeListener(e.listenerId || e.listener);
        }), delete e.listeners;
    }, t.recordListener = function(e, n, r, o) {
        e.ownerId !== r.that.id && t.pushArray(r, "listeners", {
            event: e,
            listener: n,
            listenerId: o
        });
    }, t.constructScopeObjects = function(e, t, n, r) {
        var o = t ? e.idToShadow[t.id] : null;
        r.childrenScope = o ? Object.create(o.ownScope) : {}, r.ownScope = Object.create(r.childrenScope), 
        r.parentShadow = o;
    }, t.clearChildrenScope = function(e, n, r, o) {
        t.each(o.contextHash, function(e, t) {
            n.childrenScope[t] === r && delete n.childrenScope[t];
        });
    }, t.instantiator = function() {
        function n(e, n, o, a, i) {
            var u;
            if (i) (u = r.idToShadow[n.id] = {}).that = n, u.path = o, u.memberName = a, t.constructScopeObjects(r, e, n, u); else {
                (u = r.idToShadow[n.id]).injectedPaths = u.injectedPaths || {}, u.injectedPaths[o] = !0;
                var s = r.idToShadow[e.id], l = t.keys(u.contextHash);
                t.remove_if(l, function(e) {
                    return u.contextHash && "memberName" === u.contextHash[e];
                }), l.push(a), t.each(l, function(e) {
                    s.childrenScope[e] || (s.childrenScope[e] = n);
                });
            }
            r.pathToComponent[o] && t.fail("Error during instantiation - path " + o + " which has just created component " + t.dumpThat(n) + " has already been used for component " + t.dumpThat(r.pathToComponent[o]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
            r.pathToComponent[o] = n;
        }
        var r = t.typeTag("instantiator");
        return e.extend(r, {
            lifecycleStatus: "constructed",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {
                init: {}
            },
            composePath: t.model.composePath,
            composeSegments: t.model.composeSegments,
            parseEL: t.model.parseEL,
            events: {
                onComponentAttach: t.makeEventFirer({
                    name: "instantiator's onComponentAttach event"
                }),
                onComponentClear: t.makeEventFirer({
                    name: "instantiator's onComponentClear event"
                })
            }
        }), r.idToPath = function(e) {
            var t = r.idToShadow[e];
            return t ? t.path : "";
        }, r.getThatStack = function(e) {
            var t = r.idToShadow[e.id];
            if (t) {
                for (var n = t.path, o = r.parseEL(n), a = r.pathToComponent[""], i = [], u = 0; u < o.length; ++u) a = a[o[u]], 
                i.push(a);
                return i;
            }
            return [];
        }, r.getFullStack = function(e) {
            var n = e ? r.getThatStack(e) : [];
            return n.unshift(t.resolveRootComponent), n;
        }, r.recordRoot = function(e) {
            n(null, e, "", "", !0);
        }, r.recordKnownComponent = function(e, o, a, i) {
            if (e[a] = o, t.isComponent(o) || "instantiator" === o.type) {
                var u = r.idToShadow[e.id].path, s = r.composePath(u, a);
                n(e, o, s, a, i), r.events.onComponentAttach.fire(o, s, r, i);
            } else t.fail("Cannot record non-component with value ", o, ' at path "' + a + '" of parent ', e);
        }, r.clearConcreteComponent = function(e) {
            t.each(e.childShadow.injectedPaths, function(n, o) {
                var a = t.model.getToTailPath(o), i = r.pathToComponent[a];
                r.clearComponent(i, t.model.getTailPath(o), e.child);
            }), t.clearDistributions(e.childShadow), t.clearListeners(e.childShadow), t.fireEvent(e.child, "afterDestroy", [ e.child, e.name, e.component ]), 
            delete r.idToShadow[e.child.id];
        }, r.clearComponent = function(e, n, o, a, i, u) {
            var s = r.idToShadow[e.id];
            a = a || {
                flat: !0,
                instantiator: r,
                destroyRecs: []
            }, o = o || e[n], void 0 === (u = u || s.path) && t.fail("Cannot clear component " + n + " from component ", e, " which was not created by this instantiator");
            var l = r.composePath(u, n), c = r.idToShadow[o.id];
            if (c) {
                var f = c.path === l;
                r.events.onComponentClear.fire(o, l, e, f), f ? (t.visitComponentChildren(o, function(e, t, n, i) {
                    var u = r.composeSegments.apply(null, n.slice(0, i));
                    r.clearComponent(o, t, null, a, !0, u);
                }, a, r.parseEL(l)), t.doDestroy(o, n, e), a.destroyRecs.push({
                    child: o,
                    childShadow: c,
                    name: n,
                    component: e
                })) : t.remove_if(c.injectedPaths, function(e, t) {
                    return t === l;
                }), t.clearChildrenScope(r, s, o, c), delete r.pathToComponent[l], i || (delete e[n], 
                t.each(a.destroyRecs, r.clearConcreteComponent));
            }
        }, r;
    }, t.globalInstantiator = t.instantiator(), t.getInstantiator = function(e) {
        var n = t.globalInstantiator;
        return e && n.idToShadow[e.id] ? n : null;
    }, t.defaults("fluid.resolveRoot"), t.defaults("fluid.resolveRootSingle", {
        gradeNames: "fluid.resolveRoot"
    }), t.constructRootComponents = function(e) {
        t.rootComponent = e.rootComponent = t.typeTag("fluid.rootComponent"), e.recordRoot(t.rootComponent), 
        t.resolveRootComponent = e.resolveRootComponent = t.typeTag("fluid.resolveRootComponent"), 
        e.recordKnownComponent(t.rootComponent, t.resolveRootComponent, "resolveRootComponent", !0);
        var n = e.idToShadow[t.rootComponent.id];
        n.contextHash = {};
        var r = e.idToShadow[t.resolveRootComponent.id];
        r.ownScope = n.ownScope, r.childrenScope = n.childrenScope, e.recordKnownComponent(t.resolveRootComponent, e, "instantiator", !0), 
        r.childrenScope.instantiator = e;
    }, t.constructRootComponents(t.globalInstantiator), t.expandOptions = function(e, n, r, o, a) {
        if (!e) return e;
        t.pushActivity("expandOptions", "expanding options %args for component %that ", {
            that: n,
            args: e
        });
        var i = t.makeStackResolverOptions(n, o);
        i.mergePolicy = r, i.defer = a && a.defer;
        var u = i.defer ? t.makeExpandOptions(e, i) : t.expand(e, i);
        return t.popActivity(), u;
    }, t.localRecordExpected = t.arrayToHash([ "type", "options", "container", "createOnEvent", "priority", "recordType" ]), 
    t.checkComponentRecord = function(e) {
        t.each(e, function(n, r) {
            t.localRecordExpected[r] || t.fail("Probable error in subcomponent record ", e, ' - key "' + r + '" found, where the only legal options are ' + t.keys(t.localRecordExpected).join(", "));
        });
    }, t.mergeRecordsToList = function(e, n) {
        var r = [];
        return t.each(n, function(n, o) {
            if (n.recordType = o, "distributions" === o) r.push.apply(r, t.transform(n, function(n) {
                return t.computeDistributionPriority(e, n);
            })); else {
                if (!n.options) return;
                n.priority = t.mergeRecordTypes[o], void 0 === n.priority && t.fail("Merge record with unrecognised type " + o + ": ", n), 
                r.push(n);
            }
        }), r;
    };
    var r = function(e) {
        return t.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(n) {
            t.set(e, [ n, "*", "noexpand" ], !0);
        }), e;
    };
    t.generateExpandBlock = function(e, n, r, o) {
        var a = t.expandOptions(e.options, e.contextThat || n, r, o, {
            defer: !0
        });
        return a.priority = e.priority, a.namespace = e.namespace, a.recordType = e.recordType, 
        a;
    };
    var o = function(n, o, a, i) {
        var u = t.copy(o);
        r(n), t.shadowForComponent(i).mergePolicy = n;
        var s = {
            defaults: {
                options: u
            }
        };
        e.extend(s, a.mergeRecords), s.subcomponentRecord && t.checkComponentRecord(s.subcomponentRecord);
        var l = t.mergeRecordsToList(i, s);
        return t.transform(l, function(e) {
            return t.generateExpandBlock(e, i, n, a.localRecord);
        });
    };
    t.fabricateDestroyMethod = function(e, t, n, r) {
        return function() {
            n.clearComponent(e, t, r);
        };
    }, t.computeGlobalMemberName = function(e) {
        return t.computeNickName(e.typeName) + "-" + e.id;
    }, t.typeNameToMemberName = function(e) {
        return e.replace(/\./g, "_");
    }, t.expandComponentOptions = function(e, n, r, a) {
        var i = r, u = r && r.marker === t.EXPAND ? r.instantiator : null;
        t.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that", {
            options: u ? r.mergeRecords.user : r,
            record: i,
            that: a
        }), u || (u = t.globalInstantiator, i = {
            mergeRecords: {
                user: {
                    options: t.expandCompact(r, !0)
                }
            },
            memberName: t.computeGlobalMemberName(a),
            instantiator: u,
            parentThat: t.rootComponent
        }), a.destroy = t.fabricateDestroyMethod(i.parentThat, i.memberName, u, a), u.recordKnownComponent(i.parentThat, a, i.memberName, !0);
        var s = o(e, n, i, a);
        return t.popActivity(), s;
    }, t.assembleCreatorArguments = function(n, r, o) {
        var a = t.defaults(r);
        a && a.argumentMap || t.fail("Error in assembleCreatorArguments: cannot look up component type name " + r + " to a component creator grade with an argumentMap");
        var i = {}, u = n ? t.receiveDistributions(n, a.gradeNames, o.memberName, i) : [];
        t.each(u, function(e) {
            t.computeDistributionPriority(n, e), t.isPrimitive(e.priority) && (e.priority = t.parsePriority(e.priority, 0, !1, "options distribution"));
        }), t.sortByPriority(u);
        var s = o.localDynamic, l = e.extend({}, t.censorKeys(o.componentRecord, [ "type" ]), s), c = a.argumentMap, f = Object.keys(c).concat([ "type" ]);
        t.each(f, function(e) {
            for (var t = 0; t < u.length; ++t) void 0 !== u[t][e] && (l[e] = u[t][e]);
        }), r = l.type || r, delete l.type, delete l.options;
        var d = {
            distributions: u
        };
        void 0 !== o.componentRecord && (d.subcomponentRecord = e.extend({}, o.componentRecord));
        var p = [];
        return t.each(c, function(e, r) {
            var a;
            if ("options" === r) a = {
                marker: t.EXPAND,
                localRecord: s,
                mergeRecords: d,
                instantiator: t.getInstantiator(n),
                parentThat: n,
                memberName: o.memberName
            }; else {
                var i = l[r];
                a = t.expandImmediate(i, n, l);
            }
            p[e] = a;
        }), {
            args: p,
            funcName: r
        };
    }, t.initDependent = function(e, n, r) {
        if (!e[n]) {
            var o, a = e.options.components[n], i = t.globalInstantiator, u = i.idToShadow[e.id], s = r || u.subcomponentLocal && u.subcomponentLocal[n];
            if (t.pushActivity("initDependent", 'instantiating dependent component at path "%path" with record %record as child of %parent', {
                path: u.path + "." + n,
                record: a,
                parent: e
            }), "string" == typeof a || a.expander) e[n] = t.inEvaluationMarker, (o = t.expandImmediate(a, e)) ? i.recordKnownComponent(e, o, n, !1) : delete e[n]; else if (a.type) {
                var l = t.expandImmediate(a.type, e, s);
                l || t.fail("Error in subcomponent record: ", a.type, " could not be resolved to a type for component ", n, " of parent ", e);
                var c = t.assembleCreatorArguments(e, l, {
                    componentRecord: a,
                    memberName: n,
                    localDynamic: s
                });
                o = t.initSubcomponentImpl(e, {
                    type: c.funcName
                }, c.args);
            } else t.fail("Unrecognised material in place of subcomponent " + n + ' - no "type" field found');
            return t.popActivity(), o;
        }
    }, t.bindDeferredComponent = function(e, n, r) {
        var o = t.makeArray(r.createOnEvent);
        t.each(o, function(o) {
            var a = t.isIoCReference(o) ? t.expandOptions(o, e) : e.events[o];
            a && a.addListener || t.fail("Error instantiating createOnEvent component with name " + n + " of parent ", e, " since event specification " + o + " could not be expanded to an event - got ", a), 
            a.addListener(function() {
                t.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                    componentName: n,
                    that: e,
                    eventName: o
                }), e[n] && t.globalInstantiator.clearComponent(e, n);
                var r = {
                    arguments: t.makeArray(arguments)
                };
                t.initDependent(e, n, r), t.popActivity();
            }, null, r.priority);
        });
    }, t.priorityForComponent = function(e) {
        return e.priority ? e.priority : "fluid.typeFount" === e.type || t.hasGrade(t.defaults(e.type), "fluid.typeFount") ? "first" : void 0;
    }, t.initDependents = function(e) {
        t.pushActivity("initDependents", "instantiating dependent components for component %that", {
            that: e
        });
        var n = t.shadowForComponent(e);
        if (n.memberStrategy.initter(), n.invokerStrategy.initter(), t.getForComponent(e, "modelRelay"), 
        t.getForComponent(e, "model"), !t.isDestroyed(e)) {
            var r = e.options.components || {}, o = [];
            t.each(r, function(n, r) {
                if (n.createOnEvent) t.bindDeferredComponent(e, r, n); else {
                    var a = t.priorityForComponent(n);
                    o.push({
                        namespace: r,
                        priority: t.parsePriority(a)
                    });
                }
            }), t.sortByPriority(o), t.each(o, function(n) {
                t.initDependent(e, n.namespace);
            }), n.subcomponentLocal && t.clear(n.subcomponentLocal), e.lifecycleStatus = "constructed", 
            t.assessTreeConstruction(e, n), t.popActivity();
        }
    }, t.assessTreeConstruction = function(e, n) {
        var r = t.globalInstantiator, o = r.getThatStack(e);
        t.find_if(o, function(e) {
            return "constructing" === e.lifecycleStatus;
        }) ? e.lifecycleStatus = "constructed" : t.markSubtree(r, e, n.path, "treeConstructed");
    }, t.markSubtree = function(e, n, r, o) {
        n.lifecycleStatus = o, t.visitComponentChildren(n, function(n, a) {
            var i = e.composePath(r, a), u = e.idToShadow[n.id];
            u && u.path === i && t.markSubtree(e, n, i, o);
        }, {
            flat: !0
        });
    }, t.pathForComponent = function(e, n) {
        var r = (n = n || t.getInstantiator(e) || t.globalInstantiator).idToShadow[e.id];
        return r ? n.parseEL(r.path) : null;
    }, t.construct = function(e, n, r) {
        var o = t.destroy(e, r);
        return t.set(o.parent, [ "options", "components", o.memberName ], {
            type: n.type,
            options: n
        }), t.initDependent(o.parent, o.memberName);
    }, t.destroy = function(e, n) {
        n = n || t.globalInstantiator;
        var r = t.model.parseToSegments(e, n.parseEL, !0);
        0 === r.length && t.fail("Cannot destroy the root component");
        var o = r.pop(), a = n.composeSegments.apply(null, r), i = n.pathToComponent[a];
        return i || t.fail("Cannot modify component with nonexistent parent at path ", e), 
        i[o] && i[o].destroy(), {
            parent: i,
            memberName: o
        };
    }, t.constructSingle = function(n, r, o) {
        o = o || t.globalInstantiator, n = n || "";
        var a = t.model.parseToSegments(n, o.parseEL, !0);
        "string" == typeof r && (r = {
            type: r
        });
        var i = r.type;
        i || t.fail("Cannot construct singleton object without a type entry");
        var u = (r = e.extend({}, r)).gradeNames = t.makeArray(r.gradeNames);
        u.unshift(i), r.type = "fluid.component", 0 === a.length && u.push("fluid.resolveRoot");
        var s = t.typeNameToMemberName(r.singleRootType || i);
        a.push(s), t.construct(a, r, o);
    }, t.destroySingle = function(e, n, r) {
        r = r || t.globalInstantiator;
        var o = t.model.parseToSegments(e, r.parseEL, !0), a = t.typeNameToMemberName(n);
        o.push(a), t.destroy(o, r);
    }, t.makeGradeLinkage = function(e, n, r) {
        t.defaults(e, {
            gradeNames: "fluid.component",
            distributeOptions: {
                record: r,
                target: "{/ " + n.join("&") + "}.options.gradeNames"
            }
        }), t.constructSingle([], e);
    }, t.componentForPath = function(e) {
        return t.globalInstantiator.pathToComponent[t.isArrayable(e) ? e.join(".") : e];
    }, t.debugger = function() {}, t.defaults("fluid.debuggingProbe", {
        gradeNames: [ "fluid.component" ]
    }), t.probeToDistribution = function(e) {
        var n = t.globalInstantiator, r = t.parseContextReference(e.target), o = t.model.parseToSegments(r.path, n.parseEL, !0);
        "options" !== o[0] && o.unshift("options");
        var a = t.parsePriority(e.priority);
        return a.constraint && !a.constraint.target && (a.constraint.target = "authoring"), 
        {
            target: "{/ " + r.context + "}." + n.composeSegments.apply(null, o),
            record: {
                func: e.func,
                funcName: e.funcName,
                args: e.args,
                priority: t.renderPriority(a)
            }
        };
    }, t.registerProbes = function(e) {
        var n = t.transform(e, t.probeToDistribution), r = "fluid_debuggingProbe_" + t.allocateGuid();
        return t.construct([ r ], {
            type: "fluid.debuggingProbe",
            distributeOptions: n
        }), r;
    }, t.deregisterProbes = function(e) {
        t.destroy([ e ]);
    }, t.thisistToApplicable = function(e, n, r) {
        return {
            apply: function(o, a) {
                var i = t.expandOptions(n, r);
                "string" == typeof i && (i = t.getGlobalValue(i)), i || t.fail("Could not resolve reference " + n + " to a value");
                var u = i[e.method];
                return "function" != typeof u && t.fail("Object ", i, " at reference " + n + " has no member named " + e.method + " which is a function "), 
                t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Applying arguments ", a, " to method " + e.method + " of instance ", i), 
                u.apply(i, a);
            }
        };
    }, t.changeToApplicable = function(e, n) {
        return {
            apply: function(r, o, a, i) {
                var u = t.parseValidModelReference(n, "changePath listener record", e.changePath), s = t.expandOptions(e.value, n, {}, t.extend(a, {
                    arguments: o
                })), l = i && i.source && i.source.length ? t.makeArray(e.source).concat(i.source) : e.source;
                u.applier.change(u.modelSegs, s, e.type, l);
            }
        };
    }, t.recordToApplicable = function(e, n, r) {
        if (void 0 !== e.changePath) return t.changeToApplicable(e, n, r);
        var o = e.this;
        return e.method ^ o && t.fail("Record ", n, ' must contain both entries "method" and "this" if it contains either'), 
        e.method ? t.thisistToApplicable(e, o, n) : null;
    }, t.getGlobalValueNonComponent = function(e, n) {
        var r = t.defaults(e);
        return r && t.hasGrade(r, "fluid.component") && t.fail("Error in function specification - cannot invoke function " + e + " in the context of " + n + ": component creator functions can only be used as subcomponents"), 
        t.getGlobalValue(e);
    }, t.makeInvoker = function(e, n, r) {
        void 0 === (n = t.upgradePrimitiveFunc(n)).args || n.args === t.NO_VALUE || t.isArrayable(n.args) || (n.args = t.makeArray(n.args));
        var o = t.recordToApplicable(n, e), a = t.preExpand(n.args), i = {}, u = t.makeStackResolverOptions(e, i, !0);
        return (o = o || (n.funcName ? t.getGlobalValueNonComponent(n.funcName, "an invoker") : t.expandImmediate(n.func, e))) && o.apply ? o === t.notImplemented && t.fail("Error constructing component ", e, " - the invoker named " + r + " which was defined in grade " + n.componentSource + " needs to be overridden with a concrete implementation") : t.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + o + " from ", n), 
        function() {
            !1 === t.defeatLogging && t.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record from path %path holding component %that", {
                name: r,
                record: n,
                path: t.dumpComponentPath(e),
                that: e
            });
            var s, l;
            return "destroyed" === e.lifecycleStatus ? t.log(t.logLevel.WARN, "Ignoring call to invoker " + r + " of component ", e, " which has been destroyed") : (i.arguments = arguments, 
            void 0 === n.args || n.args === t.NO_VALUE ? l = arguments : (t.expandImmediateImpl(a, u), 
            l = a.source), s = o.apply(null, l)), !1 === t.defeatLogging && t.popActivity(), 
            s;
        };
    }, t.event.makeTrackedListenerAdder = function(e) {
        var n = t.shadowForComponent(e);
        return function(e) {
            return {
                addListener: function(r, o, a, i, u) {
                    t.recordListener(e, r, n, u), e.addListener.apply(null, arguments);
                }
            };
        };
    }, t.event.listenerEngine = function(e, n, r) {
        function o() {
            if (!t.find(e, function(e, t) {
                if (void 0 === a[t]) return !0;
            })) {
                var r = a;
                a = {}, n(r);
            }
        }
        var a = {};
        t.each(e, function(e, n) {
            r(e).addListener(function() {
                a[n] = t.makeArray(arguments), o();
            });
        });
    }, t.event.dispatchListener = function(e, n, r, o, a) {
        void 0 === o.args || o.args === t.NO_VALUE || t.isArrayable(o.args) || (o.args = t.makeArray(o.args)), 
        n = t.event.resolveListener(n);
        var i = t.preExpand(o.args), u = {}, s = t.makeStackResolverOptions(e, u, !0), l = function() {
            !1 === t.defeatLogging && t.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                eventName: r,
                that: e
            });
            var l, c = a ? arguments[0] : arguments;
            u.arguments = c, void 0 !== o.args && o.args !== t.NO_VALUE ? (t.expandImmediateImpl(i, s), 
            l = i.source) : l = c;
            var f = n.apply(null, l);
            return !1 === t.defeatLogging && t.popActivity(), f;
        };
        return t.event.impersonateListener(n, l), l;
    }, t.event.resolveSoftNamespace = function(e) {
        if ("string" != typeof e) return null;
        var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
        return e.substring(t + 1);
    }, t.event.resolveListenerRecord = function(e, n, r, o, a) {
        var i = function(e, n) {
            t.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + n);
        };
        t.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
            eventName: r,
            that: n
        });
        var u = t.makeArray(e), s = {
            records: t.transform(u, function(e) {
                var u = t.isPrimitive(e) || e.expander ? {
                    listener: e
                } : t.copy(e), s = t.recordToApplicable(e, n, a);
                u.listener = s || (u.listener || u.func || u.funcName), u.listener || i(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                var l = e.method ? t.event.resolveSoftNamespace(e.this) + "." + e.method : t.event.resolveSoftNamespace(u.listener);
                u.namespace || o || !l || (u.softNamespace = !0, u.namespace = (e.componentSource ? e.componentSource : n.typeName) + "." + l);
                var c = u.listener = t.expandOptions(u.listener, n);
                c || i(e, "");
                var f = !1;
                return "fluid.event.firer" === c.typeName && (c = c.fire, f = !0), u.listener = a && (u.args && "fluid.notImplemented" !== c || f) ? t.event.dispatchListener(n, c, r, u) : c, 
                u.listenerId = t.allocateGuid(), u;
            }),
            adderWrapper: a ? t.event.makeTrackedListenerAdder(n) : null
        };
        return t.popActivity(), s;
    }, t.event.expandOneEvent = function(e, n) {
        var r;
        return (r = "string" == typeof n && "{" !== n.charAt(0) ? t.getForComponent(e, [ "events", n ]) : t.expandOptions(n, e)) && "fluid.event.firer" === r.typeName || t.fail("Error in event specification - could not resolve base event reference ", n, " to an event firer: got ", r), 
        r;
    }, t.event.expandEvents = function(e, n) {
        return "string" == typeof n ? t.event.expandOneEvent(e, n) : t.transform(n, function(n) {
            return t.event.expandOneEvent(e, n);
        });
    }, t.event.resolveEvent = function(e, n, r) {
        t.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
            eventName: n,
            that: e
        });
        var o = t.event.makeTrackedListenerAdder(e);
        "string" == typeof r && (r = {
            event: r
        });
        var a = "fluid.event.firer" === r.typeName ? r : r.event || r.events;
        a || t.fail("Event specification for event with name " + n + " does not include a base event specification: ", r);
        var i, u = "fluid.event.firer" === a.typeName ? a : t.event.expandEvents(e, a), s = "fluid.event.firer" !== u.typeName;
        if (r.args || s) {
            i = t.makeEventFirer({
                name: " [composite] " + t.event.nameEvent(e, n)
            });
            var l = t.event.dispatchListener(e, i.fire, n, r, s);
            s ? t.event.listenerEngine(u, l, o) : o(u).addListener(l);
        } else (i = {
            typeName: "fluid.event.firer"
        }).fire = function() {
            var e = t.makeArray(arguments);
            t.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                eventName: n
            });
            var r = u.fire.apply(null, e);
            return t.popActivity(), r;
        }, i.addListener = function(a, i, s, l, c) {
            var f = t.event.dispatchListener(e, a, n, r);
            o(u).addListener(f, i, s, l, c);
        }, i.removeListener = function(e) {
            u.removeListener(e);
        };
        return t.popActivity(), i;
    }, t.withEnvironment = function(n, r, o) {
        var a;
        o = o || t.globalThreadLocal();
        try {
            for (a in n) o[a] = n[a];
            return e.extend(o, n), r();
        } finally {
            for (a in n) delete o[a];
        }
    }, t.fetchContextReference = function(e, n, r, o, a) {
        o && (e = o(e, r));
        var i = e.context ? r[e.context] : n;
        return i ? e.noDereference ? e.path : t.get(i, e.path) : a && a(e) || i;
    }, t.makeEnvironmentFetcher = function(e, n, r, o) {
        return r = r || t.globalThreadLocal, function(a) {
            var i = r();
            return t.fetchContextReference(a, e, i, n, o);
        };
    }, t.coerceToPrimitive = function(e) {
        return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
    }, t.compactStringToRec = function(n, r) {
        var o = n.indexOf("("), a = n.indexOf(")");
        if ((-1 === o ^ -1 === a || o > a) && t.fail("Badly-formed compact " + r + " record without matching parentheses: " + n), 
        -1 !== o && -1 !== a) {
            var i = n.substring(a + 1);
            "" !== e.trim(i) && t.fail("Badly-formed compact " + r + " record " + n + " - unexpected material following close parenthesis: " + i);
            var u = n.substring(0, o), s = e.trim(n.substring(o + 1, a)), l = "" === s ? [] : t.transform(s.split(","), e.trim, t.coerceToPrimitive), c = t.upgradePrimitiveFunc(u, null);
            return c.args = l, c;
        }
        return "expander" === r && t.fail("Badly-formed compact expander record without parentheses: " + n), 
        n;
    }, t.expandPrefix = "@expand:", t.expandCompactString = function(e, n) {
        var r = e;
        if (0 === e.indexOf(t.expandPrefix)) {
            var o = e.substring(t.expandPrefix.length);
            r = {
                expander: t.compactStringToRec(o, "expander")
            };
        } else n && (r = t.compactStringToRec(e, n));
        return r;
    };
    var a = {
        listeners: "listener",
        modelListeners: "modelListener"
    }, i = e.extend({
        invokers: "invoker"
    }, a);
    t.expandCompactRec = function(e, n, r) {
        t.guardCircularExpansion(e, e.length);
        var o = e.length > 0 ? e[e.length - 1] : "", u = i[o];
        !u && e.length > 1 && (u = a[e[e.length - 2]]), t.each(r, function(r, o) {
            if (t.isPlainObject(r)) return n[o] = t.freshContainer(r), e.push(o), t.expandCompactRec(e, n[o], r), 
            void e.pop();
            "string" == typeof r && (r = t.expandCompactString(r, u)), n[o] = r;
        });
    }, t.expandCompact = function(e) {
        var n = {};
        return t.expandCompactRec([], n, e), n;
    }, t.extractEL = function(e, t) {
        if ("ALL" === t.ELstyle) return e;
        if (1 === t.ELstyle.length) {
            if (e.charAt(0) === t.ELstyle) return e.substring(1);
        } else if ("${}" === t.ELstyle) {
            var n = e.indexOf("${"), r = e.lastIndexOf("}");
            if (0 === n && -1 !== r) return e.substring(2, r);
        }
    }, t.extractELWithContext = function(e, n) {
        var r = t.extractEL(e, n);
        return t.isIoCReference(r) ? t.parseContextReference(r) : r ? {
            path: r
        } : r;
    }, t.parseContextReference = function(e, n, r) {
        n = n || 0;
        var o, a, i, u = "{" === e.charAt(n + 1);
        -1 === (o = u ? (i = t.parseContextReference(e, n + 1, "}")).endpos : e.indexOf("}", n + 1)) && t.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
        a = u ? i : e.substring(n + 1, o);
        var s = r ? e.indexOf(r, o + 1) : e.length, l = e.substring(o + 1, s);
        return "." === l.charAt(0) && (l = l.substring(1)), {
            context: a,
            path: l,
            endpos: s
        };
    }, t.renderContextReference = function(e) {
        var n = e.context;
        return "{" + ("string" == typeof n ? n : t.renderContextReference(n)) + "}" + (e.path ? "." + e.path : "");
    }, t.resolveContextValue = function(e, n) {
        function r(e) {
            t.pushActivity("resolveContextValue", "resolving context value %parsed", {
                parsed: e
            });
            var r = n.fetcher(e);
            return t.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                parsed: e,
                value: r
            }), t.popActivity(2), r;
        }
        var o;
        if (n.bareContextRefs && t.isIoCReference(e)) return o = t.parseContextReference(e), 
        r(o);
        if (n.ELstyle && "${}" !== n.ELstyle && (o = t.extractELWithContext(e, n))) return r(o);
        for (;"string" == typeof e; ) {
            var a = e.indexOf("${"), i = e.indexOf("}", a + 2);
            if (-1 === a || -1 === i) break;
            "{" === e.charAt(a + 2) ? i = (o = t.parseContextReference(e, a + 2, "}")).endpos : o = {
                path: e.substring(a + 2, i)
            };
            var u = r(o), s = 0 === a && i === e.length - 1;
            if (void 0 === u || null === u) return u;
            e = s ? u : e.substring(0, a) + u + e.substring(i + 1);
        }
        return e;
    }, t.fetchExpandChildren = function(n, r, o, a, i, u) {
        if (a.expander) {
            var s = t.expandExpander(n, a, u);
            if (t.isPrimitive(s) || !t.isPlainObject(s) || t.isArrayable(s) ^ t.isArrayable(n)) return s;
            e.extend(!0, n, s);
        }
        return t.each(a, function(e, s) {
            void 0 === e ? n[s] = void 0 : "expander" !== s && (o[r] = s, !0 !== t.getImmediate(u.exceptions, o, r) && u.strategy(n, s, r + 1, o, a, i));
        }), n;
    }, t.isUnexpandable = function(e) {
        return t.isPrimitive(e) || !t.isPlainObject(e);
    }, t.expandSource = function(e, n, r, o, a, i, u, s) {
        var l, c, f = t.derefMergePolicy(u);
        return "string" != typeof i || f.noexpand ? f.noexpand || t.isUnexpandable(i) ? l = i : i.expander ? l = t.expandExpander(a, i, e) : (l = t.freshContainer(i), 
        c = !0) : e.defaultEL && "{" !== i.charAt(0) ? l = i : (t.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
            source: i,
            path: t.path.apply(null, o.slice(0, r))
        }), l = t.resolveContextValue(i, e), t.popActivity(1)), l !== t.NO_VALUE && a(l), 
        c && s(l, i, r, o, u), l;
    }, t.guardCircularExpansion = function(e, n) {
        n > t.strategyRecursionBailout && t.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", n, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
    }, t.makeExpandStrategy = function(e) {
        var r = function(n, r, o, a, i) {
            return t.fetchExpandChildren(n, o || 0, a || [], r, i, e);
        }, o = function(o, a, i, u, s, l) {
            if (t.guardCircularExpansion(u, i), o) {
                if (o.hasOwnProperty(a)) return o[a];
                void 0 === s && (s = n(e.source, u, i - 1, e.sourceStrategy), l = n(e.mergePolicy, u, i - 1, t.concreteTrundler));
                var c = e.sourceStrategy(s, a, i, u), f = t.concreteTrundler(l, a);
                return t.expandSource(e, o, i, u, function(e) {
                    o[a] = e;
                }, c, f, r);
            }
        };
        return e.recurse = r, e.strategy = o, o;
    }, t.defaults("fluid.makeExpandOptions", {
        ELstyle: "${}",
        bareContextRefs: !0,
        target: t.inCreationMarker
    }), t.makeExpandOptions = function(n, r) {
        return r = e.extend({}, t.rawDefaults("fluid.makeExpandOptions"), r), r.defaultEL = "${}" === r.ELStyle && r.bareContextRefs, 
        r.expandSource = function(e) {
            return t.expandSource(r, null, 0, [], t.identity, e, r.mergePolicy, !1);
        }, t.isUnexpandable(n) ? (r.strategy = t.concreteTrundler, r.initter = t.identity, 
        r.target = "string" == typeof n ? (r.defer ? t.copy : t.identity)(r.expandSource(n)) : n, 
        r.immutableTarget = !0) : (r.source = n, r.target = t.freshContainer(n), r.sourceStrategy = r.sourceStrategy || t.concreteTrundler, 
        t.makeExpandStrategy(r), r.initter = function() {
            r.target = t.fetchExpandChildren(r.target, 0, [], r.source, r.mergePolicy, r);
        }), r;
    }, t.expand = function(e, n) {
        var r = t.makeExpandOptions(e, n);
        return r.initter(), r.target;
    }, t.preExpandRecurse = function(e, n, r, o, a) {
        function i(t) {
            e.expanders.push({
                expander: t,
                holder: r,
                member: o
            }), delete r[o];
        }
        if (t.guardCircularExpansion(a, a.length), t.isIoCReference(n)) {
            var u = t.parseContextReference(n), s = t.model.parseEL(u.path);
            i({
                typeFunc: t.expander.fetch,
                context: u.context,
                segs: s
            });
        } else t.isPlainObject(n) && (n.expander ? (n.expander.typeFunc = t.getGlobalValue(n.expander.type || "fluid.invokeFunc"), 
        i(n.expander)) : t.each(n, function(r, o) {
            a.push(o), t.preExpandRecurse(e, r, n, o, a), a.pop();
        }));
    }, t.preExpand = function(e) {
        var n = {
            expanders: [],
            source: t.isUnexpandable(e) ? e : t.copy(e)
        };
        return t.preExpandRecurse(n, n.source, n, "source", []), n;
    }, t.expandImmediate = function(e, n, r) {
        var o = t.makeStackResolverOptions(n, r, !0), a = t.preExpand(e);
        return t.expandImmediateImpl(a, o), a.source;
    }, t.expandImmediateImpl = function(e, t) {
        for (var n = e.expanders, r = 0; r < n.length; ++r) {
            var o = n[r];
            o.holder[o.member] = o.expander.typeFunc(null, o, t);
        }
    }, t.expandExpander = function(e, n, r) {
        var o = t.getGlobalValue(n.expander.type || "fluid.invokeFunc");
        return o || t.fail("Unknown expander with type " + n.expander.type), o(e, n, r);
    }, t.registerNamespace("fluid.expander"), t.expander.fetch = function(e, n, r) {
        var o = r.localRecord, a = n.expander.context, i = n.expander.segs, u = void 0 !== o[a], s = r.contextThat.lifecycleStatus, l = "treeConstructed" === s || "destroyed" === s, c = u ? o[a] : t.resolveContext(a, r.contextThat, l);
        if (c) {
            var f = c;
            if (u || "constructing" !== c.lifecycleStatus) for (var d = 0; d < i.length; ++d) f = f ? f[i[d]] : void 0; else f = t.getForComponent(c, i);
            return void 0 !== f || u || (f = t.getForComponent(c, i)), f;
        }
        i.length > 0 && t.triggerMismatchedPathError(n.expander, r.contextThat);
    }, t.invokeFunc = function(e, n, r) {
        var o = n.expander, a = t.makeArray(o.args);
        o.args = a, a = r.recurse ? r.recurse([], a) : (o = t.expandImmediate(o, r.contextThat, r.localRecord)).args;
        var i = o.func || o.funcName, u = (r.expandSource ? r.expandSource(i) : i) || t.recordToApplicable(o, r.contextThat);
        return "string" == typeof u && (u = t.getGlobalValue(u)), u || t.fail("Error in expander record ", o, ": " + i + " could not be resolved to a function for component ", r.contextThat), 
        u.apply(null, a);
    }, t.noexpand = function(e, t) {
        return t.expander.value ? t.expander.value : t.expander.tree;
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    t.model.makeEnvironmentStrategy = function(e) {
        return function(t, n, r) {
            return 0 === r && e[n] ? e[n] : void 0;
        };
    }, t.model.defaultCreatorStrategy = function(e, t) {
        if (void 0 === e[t]) return e[t] = {}, e[t];
    }, t.model.defaultFetchStrategy = function(e, t) {
        return e[t];
    }, t.model.funcResolverStrategy = function(e, t) {
        if (e.resolvePathSegment) return e.resolvePathSegment(t);
    }, t.model.traverseWithStrategy = function(e, n, r, o, a) {
        for (var i = o.strategies, u = n.length - a, s = r; s < u; ++s) {
            if (!e) return e;
            for (var l, c = 0; c < i.length && void 0 === (l = i[c](e, n[s], s + 1, n)); ++c) ;
            l === t.NO_VALUE && (l = void 0), e = l;
        }
        return e;
    }, t.model.getValueAndSegments = function(e, n, r, o) {
        return t.model.accessWithStrategy(e, n, t.NO_VALUE, r, o, !0);
    }, t.model.makeTrundler = function(e) {
        return function(n, r) {
            return t.model.getValueAndSegments(n.root, r, e, n.segs);
        };
    }, t.model.getWithStrategy = function(e, n, r, o) {
        return t.model.accessWithStrategy(e, n, t.NO_VALUE, r, o);
    }, t.model.setWithStrategy = function(e, n, r, o, a) {
        t.model.accessWithStrategy(e, n, r, o, a);
    }, t.model.accessWithStrategy = function(e, n, r, o, a, i) {
        if (t.isPrimitive(n) || t.isArrayable(n)) return t.model.accessImpl(e, n, r, o, a, i, t.model.traverseWithStrategy);
        var u = n.type || "default", s = o.resolvers[u];
        s || t.fail("Unable to find resolver of type " + u);
        var l = t.model.makeTrundler(o), c = {
            root: e,
            segs: a
        };
        return c = s(c, n, l), n.path && c && (c = l(c, n.path)), i ? c : c ? c.root : void 0;
    }, t.registerNamespace("fluid.pathUtil"), t.pathUtil.getPathSegmentImpl = function(e, t, n) {
        var r = null;
        e && (r = "");
        for (var o = !1, a = t.length; n < a; ++n) {
            var i = t.charAt(n);
            if (o) o = !1, null !== r && (r += i); else {
                if ("." === i) break;
                "\\" === i ? o = !0 : null !== r && (r += i);
            }
        }
        return null !== r && (e[0] = r), n;
    };
    var n = [];
    t.pathUtil.parseEL = function(e) {
        for (var r = [], o = 0, a = e.length; o < a; ) {
            var i = t.pathUtil.getPathSegmentImpl(n, e, o);
            r.push(n[0]), o = i + 1;
        }
        return r;
    }, t.pathUtil.composeSegment = function(e, t) {
        t = t.toString();
        for (var n = 0; n < t.length; ++n) {
            var r = t.charAt(n);
            "." !== r && "\\" !== r && "}" !== r || (e += "\\"), e += r;
        }
        return e;
    }, t.pathUtil.escapeSegment = function(e) {
        return t.pathUtil.composeSegment("", e);
    }, t.pathUtil.composePath = function(e, n) {
        return 0 !== e.length && (e += "."), t.pathUtil.composeSegment(e, n);
    }, t.pathUtil.composeSegments = function() {
        for (var e = "", n = 0; n < arguments.length; ++n) e = t.pathUtil.composePath(e, arguments[n]);
        return e;
    }, t.pathUtil.matchSegments = function(e, t, n, r) {
        if (r - n !== e.length) return !1;
        for (var o = n; o < r; ++o) if (t[o] !== e[o - n]) return !1;
        return !0;
    }, t.model.unescapedParser = {
        parse: t.model.parseEL,
        compose: t.model.composeSegments
    }, t.model.defaultGetConfig = {
        parser: t.model.unescapedParser,
        strategies: [ t.model.funcResolverStrategy, t.model.defaultFetchStrategy ]
    }, t.model.defaultSetConfig = {
        parser: t.model.unescapedParser,
        strategies: [ t.model.funcResolverStrategy, t.model.defaultFetchStrategy, t.model.defaultCreatorStrategy ]
    }, t.model.escapedParser = {
        parse: t.pathUtil.parseEL,
        compose: t.pathUtil.composeSegments
    }, t.model.escapedGetConfig = {
        parser: t.model.escapedParser,
        strategies: [ t.model.defaultFetchStrategy ]
    }, t.model.escapedSetConfig = {
        parser: t.model.escapedParser,
        strategies: [ t.model.defaultFetchStrategy, t.model.defaultCreatorStrategy ]
    }, t.initRelayModel = function(e) {
        return t.deenlistModelComponent(e), e.model;
    }, t.isModelComplete = function(e) {
        return "model" in e && e.model !== t.inEvaluationMarker;
    }, t.enlistModelComponent = function(e) {
        var n = t.getInstantiator(e), r = n.modelTransactions.init[e.id];
        return r || (r = {
            that: e,
            applier: t.getForComponent(e, "applier"),
            complete: t.isModelComplete(e)
        }, n.modelTransactions.init[e.id] = r), r;
    }, t.clearTransactions = function() {
        var e = t.globalInstantiator;
        t.clear(e.modelTransactions), e.modelTransactions.init = {};
    }, t.failureEvent.addListener(t.clearTransactions, "clearTransactions", "before:fail"), 
    t.clearLinkCounts = function(e, n) {
        t.each(e, function(t, r) {
            "number" == typeof t ? e[r] = 0 : n && t.options && "number" == typeof t.relayCount && (t.relayCount = 0);
        });
    }, t.sortCompleteLast = function(e, t) {
        return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
    }, t.operateInitialTransaction = function(e, n) {
        var r, o = t.allocateGuid(), a = t.getModelTransactionRec(e, o), i = t.transform(n, function(e) {
            return r = e.that.applier.initiate(null, "init", o), a[e.that.applier.applierId] = {
                transaction: r
            }, r;
        }), u = t.values(n).sort(t.sortCompleteLast);
        t.each(u, function(e) {
            var n = e.that, r = i[n.id];
            e.completeOnInit ? t.initModelEvent(n, n.applier, r, n.applier.listeners.sortedListeners) : t.each(e.initModels, function(e) {
                r.fireChangeRequest({
                    type: "ADD",
                    segs: [],
                    value: e
                }), t.clearLinkCounts(a, !0);
            });
            var o = t.shadowForComponent(n);
            o && (o.modelComplete = !0);
        }), r.commit();
    }, t.deenlistModelComponent = function(e) {
        var n = t.getInstantiator(e), r = n.modelTransactions.init;
        if (r[e.id] && (e.model = void 0, r[e.id].complete = !0, !t.find_if(r, function(e) {
            return !0 !== e.complete;
        }))) {
            try {
                t.operateInitialTransaction(e, r);
            } catch (e) {
                throw t.clearTransactions(), e;
            }
            n.modelTransactions.init = {};
        }
    }, t.parseModelReference = function(e, n) {
        var r = t.parseContextReference(n);
        return r.segs = e.applier.parseEL(r.path), r;
    }, t.parseValidModelReference = function(e, n, r, o) {
        var a, i = function() {
            var e = [ "Error in " + n + ": ", r ].concat(t.makeArray(arguments));
            t.fail.apply(null, e);
        }, u = function(e) {
            i(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
        };
        if ("string" == typeof r) if (t.isIoCReference(r)) {
            var s = (a = t.parseModelReference(e, r)).segs.indexOf("model");
            -1 === s ? o ? a.nonModel = !0 : i(' must be a reference into a component model via a path including the segment "model"') : (a.modelSegs = a.segs.slice(s + 1), 
            a.contextSegs = a.segs.slice(0, s), delete a.path);
        } else a = {
            path: r,
            modelSegs: e.applier.parseEL(r)
        }; else t.isArrayable(r.segs) || i(' must contain an entry "segs" holding path segments referring a model path within a component'), 
        a = {
            context: r.context,
            modelSegs: t.expandOptions(r.segs, e)
        };
        var l, c;
        return a.context ? ((l = t.resolveContext(a.context, e)) || i(" context must be a reference to an existing component"), 
        c = a.contextSegs ? t.getForComponent(l, a.contextSegs) : l) : c = e, a.nonModel || (t.isComponent(c) || u(c), 
        c.applier || t.getForComponent(c, [ "applier" ]), c.applier || u(c)), a.that = c, 
        a.applier = c && c.applier, a.path || (a.path = c && c.applier.composeSegments.apply(null, a.modelSegs)), 
        a;
    }, t.getModelTransactionRec = function(e, n) {
        var r = t.getInstantiator(e);
        if (n || t.fail("Cannot get transaction record without transaction id"), !r) return null;
        var o = r.modelTransactions[n];
        return o || (o = r.modelTransactions[n] = {
            relays: [],
            sources: {},
            externalChanges: {}
        }), o;
    }, t.recordChangeListener = function(e, n, r, o) {
        var a = t.shadowForComponent(e);
        t.recordListener(n.modelChanged, r, a, o);
    }, t.registerRelayTransaction = function(e, n, r, o, a) {
        var i = n.initiate("relay", null, r), u = e[n.applierId] = {
            transaction: i,
            relayCount: 0,
            namespace: a.namespace,
            priority: a.priority,
            options: o
        };
        return u.priority = t.parsePriority(u.priority, e.relays.length, !1, "model relay"), 
        e.relays.push(u), u;
    }, t.relayRecursionBailout = 100, t.registerDirectChangeRelay = function(e, n, r, o, a, i, u, s) {
        var l = u.targetApplier || e.applier, c = u.sourceApplier || r.applier, f = l.applierId;
        n = t.makeArray(n);
        var d, p = function(r, c, d, p, m, g) {
            var h = m.id, v = t.getModelTransactionRec(e, h);
            g && m && !v[g.applierId] && (v[g.applierId] = {
                transaction: m
            });
            var y = v[f];
            v[a] = v[a] || 0;
            ++v[a], v[a] > t.relayRecursionBailout && t.fail("Error in model relay specification at component ", e, " - operated more than " + t.relayRecursionBailout + " relays without model value settling - current model contents are ", m.newHolder.model), 
            y || (y = t.registerRelayTransaction(v, l, h, u, s)), i && !u.targetApplier ? i(y.transaction, u.sourceApplier ? void 0 : r, o, n, p) : (!u.noRelayDeletesDirect && p && "DELETE" === p.type && y.transaction.fireChangeRequest({
                type: "DELETE",
                segs: n
            }), void 0 !== r && y.transaction.fireChangeRequest({
                type: "ADD",
                segs: n,
                value: r
            }));
        };
        (o = o ? t.makeArray(o) : o) && (d = c.modelChanged.addListener({
            isRelay: !0,
            segs: o,
            transactional: u.transactional
        }, p), t.passLogLevel(t.logLevel.TRACE) && t.log(t.logLevel.TRACE, "Adding relay listener with listenerId " + d.listenerId + " to source applier with id " + c.applierId + " from target applier with id " + f + " for target component with id " + e.id)), 
        r && (t.recordChangeListener(r, c, p, d.listenerId), e !== r && t.recordChangeListener(e, c, p, d.listenerId));
    }, t.connectModelRelay = function(e, n, r, o, a) {
        function i(e) {
            var n = t.enlistModelComponent(e);
            n.complete && t.shadowForComponent(e).modelComplete && (n.completeOnInit = !0);
        }
        var u = t.allocateGuid();
        i(r), i(e);
        var s = t.filterKeys(a, [ "namespace", "priority" ]);
        a.update ? a.targetApplier ? t.registerDirectChangeRelay(e, n, r, o, u, null, {
            transactional: !1,
            targetApplier: a.targetApplier,
            update: a.update
        }, s) : t.registerDirectChangeRelay(r, o, e, [], u + "-transform", a.forwardAdapter, {
            transactional: !0,
            sourceApplier: a.forwardApplier
        }, s) : (t.registerDirectChangeRelay(r, o, e, n, u, a.forwardAdapter, {
            transactional: !1
        }, s), n && t.registerDirectChangeRelay(e, n, r, o, u, a.backwardAdapter, {
            transactional: !1
        }, s));
    }, t.parseSourceExclusionSpec = function(e, n) {
        return e.excludeSource = t.arrayToHash(t.makeArray(n.excludeSource || (n.includeSource ? "*" : void 0))), 
        e.includeSource = t.arrayToHash(t.makeArray(n.includeSource)), e;
    }, t.isExcludedChangeSource = function(e, t) {
        if (!t || !t.excludeSource) return !1;
        var n = t.excludeSource["*"];
        for (var r in e.fullSources) t.excludeSource[r] && (n = !0), t.includeSource[r] && (n = !1);
        return n;
    }, t.model.guardedAdapter = function(e, n, r, o) {
        t.isExcludedChangeSource(e, n) || r === t.model.transform.uninvertibleTransform || r.apply(null, o);
    }, t.transformToAdapter = function(e, n) {
        var r = {};
        return r[n] = e, function(e, o, a, i, u) {
            u && "DELETE" === u.type && e.fireChangeRequest({
                type: "DELETE",
                path: n
            }), t.model.transformWithRules(o, r, {
                finalApplier: e
            });
        };
    }, t.makeTransformPackage = function(e, n, r, o, a, i, u, s) {
        var l = {
            forwardHolder: {
                model: n
            },
            backwardHolder: {
                model: null
            }
        };
        l.generateAdapters = function(e) {
            if (l.forwardAdapterImpl = t.transformToAdapter(e ? e.newHolder.model : l.forwardHolder.model, o), 
            null !== r) {
                var a = t.model.transform.invertConfiguration(n);
                a !== t.model.transform.uninvertibleTransform ? (l.backwardHolder.model = a, l.backwardAdapterImpl = t.transformToAdapter(l.backwardHolder.model, r)) : l.backwardAdapterImpl = a;
            }
        }, l.forwardAdapter = function(e, n) {
            void 0 === n && l.generateAdapters(), t.model.guardedAdapter(e, a, l.forwardAdapterImpl, arguments);
        }, l.runTransform = function(e) {
            e.commit(), e.reset();
        }, l.forwardApplier = t.makeHolderChangeApplier(l.forwardHolder), l.forwardApplier.isRelayApplier = !0, 
        l.invalidator = t.makeEventFirer({
            name: "Invalidator for model relay with applier " + l.forwardApplier.applierId
        }), null !== r && (l.backwardApplier = t.makeHolderChangeApplier(l.backwardHolder), 
        l.backwardAdapter = function(e) {
            t.model.guardedAdapter(e, i, l.backwardAdapterImpl, arguments);
        }), l.update = l.invalidator.fire;
        var c = {
            targetApplier: l.forwardApplier,
            update: l.update,
            namespace: u,
            priority: s,
            refCount: 0
        };
        return l.forwardHolder.model = t.parseImplicitRelay(e, n, [], c), l.refCount = c.refCount, 
        l.namespace = u, l.priority = s, l.generateAdapters(), l.invalidator.addListener(l.generateAdapters), 
        l.invalidator.addListener(l.runTransform), l;
    }, t.singleTransformToFull = function(t) {
        return {
            "": {
                transform: e.extend(!0, {
                    inputPath: ""
                }, t)
            }
        };
    }, t.model.relayConditions = {
        initOnly: {
            includeSource: "init"
        },
        liveOnly: {
            excludeSource: "init"
        },
        never: {
            includeSource: []
        },
        always: {}
    }, t.model.parseRelayCondition = function(e) {
        "initOnly" === e ? t.log(t.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && t.log(t.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead');
        var n;
        return e ? "string" == typeof e ? (n = t.model.relayConditions[e]) || t.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : n = e : n = {}, 
        t.parseSourceExclusionSpec({}, n);
    }, t.parseModelRelay = function(e, n, r) {
        var o = void 0 !== n.source ? t.parseValidModelReference(e, 'modelRelay record member "source"', n.source) : {
            path: null,
            modelSegs: null
        }, a = t.parseValidModelReference(e, 'modelRelay record member "target"', n.target), i = n.namespace || r, u = n.singleTransform ? t.singleTransformToFull(n.singleTransform) : n.transform;
        u || t.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', n);
        var s = t.model.parseRelayCondition(n.forward), l = t.model.parseRelayCondition(n.backward), c = t.makeTransformPackage(e, u, o.path, a.path, s, l, i, n.priority), f = {
            noRelayDeletesDirect: !0
        };
        0 === c.refCount ? t.connectModelRelay(o.that || e, o.modelSegs, a.that, a.modelSegs, t.filterKeys(c, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ]), f) : (o.modelSegs && t.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', n, " for component ", e), 
        t.connectModelRelay(o.that || e, o.modelSegs, a.that, a.modelSegs, c));
    }, t.parseImplicitRelay = function(e, n, r, o) {
        var a;
        if (t.isIoCReference(n)) {
            var i = t.parseValidModelReference(e, "model reference from model (implicit relay)", n, !0);
            i.nonModel ? a = t.getForComponent(i.that, i.segs) : (++o.refCount, t.connectModelRelay(e, r, i.that, i.modelSegs, o));
        } else t.isPrimitive(n) || !t.isPlainObject(n) ? a = n : n.expander && t.isPlainObject(n.expander) ? a = t.expandOptions(n, e) : (a = t.freshContainer(n), 
        t.each(n, function(n, i) {
            r.push(i);
            var u = t.parseImplicitRelay(e, n, r, o);
            void 0 !== u && (a[i] = u), r.pop();
        }));
        return a;
    }, t.model.notifyExternal = function(e) {
        var n = e ? t.values(e.externalChanges) : [];
        t.sortByPriority(n);
        for (var r = 0; r < n.length; ++r) {
            var o = n[r];
            o.args[5].destroyed || o.listener.apply(null, o.args);
        }
        t.clearLinkCounts(e, !0);
    }, t.model.commitRelays = function(e, n) {
        var r = e.modelTransactions[n];
        t.each(r, function(e) {
            e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
        });
    }, t.model.updateRelays = function(e, n) {
        var r = e.modelTransactions[n], o = 0;
        return t.sortByPriority(r.relays), t.each(r.relays, function(e) {
            e.transaction.changeRecord.changes > 0 && e.relayCount < 2 && e.options.update && (e.relayCount++, 
            t.clearLinkCounts(r), e.options.update(e.transaction, r), ++o);
        }), o;
    }, t.establishModelRelay = function(e, n, r, o, a) {
        var i = t.shadowForComponent(e);
        i.modelRelayEstablished ? t.fail("FLUID-5887 failure: Model relay initialised twice on component", e) : i.modelRelayEstablished = !0, 
        t.mergeModelListeners(e, r);
        var u = t.enlistModelComponent(e);
        t.each(o, function(n, r) {
            for (var o = 0; o < n.length; ++o) t.parseModelRelay(e, n[o], r);
        });
        var s = t.transform(n, function(n) {
            return t.parseImplicitRelay(e, n, [], {
                refCount: 0,
                priority: "first"
            });
        });
        u.initModels = s;
        var l = t.getInstantiator(e);
        return a.preCommit.addListener(function(e) {
            for (;t.model.updateRelays(l, e.id) > 0; ) ;
        }), a.preCommit.addListener(function(e, n, r) {
            "relay" !== r && t.model.commitRelays(l, e.id);
        }), a.postCommit.addListener(function(e, n, r) {
            "relay" !== r && (t.model.notifyExternal(l.modelTransactions[e.id]), delete l.modelTransactions[e.id]);
        }), null;
    }, t.defaults("fluid.modelComponent", {
        gradeNames: [ "fluid.component" ],
        changeApplierOptions: {
            relayStyle: !0,
            cullUnchanged: !0
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: !0,
                func: t.arrayConcatPolicy
            },
            modelListeners: t.makeMergeListenersPolicy(t.arrayConcatPolicy),
            modelRelay: t.makeMergeListenersPolicy(t.arrayConcatPolicy, !0)
        }
    }), t.modelChangedToChange = function(e) {
        return {
            value: e[0],
            oldValue: e[1],
            path: e[2],
            transaction: e[4]
        };
    }, t.event.invokeListener = function(e, n, r, o) {
        return "string" == typeof e && (e = t.event.resolveListener(e)), e.apply(null, n, r, o);
    }, t.resolveModelListener = function(e, n) {
        var r = function() {
            if (!t.isDestroyed(e)) {
                var r = t.modelChangedToChange(arguments), o = arguments, a = {
                    change: r,
                    arguments: o
                }, i = {
                    source: Object.keys(r.transaction.sources)
                };
                n.args && (o = t.expandOptions(n.args, e, {}, a)), t.event.invokeListener(n.listener, t.makeArray(o), a, i);
            }
        };
        return t.event.impersonateListener(n.listener, r), r;
    }, t.registerModelListeners = function(e, n, r, o) {
        var a = t.resolveModelListener(e, n);
        t.each(n.byTarget, function(r) {
            var i = r[0], u = {
                listener: a,
                listenerId: t.allocateGuid(),
                segsArray: t.getMembers(r, "modelSegs"),
                pathArray: t.getMembers(r, "path"),
                includeSource: n.includeSource,
                excludeSource: n.excludeSource,
                priority: t.expandOptions(n.priority, e),
                transactional: !0
            };
            u = i.applier.modelChanged.addListener(u, a, o, n.softNamespace), t.recordChangeListener(e, i.applier, a, u.listenerId), 
            e === i.that || t.isModelComplete(e) || t.getForComponent(e, [ "events", "onCreate" ]).addListener(function() {
                if (t.isModelComplete(i.that)) {
                    var n = i.applier.initiate(null, "init");
                    t.initModelEvent(e, i.applier, n, [ u ]), n.commit();
                }
            });
        });
    }, t.mergeModelListeners = function(e, n) {
        t.each(n, function(n, r) {
            "string" == typeof n && (n = {
                funcName: n
            });
            var o = t.event.resolveListenerRecord(n, e, "modelListeners", null, !1).records;
            t.each(o, function(n) {
                n.byTarget = {};
                var o = t.makeArray(void 0 === n.path ? r : n.path);
                t.each(o, function(r) {
                    var o = t.parseValidModelReference(e, "modelListeners entry", r);
                    t.pushArray(n.byTarget, o.that.id, o);
                });
                var a = (n.namespace && !n.softNamespace ? n.namespace : null) || (void 0 !== n.path ? r : null);
                t.registerModelListeners(e, n, o, a);
            });
        });
    }, t.fireChanges = function(e, t) {
        for (var n = 0; n < t.length; ++n) e.fireChangeRequest(t[n]);
    }, t.model.isChangedPath = function(e, t) {
        for (var n = 0; n <= t.length; ++n) {
            if ("string" == typeof e) return !0;
            n < t.length && e && (e = e[t[n]]);
        }
        return !1;
    }, t.model.setChangedPath = function(e, n, r) {
        var o = function(o) {
            n.unshift(o), t.model.setSimple(e, n, r), n.shift();
        };
        t.model.isChangedPath(e.changeMap, n) || (++e.changes, o("changeMap")), t.model.isChangedPath(e.deltaMap, n) || (++e.deltas, 
        o("deltaMap"));
    }, t.model.fetchChangeChildren = function(e, n, r, o, a) {
        t.each(o, function(o, i) {
            r[n] = i, t.model.applyChangeStrategy(e, i, n, r, o, a), r.length = n;
        });
    }, t.model.isSameValue = function(e, t) {
        return "number" != typeof e || "number" != typeof t ? e === t : e === t || e !== e && t !== t || Math.abs((e - t) / t) < 1e-12;
    }, t.model.applyChangeStrategy = function(e, n, r, o, a, i) {
        var u = e[n], s = t.typeCode(a), l = t.typeCode(u), c = t.NO_VALUE;
        "primitive" === s ? t.model.isSameValue(u, a) || (c = a, ++i.unchanged) : (l !== s || "array" === s && a.length !== u.length) && (c = t.freshContainer(a)), 
        c !== t.NO_VALUE && (e[n] = c, i.changeMap && t.model.setChangedPath(i, o, i.inverse ? "DELETE" : "ADD")), 
        "primitive" !== s && t.model.fetchChangeChildren(e[n], r + 1, o, a, i);
    }, t.model.stepTargetAccess = function(e, n, r, o, a, i) {
        for (var u = o; u < a; ++u) e && e[r[u]] !== (e = t.model.traverseWithStrategy(e, r, u, i["ADD" === n ? "resolverSetConfig" : "resolverGetConfig"], r.length - u - 1)) && i.changeMap && t.model.setChangedPath(i, r.slice(0, u + 1), "ADD");
        return {
            root: e,
            last: r[a]
        };
    }, t.model.defaultAccessorConfig = function(e) {
        return e = e || {}, e.resolverSetConfig = e.resolverSetConfig || t.model.escapedSetConfig, 
        e.resolverGetConfig = e.resolverGetConfig || t.model.escapedGetConfig, e;
    }, t.model.applyHolderChangeRequest = function(e, n, r) {
        (r = t.model.defaultAccessorConfig(r)).deltaMap = r.changeMap ? {} : null, r.deltas = 0;
        var o, a = n.segs.length, i = 0 === a;
        if (i ? o = {
            root: e,
            last: "model"
        } : (e.model || (e.model = {}, t.model.setChangedPath(r, [], r.inverse ? "DELETE" : "ADD")), 
        o = t.model.stepTargetAccess(e.model, n.type, n.segs, 0, a - 1, r)), "ADD" === n.type) {
            var u = n.value, s = t.makeArray(n.segs);
            t.model.applyChangeStrategy(o.root, o.last, a - 1, s, u, r, i);
        } else "DELETE" === n.type ? o.root && void 0 !== o.root[o.last] && (delete o.root[o.last], 
        r.changeMap && t.model.setChangedPath(r, n.segs, "DELETE")) : t.fail("Unrecognised change type of " + n.type);
        return r.deltas ? r.deltaMap : null;
    }, t.model.diff = function(e, n, r) {
        r = r || {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        var o, a = t.typeCode(e), i = t.typeCode(n);
        if ("primitive" === a && "primitive" === i) o = t.model.isSameValue(e, n); else if ("primitive" === a ^ "primitive" === i) o = !1; else {
            var u = {
                model: t.copy(e)
            };
            t.model.applyHolderChangeRequest(u, {
                value: n,
                segs: [],
                type: "ADD"
            }, r);
            var s = {
                model: t.copy(n)
            };
            r.inverse = !0, t.model.applyHolderChangeRequest(s, {
                value: e,
                segs: [],
                type: "ADD"
            }, r), o = 0 === r.changes;
        }
        return !1 === o && 0 === r.changes ? (r.changes = 1, r.changeMap = void 0 === n ? "DELETE" : "ADD") : !0 === o && 0 === r.unchanged && (r.unchanged = 1), 
        o;
    }, t.outputMatches = function(e, n, r) {
        t.each(r, function(t, r) {
            e.push(n.concat(r));
        });
    }, t.matchChanges = function(e, n, r, o) {
        for (var a = r.model, i = o.model, u = e, s = [ "model" ], l = !1, c = [], f = 0; f < n.length; ++f) {
            var d = n[f];
            "*" === d ? f === n.length - 1 ? l = !0 : t.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + n.join(".")) : (s.push(d), 
            u = t.isPrimitive(u) ? u : u[d], a = a ? a[d] : void 0, i = i ? i[d] : void 0);
        }
        return u && (l ? "DELETE" === u ? t.outputMatches(c, s, i) : "ADD" === u ? t.outputMatches(c, s, a) : t.outputMatches(c, s, u) : c.push(s)), 
        c;
    }, t.storeExternalChange = function(e, t, n, r, o) {
        var a = t.composeSegments.apply(null, n), i = [ t.holder.id, r.listenerId, r.wildcard ? a : "" ].join("|");
        e.externalChanges[i] = {
            listener: r.listener,
            namespace: r.namespace,
            priority: r.priority,
            args: o
        };
    }, t.notifyModelChanges = function(e, n, r, o, a, i, u, s) {
        if (e) for (var l = i && t.getModelTransactionRec(s, i.id), c = 0; c < e.length; ++c) for (var f = e[c], d = f.segsArray.length > 1, p = 0; p < f.segsArray.length; ++p) for (var m = t.matchChanges(n, f.segsArray[p], r, o), g = 0; g < m.length; ++g) {
            if (u.destroyed) return;
            var h = m[g];
            f.listener = t.event.resolveListener(f.listener);
            var v = [ d ? r.model : t.model.getSimple(r, h), d ? o.model : t.model.getSimple(o, h), d ? [] : h.slice(1), a, i, u ];
            if (!f.isRelay) {
                if (t.model.diff(v[0], v[1])) continue;
                if (t.isExcludedChangeSource(i, f)) continue;
            }
            l && !f.isRelay && f.transactional ? t.storeExternalChange(l, u, h, f, v) : f.listener.apply(null, v);
        }
    }, t.bindELMethods = function(e) {
        e.parseEL = function(n) {
            return t.model.pathToSegments(n, e.options.resolverSetConfig);
        }, e.composeSegments = function() {
            return e.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    }, t.initModelEvent = function(e, n, r, o) {
        t.notifyModelChanges(o, "ADD", r.oldHolder, t.emptyHolder, null, r, n, e);
    }, t.emptyHolder = t.freezeRecursive({
        model: void 0
    }), t.preFireChangeRequest = function(e, t) {
        t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
    }, t.bindRequestChange = function(e) {
        e.change = function(t, n, r, o) {
            var a = {
                path: t,
                value: n,
                type: r,
                source: o
            };
            e.fireChangeRequest(a);
        };
    }, t.isObjectSimple = function(e) {
        return "[object Object]" === Object.prototype.toString.call(e);
    }, t.mergeChangeSources = function(e, n) {
        t.isObjectSimple(n) ? t.extend(e, n) : t.each(t.makeArray(n), function(t) {
            e[t] = !0;
        });
    }, t.ChangeApplier = function() {}, t.makeHolderChangeApplier = function(n, r) {
        r = t.model.defaultAccessorConfig(r);
        var o = t.allocateGuid(), a = new t.ChangeApplier(), i = t.isComponent(n) ? "ChangeApplier for component " + t.dumpThat(n) : "ChangeApplier with id " + o;
        return e.extend(a, {
            applierId: o,
            holder: n,
            listeners: t.makeEventFirer({
                name: "Internal change listeners for " + i
            }),
            transListeners: t.makeEventFirer({
                name: "External change listeners for " + i
            }),
            options: r,
            modelChanged: {},
            preCommit: t.makeEventFirer({
                name: "preCommit event for " + i
            }),
            postCommit: t.makeEventFirer({
                name: "postCommit event for " + i
            })
        }), a.destroy = function() {
            a.preCommit.destroy(), a.postCommit.destroy(), a.destroyed = !0;
        }, a.modelChanged.addListener = function(e, n, r, o) {
            return (e = "string" == typeof e ? {
                path: e
            } : t.copy(e)).listenerId = e.listenerId || t.allocateGuid(), e.namespace = r, e.softNamespace = o, 
            "string" == typeof n && (n = {
                globalName: n
            }), e.listener = n, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || a.parseEL(e.path)), 
            e.segsArray || (e.segsArray = [ e.segs ])), t.parseSourceExclusionSpec(e, e), e.wildcard = t.accumulate(t.transform(e.segsArray, function(e) {
                return t.contains(e, "*");
            }), t.add, 0), e.wildcard && e.segsArray.length > 1 && t.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched"), 
            a[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
        }, a.modelChanged.removeListener = function(e) {
            a.listeners.removeListener(e), a.transListeners.removeListener(e);
        }, a.fireChangeRequest = function(e) {
            var t = a.initiate("local", e.source);
            t.fireChangeRequest(e), t.commit();
        }, a.initiate = function(e, o, i) {
            var u = "relay" === (e = "init" === o ? null : e || "local"), s = {
                instanceId: t.allocateGuid(),
                id: i || t.allocateGuid(),
                changeRecord: {
                    resolverSetConfig: r.resolverSetConfig,
                    resolverGetConfig: r.resolverGetConfig
                },
                reset: function() {
                    s.oldHolder = n, s.newHolder = {
                        model: t.copy(n.model)
                    }, s.changeRecord.changes = 0, s.changeRecord.unchanged = 0, s.changeRecord.changeMap = {};
                },
                commit: function(e) {
                    if (a.preCommit.fire(s, a, e), s.changeRecord.changes > 0) {
                        var r = {
                            model: n.model
                        };
                        n.model = s.newHolder.model, t.notifyModelChanges(a.transListeners.sortedListeners, s.changeRecord.changeMap, n, r, null, s, a, n);
                    }
                    u || a.postCommit.fire(s, a, e);
                },
                fireChangeRequest: function(e) {
                    t.preFireChangeRequest(a, e), e.transactionId = s.id;
                    var r = t.model.applyHolderChangeRequest(s.newHolder, e, s.changeRecord);
                    t.notifyModelChanges(a.listeners.sortedListeners, r, s.newHolder, n, e, s, a, n);
                },
                hasChangeSource: function(e) {
                    return s.fullSources[e];
                }
            }, l = t.getModelTransactionRec(n, s.id);
            return l && (t.mergeChangeSources(l.sources, o), s.sources = l.sources, s.fullSources = Object.create(l.sources), 
            s.fullSources[e] = !0), s.reset(), t.bindRequestChange(s), s;
        }, t.bindRequestChange(a), t.bindELMethods(a), a;
    }, t.modelPairToChanges = function(e, n, r) {
        r = r || "";
        var o = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        t.model.diff(n, e, o);
        var a = [];
        return t.modelPairToChangesImpl(e, t.pathUtil.parseEL(r), o.changeMap, [], a), a;
    }, t.modelPairToChangesImpl = function(e, n, r, o, a) {
        "ADD" === r ? a.push({
            path: n,
            value: e,
            type: "ADD"
        }) : "DELETE" === r ? a.push({
            path: n,
            value: null,
            type: "DELETE"
        }) : t.isPlainObject(r, !0) && t.each(r, function(r, i) {
            var u = o.concat([ i ]);
            "ADD" === r ? a.push({
                path: n.concat(u),
                value: t.get(e, u),
                type: "ADD"
            }) : "DELETE" === r ? a.push({
                path: n.concat(u),
                value: null,
                type: "DELETE"
            }) : t.isPlainObject(r, !0) && t.modelPairToChangesImpl(e, n, r, u, a);
        });
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(e, t) {
    "use strict";
    t.registerNamespace("fluid.model.transform"), t.defaults("fluid.transformFunction", {
        gradeNames: "fluid.function"
    }), t.defaults("fluid.standardInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), t.defaults("fluid.standardOutputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), t.defaults("fluid.multiInputTransformFunction", {
        gradeNames: "fluid.transformFunction"
    }), t.defaults("fluid.standardTransformFunction", {
        gradeNames: [ "fluid.standardInputTransformFunction", "fluid.standardOutputTransformFunction" ]
    }), t.defaults("fluid.lens", {
        gradeNames: "fluid.transformFunction",
        invertConfiguration: null
    }), t.model.transform.pathToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.value",
                inputPath: e
            }
        };
    }, t.model.transform.literalValueToRule = function(e) {
        return {
            transform: {
                type: "fluid.transforms.literalValue",
                input: e
            }
        };
    }, t.model.composePaths = function(e, t) {
        return e = 0 === e ? "0" : e || "", t = 0 === t ? "0" : t || "", e ? t ? e + "." + t : e : t;
    }, t.model.transform.accumulateInputPath = function(e, n, r) {
        void 0 !== e && r.push(t.model.composePaths(n.inputPrefix, e));
    }, t.model.transform.accumulateStandardInputPath = function(e, n, r, o) {
        t.model.transform.getValue(void 0, n[e], r), t.model.transform.accumulateInputPath(n[e + "Path"], r, o);
    }, t.model.transform.accumulateMultiInputPaths = function(e, n, r, o) {
        t.each(e, function(e, a) {
            t.model.transform.accumulateStandardInputPath(a, n, r, o);
        });
    }, t.model.transform.getValue = function(e, n, r) {
        var o;
        return void 0 !== e && (o = t.get(r.source, t.model.composePaths(r.inputPrefix, e), r.resolverGetConfig)), 
        void 0 === o && (o = t.isPrimitive(n) ? n : "literalValue" in n ? n.literalValue : void 0 === n.transform ? n : r.expand(n)), 
        o;
    }, t.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN = {}, t.model.transform.setValue = function(e, n, r) {
        var o = t.copy(n), a = t.model.composePaths(r.outputPrefix, e);
        return void 0 !== o && r.applier.change(a, o), e ? t.model.transform.NONDEFAULT_OUTPUT_PATH_RETURN : o;
    }, t.model.transform.resolveParam = function(e, n, r, o) {
        var a = t.model.transform.getValue(e[r + "Path"], e[r], n);
        return void 0 !== a ? a : o;
    }, t.model.transform.matchValue = function(e, n, r) {
        var o = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        return t.model.diff(e, n, o), 0 === o.unchanged ? 0 : r ? 0xffffff000000 - 16777216 * o.changes + o.unchanged : o.changes ? 0 : 0xffffff000000 + o.unchanged;
    }, t.model.transform.invertPaths = function(e, n) {
        var r = t.model.composePaths(n.outputPrefix, e.outputPath);
        return e.outputPath = t.model.composePaths(n.inputPrefix, e.inputPath), e.inputPath = r, 
        e;
    }, t.model.transform.prefixApplier = function(e, t) {
        e.inputPrefix && t.inputPrefixOp.push(e.inputPrefix), e.outputPrefix && t.outputPrefixOp.push(e.outputPrefix), 
        t.expand(e.input), e.inputPrefix && t.inputPrefixOp.pop(), e.outputPrefix && t.outputPrefixOp.pop();
    }, t.defaults("fluid.model.transform.prefixApplier", {
        gradeNames: [ "fluid.transformFunction" ]
    }), t.model.makePathStack = function(e, n) {
        var r = e[n + "Stack"] = [];
        return e[n] = "", {
            push: function(o) {
                var a = t.model.composePaths(e[n], o);
                r.push(e[n]), e[n] = a;
            },
            pop: function() {
                e[n] = r.pop();
            }
        };
    }, t.model.transform.doTransform = function(e, n, r) {
        var o = r.defaults, a = t.getGlobalValue(r.typeName);
        "function" != typeof a && t.fail("Transformation record specifies transformation function with name " + e.type + " which is not a function - ", a), 
        t.hasGrade(o, "fluid.transformFunction") || (o = t.defaults("fluid.standardTransformFunction"));
        var i = [ e, n ];
        if (t.hasGrade(o, "fluid.multiInputTransformFunction")) {
            var u = {};
            t.each(o.inputVariables, function(r, o) {
                u[o] = function() {
                    var a = t.model.transform.getValue(e[o + "Path"], e[o], n);
                    return a = void 0 === a && null !== r ? r : a;
                };
            }), i.unshift(u);
        }
        if (t.hasGrade(o, "fluid.standardInputTransformFunction")) {
            "input" in e || "inputPath" in e || t.fail('Error in transform specification. Either "input" or "inputPath" must be specified for a standardInputTransformFunction: received ', e);
            var s = t.model.transform.getValue(e.inputPath, e.input, n);
            if (i.unshift(s), void 0 === s) return;
        }
        var l = a.apply(null, i);
        return t.hasGrade(o, "fluid.standardOutputTransformFunction") && void 0 !== (void 0 !== e.outputPath ? e.outputPath : r.doOutput ? "" : void 0) && void 0 !== l && (t.model.transform.setValue(e.outputPath, l, n), 
        l = void 0), l;
    };
    var n = [];
    t.registerNamespace("fluid.pathUtil"), t.pathUtil.getPathSegment = function(e, r) {
        return t.pathUtil.getPathSegmentImpl(n, e, r), n[0];
    }, t.pathUtil.getHeadPath = function(e) {
        return t.pathUtil.getPathSegment(e, 0);
    }, t.pathUtil.getFromHeadPath = function(e) {
        var n = t.pathUtil.getPathSegmentImpl(null, e, 0);
        return n === e.length ? "" : e.substring(n + 1);
    }, t.pathUtil.matchPath = function(e, n, r) {
        for (var o = []; ;) {
            if ("" === n ^ "" === e && r) return null;
            if (!e || !n) break;
            var a = t.pathUtil.getHeadPath(e), i = t.pathUtil.getHeadPath(n);
            if ("*" !== a && a !== i) return null;
            o.push(i), e = t.pathUtil.getFromHeadPath(e), n = t.pathUtil.getFromHeadPath(n);
        }
        return o;
    }, t.model.transform.expandWildcards = function(e, n) {
        t.each(n, function(n, r) {
            var o = e.queuedTransforms;
            e.pathOp.push(t.pathUtil.escapeSegment(r.toString()));
            for (var a = 0; a < o.length; ++a) if (t.pathUtil.matchPath(o[a].matchPath, e.path, !0)) {
                var i = t.copy(o[a].transformSpec);
                (void 0 === i.inputPath || t.model.transform.hasWildcard(i.inputPath)) && (i.inputPath = ""), 
                e.inputPrefixOp.push(e.path), e.outputPrefixOp.push(e.path);
                var u = t.model.transform.lookupType(i.type), s = t.model.transform.doTransform(i, e, u);
                void 0 !== s && t.model.transform.setValue(null, s, e), e.outputPrefixOp.pop(), 
                e.inputPrefixOp.pop();
            }
            t.isPrimitive(n) || t.model.transform.expandWildcards(e, n), e.pathOp.pop();
        });
    }, t.model.transform.hasWildcard = function(e) {
        return "string" == typeof e && -1 !== e.indexOf("*");
    }, t.model.transform.maybePushWildcard = function(e, n) {
        var r, o = t.model.transform.hasWildcard;
        return o(e.inputPath) ? r = t.model.composePaths(n.inputPrefix, e.inputPath) : (o(n.outputPrefix) || o(e.outputPath)) && (r = t.model.composePaths(n.outputPrefix, e.outputPath)), 
        !!r && (n.queuedTransforms.push({
            transformSpec: e,
            outputPrefix: n.outputPrefix,
            inputPrefix: n.inputPrefix,
            matchPath: r
        }), !0);
    }, t.model.sortByKeyLength = function(e) {
        return t.keys(e).sort(t.compareStringLength(!0));
    }, t.model.transform.handleTransformStrategy = function(e, n, r) {
        return t.model.transform.maybePushWildcard(e, n) ? void 0 : t.model.transform.doTransform(e, n, r);
    }, t.model.transform.handleInvertStrategy = function(e, n, r) {
        e = t.copy(e), t.hasGrade(r.defaults, "fluid.standardTransformFunction") && (e = t.model.transform.invertPaths(e, n));
        var o = r.defaults && r.defaults.invertConfiguration;
        if (o) {
            var a = t.invokeGlobalFunction(o, [ e, n ]);
            n.inverted.push(a);
        } else n.inverted.push(t.model.transform.uninvertibleTransform);
    }, t.model.transform.handleCollectStrategy = function(e, n, r) {
        var o = r.defaults, a = t.hasGrade(o, "fluid.standardInputTransformFunction"), i = t.hasGrade(o, "fluid.multiInputTransformFunction");
        if (a && t.model.transform.accumulateStandardInputPath("input", e, n, n.inputPaths), 
        i && t.model.transform.accumulateMultiInputPaths(o.inputVariables, e, n, n.inputPaths), 
        !i && !a) {
            var u = o.collectInputPaths;
            if (u) {
                var s = t.makeArray(t.invokeGlobalFunction(u, [ e, n ]));
                Array.prototype.push.apply(n.inputPaths, s);
            }
        }
    }, t.model.transform.lookupType = function(e, n) {
        return e || t.fail("Transformation record is missing a type name: ", n), -1 === e.indexOf(".") && (e = "fluid.transforms." + e), 
        {
            defaults: t.defaults(e),
            typeName: e
        };
    }, t.model.transform.processRule = function(e, n) {
        "string" == typeof e ? e = t.model.transform.pathToRule(e) : void 0 !== e.literalValue && (e = t.model.transform.literalValueToRule(e.literalValue));
        var r;
        if (e.transform) {
            var o, a;
            if (t.isArrayable(e.transform)) {
                var i = e.transform;
                r = void 0;
                for (var u = 0; u < i.length; ++u) o = i[u], a = t.model.transform.lookupType(o.type), 
                n.transformHandler(o, n, a);
            } else o = e.transform, a = t.model.transform.lookupType(o.type), r = n.transformHandler(o, n, a);
        }
        return t.isArrayable(e) && (n.collectedFlatSchemaOpts = n.collectedFlatSchemaOpts || {}, 
        n.collectedFlatSchemaOpts[n.outputPrefix] = "array"), t.each(e, function(e, r) {
            if ("transform" !== r) {
                n.outputPrefixOp.push(r);
                var o = n.expand(e, n);
                void 0 !== o && (t.model.transform.setValue(null, o, n), o = void 0), n.outputPrefixOp.pop();
            }
        }), r;
    }, t.model.transform.makeStrategy = function(e, n, r) {
        r = r || t.model.transform.processRule, e.expand = function(t) {
            return r(t, e);
        }, e.outputPrefixOp = t.model.makePathStack(e, "outputPrefix"), e.inputPrefixOp = t.model.makePathStack(e, "inputPrefix"), 
        e.transformHandler = n;
    }, t.model.transform.uninvertibleTransform = Object.freeze({}), t.model.transform.invertConfiguration = function(e) {
        var n = {
            inverted: []
        };
        return t.model.transform.makeStrategy(n, t.model.transform.handleInvertStrategy), 
        n.expand(e), -1 === n.inverted.indexOf(t.model.transform.uninvertibleTransform) ? {
            transform: n.inverted
        } : t.model.transform.uninvertibleTransform;
    }, t.model.transform.collectInputPaths = function(e) {
        var n = {
            inputPaths: []
        };
        return t.model.transform.makeStrategy(n, t.model.transform.handleCollectStrategy), 
        n.expand(e), n.inputPaths;
    }, t.model.transform.flatSchemaStrategy = function(e, n) {
        var r = t.model.sortByKeyLength(e);
        return function(o, a, i, u) {
            for (var s = n.parser.compose.apply(null, u.slice(0, i)), l = 0; l < r.length; ++l) {
                var c = r[l];
                if (null !== t.pathUtil.matchPath(c, s, !0)) return e[c];
            }
        };
    }, t.model.transform.defaultSchemaValue = function(e) {
        return "array" === (t.isPrimitive(e) ? e : e.type) ? [] : {};
    }, t.model.transform.isomorphicSchemaStrategy = function(e, n) {
        return function(r, o, a, i) {
            var u = t.get(e, i.slice(0, a), n);
            return t.isArrayable(u) ? "array" : "object";
        };
    }, t.model.transform.decodeStrategy = function(e, n, r) {
        return n.isomorphic ? t.model.transform.isomorphicSchemaStrategy(e, r) : n.flatSchema ? t.model.transform.flatSchemaStrategy(n.flatSchema, r) : void 0;
    }, t.model.transform.schemaToCreatorStrategy = function(e) {
        return function(n, r, o, a) {
            if (void 0 === n[r]) {
                var i = e(n, r, o, a);
                return n[r] = t.model.transform.defaultSchemaValue(i), n[r];
            }
        };
    }, t.model.transform.sequence = function(e, n, r) {
        for (var o = 0; o < n.length; ++o) e = t.model.transform(e, n[o], r);
        return e;
    }, t.model.compareByPathLength = function(e, t) {
        var n = e.path.length - t.path.length;
        return 0 === n ? e.sequence - t.sequence : n;
    }, t.model.fireSortedChanges = function(e, n) {
        e.sort(t.model.compareByPathLength), t.fireChanges(n, e);
    }, t.model.transformWithRules = function(n, r, o) {
        o = o || {};
        var a = t.model.escapedGetConfig, i = t.model.escapedSetConfig, u = t.model.transform.decodeStrategy(n, o, a), s = {
            source: n,
            target: {
                model: u ? t.model.transform.defaultSchemaValue(u(null, "", 0, [ "" ])) : {}
            },
            resolverGetConfig: a,
            resolverSetConfig: i,
            collectedFlatSchemaOpts: void 0,
            queuedChanges: [],
            queuedTransforms: []
        };
        t.model.transform.makeStrategy(s, t.model.transform.handleTransformStrategy), s.applier = {
            fireChangeRequest: function(e) {
                e.sequence = s.queuedChanges.length, s.queuedChanges.push(e);
            }
        }, t.bindRequestChange(s.applier), s.expand(r);
        var l = t.copy(i);
        return void 0 !== s.collectedFlatSchemaOpts && (e.extend(s.collectedFlatSchemaOpts, o.flatSchema), 
        u = t.model.transform.flatSchemaStrategy(s.collectedFlatSchemaOpts, a)), l.strategies = [ t.model.defaultFetchStrategy, u ? t.model.transform.schemaToCreatorStrategy(u) : t.model.defaultCreatorStrategy ], 
        s.finalApplier = o.finalApplier || t.makeHolderChangeApplier(s.target, {
            resolverSetConfig: l
        }), s.queuedTransforms.length > 0 && (s.typeStack = [], s.pathOp = t.model.makePathStack(s, "path"), 
        t.model.transform.expandWildcards(s, n)), t.model.fireSortedChanges(s.queuedChanges, s.finalApplier), 
        s.target.model;
    }, e.extend(t.model.transformWithRules, t.model.transform), t.model.transform = t.model.transformWithRules, 
    t.transformOne = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transformWithRules",
                config: e
            }
        };
    }, t.transformMany = function(e) {
        return {
            transformOptions: {
                transformer: "fluid.model.transform.sequence",
                config: e
            }
        };
    };
}(jQuery, fluid_3_0_0);

var fluid_2_0_0 = fluid_2_0_0 || {}, fluid = fluid || fluid_2_0_0;

!function(e, t) {
    "use strict";
    t.registerNamespace("fluid.model.transform"), t.registerNamespace("fluid.transforms"), 
    t.defaults("fluid.transforms.value", {
        gradeNames: "fluid.standardTransformFunction",
        invertConfiguration: "fluid.identity"
    }), t.transforms.value = t.identity, t.transforms.identity = t.transforms.value, 
    t.defaults("fluid.transforms.identity", {
        gradeNames: "fluid.transforms.value"
    }), t.transforms.invertToIdentity = function(e) {
        return e.type = "fluid.transforms.identity", e;
    }, t.defaults("fluid.transforms.literalValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), t.transforms.literalValue = function(e) {
        return e.input;
    }, t.defaults("fluid.transforms.stringToNumber", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToNumber.invert"
    }), t.transforms.stringToNumber = function(e) {
        var t = Number(e);
        return isNaN(t) ? void 0 : t;
    }, t.transforms.stringToNumber.invert = function(e) {
        return e.type = "fluid.transforms.numberToString", e;
    }, t.defaults("fluid.transforms.numberToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.numberToString.invert"
    }), t.transforms.numberToString = function(e, n) {
        if ("number" == typeof e) return "number" != typeof n.scale || isNaN(n.scale) ? e.toString() : t.roundToDecimal(e, n.scale, n.method).toString();
    }, t.transforms.numberToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToNumber", e;
    }, t.defaults("fluid.transforms.count", {
        gradeNames: "fluid.standardTransformFunction"
    }), t.transforms.count = function(e) {
        return t.makeArray(e).length;
    }, t.defaults("fluid.transforms.round", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), t.transforms.round = function(e, n) {
        return t.roundToDecimal(e, n.scale, n.method);
    }, t.defaults("fluid.transforms.delete", {
        gradeNames: "fluid.transformFunction"
    }), t.transforms.delete = function(e, n) {
        var r = t.model.composePaths(n.outputPrefix, e.outputPath);
        n.applier.change(r, null, "DELETE");
    }, t.defaults("fluid.transforms.firstValue", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), t.transforms.firstValue = function(e, n) {
        e.values && e.values.length || t.fail('firstValue transformer requires an array of values at path named "values", supplied', e);
        for (var r = 0; r < e.values.length; r++) {
            var o = e.values[r], a = n.expand(o);
            if (void 0 !== a) return a;
        }
    }, t.defaults("fluid.transforms.linearScale", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.linearScale.invert",
        inputVariables: {
            factor: 1,
            offset: 0
        }
    }), t.transforms.linearScale = function(e, t) {
        var n = t.factor(), r = t.offset();
        if ("number" == typeof e && "number" == typeof n && "number" == typeof r) return e * n + r;
    }, t.transforms.linearScale.invert = function(e) {
        return delete e.factorPath, delete e.offsetPath, void 0 !== e.factor && (e.factor = 0 === e.factor ? 0 : 1 / e.factor), 
        void 0 !== e.offset && (e.offset = -e.offset * (void 0 !== e.factor ? e.factor : 1)), 
        e;
    }, t.defaults("fluid.transforms.binaryOp", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            left: null,
            right: null
        }
    }), t.transforms.binaryLookup = {
        "===": function(e, n) {
            return t.model.isSameValue(e, n);
        },
        "!==": function(e, n) {
            return !t.model.isSameValue(e, n);
        },
        "<=": function(e, t) {
            return e <= t;
        },
        "<": function(e, t) {
            return e < t;
        },
        ">=": function(e, t) {
            return e >= t;
        },
        ">": function(e, t) {
            return e > t;
        },
        "+": function(e, t) {
            return e + t;
        },
        "-": function(e, t) {
            return e - t;
        },
        "*": function(e, t) {
            return e * t;
        },
        "/": function(e, t) {
            return e / t;
        },
        "%": function(e, t) {
            return e % t;
        },
        "&&": function(e, t) {
            return e && t;
        },
        "||": function(e, t) {
            return e || t;
        }
    }, t.transforms.binaryOp = function(e, n, r) {
        var o = e.left(), a = e.right(), i = t.model.transform.getValue(void 0, n.operator, r), u = t.transforms.binaryLookup[i];
        return void 0 === u || void 0 === o || void 0 === a ? void 0 : u(o, a);
    }, t.defaults("fluid.transforms.condition", {
        gradeNames: [ "fluid.multiInputTransformFunction", "fluid.standardOutputTransformFunction" ],
        inputVariables: {
            true: null,
            false: null,
            condition: null
        }
    }), t.transforms.condition = function(e) {
        var t = e.condition();
        if (null !== t) return e[t ? "true" : "false"]();
    }, t.defaults("fluid.transforms.valueMapper", {
        gradeNames: [ "fluid.transformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.valueMapper.invert",
        collectInputPaths: "fluid.transforms.valueMapper.collect"
    }), t.model.transform.compareMatches = function(e, t) {
        var n = t.matchValue - e.matchValue;
        return 0 === n ? e.index - t.index : n;
    }, t.transforms.valueMapper = function(e, n) {
        e.match || t.fail('valueMapper requires an array or hash of matches at path named "match", supplied ', e);
        var r = t.model.transform.getValue(e.defaultInputPath, e.defaultInput, n), o = t.isArrayable(e.match) ? t.transforms.valueMapper.longFormMatch(r, e, n) : e.match[r];
        if (void 0 === o && (o = e.noMatch), void 0 !== o) {
            var a = void 0 === o.outputPath ? e.defaultOutputPath : o.outputPath;
            n.outputPrefixOp.push(a);
            var i;
            return i = t.isPrimitive(o) ? o : o.outputUndefinedValue ? void 0 : void 0 === (i = t.model.transform.resolveParam(o, n, "outputValue", void 0)) ? e.defaultOutputValue : i, 
            "string" == typeof a && void 0 !== i && (t.model.transform.setValue(void 0, i, n, e.merge), 
            i = void 0), n.outputPrefixOp.pop(), i;
        }
    }, t.transforms.valueMapper.longFormMatch = function(e, n, r) {
        var o = n.match;
        0 === o.length && t.fail("valueMapper supplied empty list of matches: ", n);
        for (var a = [], i = 0; i < o.length; ++i) {
            var u = o[i], s = u.inputPath ? t.model.transform.getValue(u.inputPath, void 0, r) : e, l = t.model.transform.matchValue(u.inputValue, s, u.partialMatches);
            a[i] = {
                index: i,
                matchValue: l
            };
        }
        return a.sort(t.model.transform.compareMatches), a[0].matchValue <= 0 ? void 0 : o[a[0].index];
    }, t.transforms.valueMapper.invert = function(e, n) {
        var r = [], o = {
            type: "fluid.transforms.valueMapper",
            match: r
        }, a = t.isArrayable(e.match);
        o.defaultInputPath = t.model.composePaths(n.outputPrefix, e.defaultOutputPath), 
        o.defaultOutputPath = t.model.composePaths(n.inputPrefix, e.defaultInputPath);
        var i = t.firstDefined;
        return t.each(e.match, function(o, u) {
            if (!0 !== o.outputUndefinedValue) {
                var s = {}, l = i(a ? o.inputValue : u, e.defaultInputValue);
                void 0 === l && t.fail("Failure inverting configuration for valueMapper - inputValue could not be resolved for record " + u + ": ", e), 
                s.outputValue = l, s.inputValue = !a && t.isPrimitive(o) ? o : i(o.outputValue, e.defaultOutputValue), 
                o.outputPath && (s.inputPath = t.model.composePaths(n.outputPrefix, i(o.outputPath, e.outputPath))), 
                o.inputPath && (s.outputPath = t.model.composePaths(n.inputPrefix, i(o.inputPath, e.inputPath))), 
                r.push(s);
            }
        }), o;
    }, t.transforms.valueMapper.collect = function(e, n) {
        var r = [];
        return t.model.transform.accumulateInputPath(e.defaultInputPath, n, r), t.each(e.match, function(e) {
            t.model.transform.accumulateInputPath(e.inputPath, n, r);
        }), r;
    }, t.defaults("fluid.transforms.arrayToSetMembership", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.arrayToSetMembership.invert"
    }), t.transforms.arrayToSetMembership = function(e, n, r) {
        var o = {}, a = n.options;
        return e && t.isArrayable(e) || t.fail("arrayToSetMembership didn't find array at inputPath nor passed as value.", n), 
        a || t.fail("arrayToSetMembership requires an options block set"), void 0 === n.presentValue && (n.presentValue = !0), 
        void 0 === n.missingValue && (n.missingValue = !1), t.each(a, function(a, i) {
            var u = -1 !== e.indexOf(i) ? n.presentValue : n.missingValue;
            t.set(o, a, u, r.resolverSetConfig);
        }), o;
    }, t.transforms.arrayToSetMembership.invertWithType = function(e, n, r) {
        e.type = r;
        var o = {};
        return t.each(e.options, function(e, t) {
            o[e] = t;
        }), e.options = o, e;
    }, t.transforms.arrayToSetMembership.invert = function(e, n) {
        return t.transforms.arrayToSetMembership.invertWithType(e, n, "fluid.transforms.setMembershipToArray");
    }, t.defaults("fluid.transforms.setMembershipToArray", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.setMembershipToArray.invert"
    }), t.transforms.setMembershipToArray = function(e, n, r) {
        var o = n.options;
        o || t.fail("setMembershipToArray requires an options block specified"), void 0 === n.presentValue && (n.presentValue = !0), 
        void 0 === n.missingValue && (n.missingValue = !1);
        var a = [];
        return t.each(o, function(o, i) {
            t.get(e, i, r.resolverGetConfig) === n.presentValue && a.push(o);
        }), a;
    }, t.transforms.setMembershipToArray.invert = function(e, n) {
        return t.transforms.arrayToSetMembership.invertWithType(e, n, "fluid.transforms.arrayToSetMembership");
    }, t.model.transform.applyPaths = function(e, t, n) {
        for (var r = 0; r < n.length; ++r) "push" === e ? t.push(n[r]) : t.pop();
    }, t.model.transform.expandInnerValues = function(n, r, o, a) {
        var i = o.inputPrefixOp, u = o.outputPrefixOp, s = t.model.transform.applyPaths;
        s("push", i, n), s("push", u, r);
        var l = {};
        return t.each(a, function(n) {
            var r = o.expand(n);
            t.isPrimitive(r) ? l = r : e.extend(!0, l, r);
        }), s("pop", u, r), s("pop", i, n), l;
    }, t.defaults("fluid.transforms.indexArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexArrayByKey.invert"
    }), t.transforms.indexArrayByKey = function(e, n, r) {
        void 0 === n.key && t.fail("indexArrayByKey requires a 'key' option.", n), t.isArrayable(e) || t.fail("indexArrayByKey didn't find array at inputPath.", n);
        var o = {}, a = n.key;
        return t.each(e, function(e, i) {
            var u = e[a], s = typeof u;
            "string" !== s && "boolean" !== s && "number" !== s && t.fail("indexArrayByKey encountered untransformable array due to missing or invalid key", e);
            var l = t.copy(e);
            delete l[a], n.innerValue && (l = t.model.transform.expandInnerValues([ r.inputPrefix, n.inputPath, i.toString() ], [ n.outputPath, u ], r, n.innerValue)), 
            o[u] = l;
        }), o;
    }, t.transforms.indexArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.deindexIntoArrayByKey", e.innerValue) for (var n = e.innerValue, r = 0; r < n.length; ++r) {
            var o = t.model.transform.invertConfiguration(n[r]);
            if (o === t.model.transform.uninvertibleTransform) return o;
            n[r] = o;
        }
        return e;
    }, t.defaults("fluid.transforms.deindexIntoArrayByKey", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.deindexIntoArrayByKey.invert"
    }), t.transforms.deindexIntoArrayByKey = function(n, r, o) {
        void 0 === r.key && t.fail('deindexIntoArrayByKey requires a "key" option.', r);
        var a = [], i = r.key;
        return t.each(n, function(n, u) {
            var s = {};
            s[i] = u, r.innerValue && (n = t.model.transform.expandInnerValues([ r.inputPath, u ], [ r.outputPath, a.length.toString() ], o, r.innerValue)), 
            e.extend(!0, s, n), a.push(s);
        }), a;
    }, t.transforms.deindexIntoArrayByKey.invert = function(e) {
        if (e.type = "fluid.transforms.indexArrayByKey", e.innerValue) for (var n = e.innerValue, r = 0; r < n.length; ++r) n[r] = t.model.transform.invertConfiguration(n[r]);
        return e;
    }, t.defaults("fluid.transforms.limitRange", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.invertToIdentity"
    }), t.transforms.limitRange = function(e, t) {
        var n = t.min;
        void 0 !== n && e < (n += t.excludeMin || 0) && (e = n);
        var r = t.max;
        return void 0 !== r && e > (r -= t.excludeMax || 0) && (e = r), e;
    }, t.defaults("fluid.transforms.indexOf", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.indexOf.invert"
    }), t.transforms.indexOf = function(e, n) {
        "number" == typeof n.notFound && n.notFound >= 0 && t.fail("A positive number is not allowed as 'notFound' value for indexOf");
        var r = t.transforms.parseIndexationOffset(n.offset, "indexOf"), o = t.makeArray(n.array).indexOf(e);
        return -1 === o && n.notFound ? n.notFound : o + r;
    }, t.transforms.indexOf.invert = function(e, n) {
        var r = t.transforms.invertArrayIndexation(e, n);
        return r.type = "fluid.transforms.dereference", r;
    }, t.defaults("fluid.transforms.dereference", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dereference.invert"
    }), t.transforms.dereference = function(e, n) {
        if ("number" == typeof e) {
            var r = t.transforms.parseIndexationOffset(n.offset, "dereference");
            return t.makeArray(n.array)[e + r];
        }
    }, t.transforms.dereference.invert = function(e, n) {
        var r = t.transforms.invertArrayIndexation(e, n);
        return r.type = "fluid.transforms.indexOf", r;
    }, t.transforms.parseIndexationOffset = function(e, n) {
        var r = 0;
        return void 0 !== e && (r = t.parseInteger(e), isNaN(r) && t.fail(n + ' requires the value of "offset" to be an integer or a string that can be converted to an integer. ' + e + " is invalid.")), 
        r;
    }, t.transforms.invertArrayIndexation = function(e) {
        return isNaN(Number(e.offset)) || (e.offset = -1 * Number(e.offset)), e;
    }, t.defaults("fluid.transforms.stringTemplate", {
        gradeNames: "fluid.standardOutputTransformFunction"
    }), t.transforms.stringTemplate = function(e) {
        return t.stringTemplate(e.template, e.terms);
    }, t.defaults("fluid.transforms.free", {
        gradeNames: "fluid.transformFunction"
    }), t.transforms.free = function(e) {
        var n = t.makeArray(e.args);
        return t.invokeGlobalFunction(e.func, n);
    }, t.defaults("fluid.transforms.quantize", {
        gradeNames: "fluid.standardTransformFunction"
    }), t.transforms.quantize = function(e, n, r) {
        n.ranges && n.ranges.length || t.fail("fluid.transforms.quantize should have a key called ranges containing an array defining ranges to quantize");
        for (var o = 0; o < n.ranges.length; o++) {
            var a = n.ranges[o];
            if (e <= a.upperBound || void 0 === a.upperBound && e >= Number.NEGATIVE_INFINITY) return t.isPrimitive(a.output) ? a.output : r.expand(a.output);
        }
    }, t.defaults("fluid.transforms.inRange", {
        gradeNames: "fluid.standardTransformFunction"
    }), t.transforms.inRange = function(e, t) {
        return (void 0 === t.min || t.min <= e) && (void 0 === t.max || t.max >= e);
    }, t.transforms.stringToBoolean = function(e) {
        return !!e && !("0" === e || "false" === e);
    }, t.transforms.stringToBoolean.invert = function(e) {
        return e.type = "fluid.transforms.booleanToString", e;
    }, t.defaults("fluid.transforms.stringToBoolean", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToBoolean.invert"
    }), t.transforms.booleanToString = function(e) {
        return e ? "true" : "false";
    }, t.transforms.booleanToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToBoolean", e;
    }, t.defaults("fluid.transforms.booleanToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.booleanToString.invert"
    }), t.transforms.JSONstringToObject = function(e) {
        try {
            return JSON.parse(e);
        } catch (e) {
            return;
        }
    }, t.transforms.JSONstringToObject.invert = function(e) {
        return e.type = "fluid.transforms.objectToJSONString", e;
    }, t.defaults("fluid.transforms.JSONstringToObject", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.JSONstringToObject.invert"
    }), t.transforms.objectToJSONString = function(e, t) {
        var n = t.space || 0;
        return JSON.stringify(e, null, n);
    }, t.transforms.objectToJSONString.invert = function(e) {
        return e.type = "fluid.transforms.JSONstringToObject", e;
    }, t.defaults("fluid.transforms.objectToJSONString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.objectToJSONString.invert"
    }), t.transforms.stringToDate = function(e) {
        var t = new Date(e);
        return isNaN(t.getTime()) ? void 0 : t;
    }, t.transforms.stringToDate.invert = function(e) {
        return e.type = "fluid.transforms.dateToString", e;
    }, t.defaults("fluid.transforms.stringToDate", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.stringToDate.invert"
    }), t.transforms.dateToString = function(e) {
        if (e instanceof Date) {
            var t = e.toISOString();
            return t.substring(0, t.indexOf("T"));
        }
    }, t.transforms.dateToString.invert = function(e) {
        return e.type = "fluid.transforms.stringToDate", e;
    }, t.defaults("fluid.transforms.dateToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    }), t.transforms.dateTimeToString = function(e) {
        return e instanceof Date ? e.toISOString() : void 0;
    }, t.defaults("fluid.transforms.dateTimeToString", {
        gradeNames: [ "fluid.standardTransformFunction", "fluid.lens" ],
        invertConfiguration: "fluid.transforms.dateToString.invert"
    });
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    t.registerNamespace("fluid.contextAware"), t.defaults("fluid.contextAware.marker", {
        gradeNames: [ "fluid.component" ]
    }), t.contextAware.makeCheckMarkers = function(e, n, r) {
        t.each(e, function(e, o) {
            t.constructSingle(n, {
                type: o,
                gradeNames: "fluid.contextAware.marker",
                value: e
            }, r);
        });
    }, t.contextAware.performChecks = function(e) {
        return t.transform(e, function(e) {
            return "function" == typeof e ? e = {
                func: e
            } : "string" == typeof e && (e = {
                funcName: e
            }), t.isPrimitive(e) ? e : "value" in e ? e.value : "func" in e ? e.func() : "funcName" in e ? t.invokeGlobalFunction(e.funcName) : void t.fail("Error in contextAwareness check record ", e, " - must contain an entry with name value, func, or funcName");
        });
    }, t.contextAware.makeChecks = function(e, n, r) {
        var o = t.contextAware.performChecks(e);
        t.contextAware.makeCheckMarkers(o, n, r);
    }, t.contextAware.forgetChecks = function(e, n, r) {
        r = r || t.globalInstantiator, n = n || [];
        var o = t.makeArray(e);
        t.each(o, function(e) {
            var o = t.typeNameToMemberName(e), a = t.model.parseToSegments(n, r.parseEL, !0);
            a.push(o), t.destroy(a, r);
        });
    }, t.defaults("fluid.contextAware", {
        gradeNames: [ "{that}.check" ],
        mergePolicy: {
            contextAwareness: "noexpand"
        },
        contextAwareness: {},
        invokers: {
            check: {
                funcName: "fluid.contextAware.check",
                args: [ "{that}", "{that}.options.contextAwareness" ]
            }
        }
    }), t.contextAware.getCheckValue = function(e, n) {
        var r = t.parseContextReference(n), o = t.resolveContext(r.context, e), a = r.path || [ "options", "value" ];
        return t.getForComponent(o, a);
    }, t.contextAware.checkOne = function(e, n) {
        n.checks && n.checks.contextValue && t.fail("Nesting error in contextAwareness record ", n, ' - the "checks" entry must contain a hash and not a contextValue/gradeNames record at top level');
        var r = t.parsePriorityRecords(n.checks, "contextAwareness checkRecord");
        return t.find(r, function(n) {
            n.contextValue || t.fail("Cannot perform check for contextAwareness record ", n, ' without a valid field named "contextValue"');
            var r = t.contextAware.getCheckValue(e, n.contextValue);
            if (void 0 === n.equals ? r : r === n.equals) return n.gradeNames;
        }, n.defaultGradeNames);
    }, t.contextAware.check = function(e, n) {
        var r = [], o = t.parsePriorityRecords(n, "contextAwareness adaptationRecord");
        return t.each(o, function(n) {
            var o = t.contextAware.checkOne(e, n);
            r = r.concat(t.makeArray(o));
        }), r;
    }, t.contextAware.makeAdaptation = function(e) {
        t.expect("fluid.contextAware.makeAdaptation", e, [ "distributionName", "targetName", "adaptationName", "checkName", "record" ]), 
        t.defaults(e.distributionName, {
            gradeNames: [ "fluid.component" ],
            distributeOptions: {
                target: "{/ " + e.targetName + "}.options.contextAwareness." + e.adaptationName + ".checks." + e.checkName,
                record: e.record
            }
        }), t.constructSingle([], e.distributionName);
    }, t.contextAware.isBrowser = function() {
        return "undefined" != typeof window && window.document;
    }, t.contextAware.makeChecks({
        "fluid.browser": {
            funcName: "fluid.contextAware.isBrowser"
        }
    }), t.registerNamespace("fluid.contextAware.browser"), t.contextAware.browser.getPlatformName = function() {
        return "undefined" != typeof navigator && navigator.platform ? navigator.platform : void 0;
    }, t.contextAware.browser.getUserAgent = function() {
        return "undefined" != typeof navigator && navigator.userAgent ? navigator.userAgent : void 0;
    }, t.contextAware.makeChecks({
        "fluid.browser.platformName": {
            funcName: "fluid.contextAware.browser.getPlatformName"
        },
        "fluid.browser.userAgent": {
            funcName: "fluid.contextAware.browser.getUserAgent"
        }
    });
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    function n(t, n) {
        return (t = e(t)).trigger("fluid-" + n), t.triggerHandler(n), t[n](), t;
    }
    t.uaMatch = function(e) {
        e = e.toLowerCase();
        var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
        return {
            browser: t[1] || "",
            version: t[2] || "0"
        };
    };
    var r, o;
    e.browser || (navigator.userAgent.match(/Trident\/7\./) ? o = {
        msie: !0,
        version: 11
    } : (o = {}, (r = t.uaMatch(navigator.userAgent)).browser && (o[r.browser] = !0, 
    o.version = r.version), o.chrome ? o.webkit = !0 : o.webkit && (o.safari = !0)), 
    e.browser = o);
    t.getScopedData = function(t, n) {
        var r = e(t).data("fluid-scoped-data");
        return r ? r[n] : void 0;
    }, t.setScopedData = function(t, n, r) {
        e(t).each(function() {
            var t = e.data(this, "fluid-scoped-data") || {};
            t[n] = r, e.data(this, "fluid-scoped-data", t);
        });
    };
    var a = null;
    e(document).on("focusin", function(e) {
        a = e.target;
    }), t.getLastFocusedElement = function() {
        return a;
    };
    t.enabled = function(n, r) {
        if (n = e(n), void 0 === r) return !1 !== t.getScopedData(n, "enablement");
        e("*", n).add(n).each(function() {
            void 0 !== t.getScopedData(this, "enablement") ? t.setScopedData(this, "enablement", r) : /select|textarea|input/i.test(this.nodeName) && e(this).prop("disabled", !r);
        }), t.setScopedData(n, "enablement", r);
    }, t.initEnablement = function(e) {
        t.setScopedData(e, "enablement", !0);
    }, t.resolveEventTarget = function(e) {
        for (;e.originalEvent && e.originalEvent.target; ) e = e.originalEvent;
        return e.target;
    }, e.each([ "focus", "blur" ], function(e, r) {
        t[r] = function(e) {
            return n(e, r);
        };
    }), t.changeElementValue = function(t, n) {
        (t = e(t)).val(n).change();
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    t.dom = t.dom || {};
    var n = function(e) {
        if (e.node.firstChild) return e.node = e.node.firstChild, e.depth += 1, e;
        for (;e.node; ) {
            if (e.node.nextSibling) return e.node = e.node.nextSibling, e;
            e.node = e.node.parentNode, e.depth -= 1;
        }
        return e;
    };
    t.dom.iterateDom = function(e, r, o) {
        for (var a, i = {
            node: e,
            depth: 0
        }, u = e; null !== i.node && i.depth >= 0 && i.depth < t.dom.iterateDom.DOM_BAIL_DEPTH; ) {
            if (a = null, (1 === i.node.nodeType || o) && (a = r(i.node, i.depth)), a) if ("delete" === a) i.node.parentNode.removeChild(i.node), 
            i.node = u; else if ("stop" === a) return i.node;
            u = i.node, i = n(i);
        }
    }, t.dom.iterateDom.DOM_BAIL_DEPTH = 256, t.dom.isContainer = function(e, t) {
        for (;t; t = t.parentNode) if (e === t) return !0;
        return !1;
    }, t.dom.getElementText = function(e) {
        for (var t = e.childNodes, n = "", r = 0; r < t.length; ++r) {
            var o = t[r];
            3 === o.nodeType && (n += o.nodeValue);
        }
        return n;
    };
}(jQuery, fluid_3_0_0);

var fluid_3_0_0 = fluid_3_0_0 || {};

!function(e, t) {
    "use strict";
    t.defaults("fluid.viewComponent", {
        gradeNames: [ "fluid.modelComponent" ],
        initFunction: "fluid.initView",
        argumentMap: {
            container: 0,
            options: 1
        },
        members: {
            dom: "@expand:fluid.initDomBinder({that}, {that}.options.selectors)"
        }
    }), t.dumpSelector = function(e) {
        return "string" == typeof e ? e : e.selector ? e.selector : "";
    }, t.diagnoseFailedView = function(e, n, r, o) {
        if (!n && t.hasGrade(r, "fluid.viewComponent")) {
            var a = t.wrap(o[1]), i = "Instantiation of view component with type " + e + " failed, since ";
            a ? 0 === a.length ? t.fail(i + 'selector "', t.dumpSelector(o[1]), '" did not match any markup in the document') : t.fail(i + " component creator function did not return a value") : t.fail(i + " container argument is empty");
        }
    }, t.checkTryCatchParameter = function() {
        var e = (window.location || {
            search: "",
            protocol: "file:"
        }).search.slice(1).split("&");
        return !0 === t.find(e, function(e) {
            if (0 === e.indexOf("notrycatch")) return !0;
        });
    }, t.notrycatch = t.checkTryCatchParameter(), t.wrap = function(t, n) {
        return n = n || e, !t || t.jquery ? t : n(t);
    }, t.unwrap = function(e) {
        return e && e.jquery ? e[0] : e;
    }, t.container = function(e, n, r) {
        var o = e.selector || e;
        r && (e = t.unwrap(e));
        var a = t.wrap(e, r);
        if (n && (!a || 0 === a.length)) return null;
        if (!a || !a.jquery || 1 !== a.length) {
            "string" != typeof e && (e = a.selector);
            var i = void 0 !== a.length ? a.length : 0;
            t.fail((i > 1 ? "More than one (" + i + ") container elements were" : "No container element was") + " found for selector " + e);
        }
        return t.isDOMNode(a[0]) || t.fail("fluid.container was supplied a non-jQueryable element"), 
        a.selector = o, a.context = a.context || e.ownerDocument || document, a;
    }, t.createDomBinder = function(n, r) {
        function o(e, n) {
            return t.allocateSimpleId(n) + "-" + e;
        }
        function a(e, t, n) {
            i.cache[o(e, t)] = n;
        }
        var i = {
            id: t.allocateGuid(),
            cache: {}
        }, u = n.constructor;
        return i.locate = function(o, i) {
            var s, l, c;
            if (void 0 !== (s = r[o])) return (l = i ? e(i) : n) || t.fail("DOM binder invoked for selector " + o + " without container"), 
            (c = "" === s ? l : s ? "function" == typeof s ? u(s.call(null, t.unwrap(l))) : u(s, l) : u()).selector || (c.selector = s, 
            c.context = l), c.selectorName = o, a(o, l, c), c;
        }, i.fastLocate = function(e, t) {
            var r = o(e, t || n), a = i.cache[r];
            return a || i.locate(e, t);
        }, i.clear = function() {
            i.cache = {};
        }, i.refresh = function(e, t) {
            var r = t || n;
            "string" == typeof e && (e = [ e ]), void 0 === r.length && (r = [ r ]);
            for (var o = 0; o < e.length; ++o) for (var a = 0; a < r.length; ++a) i.locate(e[o], r[a]);
        }, i.resolvePathSegment = i.locate, i;
    }, t.expectFilledSelector = function(e, n) {
        e && 0 === e.length && e.jquery && t.fail(n + ': selector "' + e.selector + '" with name ' + e.selectorName + " returned no results in context " + t.dumpEl(e.context));
    }, t.initView = function(n, r, o, a) {
        var i = t.container(r, !0);
        if (t.expectFilledSelector(i, 'Error instantiating component with name "' + n), 
        !i) return null;
        var u = t.initLittleComponent(n, o, a || {
            gradeNames: [ "fluid.viewComponent" ]
        }, function(e) {
            e.container = i;
        });
        u.dom || t.initDomBinder(u);
        var s = u.options.jQuery;
        return t.log("Constructing view component " + n + " with container " + i.constructor.expando + (s ? " user jQuery " + s.expando : "") + " env: " + e.expando), 
        u;
    }, t.initDomBinder = function(e, n) {
        return e.container || t.fail("fluid.initDomBinder called for component with typeName " + e.typeName + ' without an initialised container - this has probably resulted from placing "fluid.viewComponent" in incorrect position in grade merging order.  Make sure to place it to the right of any non-view grades in the gradeNames list to ensure that it overrides properly: resolved gradeNames is ', e.options.gradeNames, " for component ", e), 
        e.dom = t.createDomBinder(e.container, n || e.options.selectors || {}), e.locate = e.dom.locate, 
        e.dom;
    }, t.findAncestor = function(e, n) {
        for (e = t.unwrap(e); e; ) {
            if (n(e)) return e;
            e = e.parentNode;
        }
    }, t.findForm = function(e) {
        return t.findAncestor(e, function(e) {
            return "form" === e.nodeName.toLowerCase();
        });
    }, t.each([ "text", "html" ], function(n) {
        t[n] = function(t, r) {
            return t = e(t), void 0 === r ? t[n]() : t[n](r);
        };
    }), t.value = function(n, r) {
        var o = t.unwrap(n), a = !1;
        if (void 0 === o.nodeType && o.length > 1 && (o = o[0], a = !0), "input" !== o.nodeName.toLowerCase() || !/radio|checkbox/.test(o.type)) return void 0 === r ? e(o).val() : e(o).val(r);
        var i = o.name;
        void 0 === i && t.fail("Cannot acquire value from node " + t.dumpEl(o) + " which does not have name attribute set");
        var u;
        if (a) u = n; else {
            u = o.ownerDocument.getElementsByName(i);
            var s = t.findForm(o);
            u = e.grep(u, function(e) {
                return e.name === i && (!s || t.dom.isContainer(s, e));
            });
        }
        if (void 0 === r) {
            var l = e.map(u, function(e) {
                return e.checked ? e.value : null;
            });
            return "radio" === o.type ? l[0] : l;
        }
        "boolean" == typeof r && (r = r ? "true" : "false"), e.each(u, function() {
            this.checked = r instanceof Array ? -1 !== r.indexOf(this.value) : r === this.value;
        });
    }, t.BINDING_ROOT_KEY = "fluid-binding-root", t.findData = function(t, n) {
        for (;t; ) {
            var r = e.data(t, n);
            if (r) return r;
            t = t.parentNode;
        }
    }, t.bindFossils = function(n, r, o) {
        e.data(n, t.BINDING_ROOT_KEY, {
            data: r,
            fossils: o
        });
    }, t.boundPathForNode = function(e, n) {
        var r = n[(e = t.unwrap(e)).name || e.id];
        return r ? r.EL : null;
    }, t.applyBoundChange = function(e, n, r) {
        e = t.unwrap(e), void 0 === n && (n = t.value(e)), void 0 === e.nodeType && e.length > 0 && (e = e[0]);
        var o = t.findData(e, t.BINDING_ROOT_KEY);
        o || t.fail("Bound data could not be discovered in any node above " + t.dumpEl(e));
        var a = e.name, i = o.fossils[a];
        i || t.fail("No fossil discovered for name " + a + " in fossil record above " + t.dumpEl(e)), 
        "boolean" == typeof i.oldvalue && (n = !!n[0]);
        var u = o.fossils[a].EL;
        r ? r.fireChangeRequest({
            path: u,
            value: n,
            source: "DOM:" + e.id
        }) : t.set(o.data, u, n);
    }, t.jById = function(n, r) {
        r = r && 9 === r.nodeType ? r : document;
        var o = t.byId(n, r), a = o ? e(o) : [];
        return a.selector = "#" + n, a.context = r, a;
    }, t.byId = function(e, n) {
        var r = (n = n && 9 === n.nodeType ? n : document).getElementById(e);
        return r ? (r.id !== e && t.fail("Problem in document structure - picked up element " + t.dumpEl(r) + " for id " + e + " without this id - most likely the element has a name which conflicts with this id"), 
        r) : null;
    }, t.getId = function(e) {
        return t.unwrap(e).id;
    }, t.allocateSimpleId = function(e) {
        if (!(e = t.unwrap(e)) || t.isPrimitive(e)) return null;
        if (!e.id) {
            var n = "fluid-id-" + t.allocateGuid();
            e.id = n;
        }
        return e.id;
    }, t.getDocument = function(e) {
        var n = t.unwrap(e);
        return 9 === n.nodeType ? n : n.ownerDocument;
    }, t.defaults("fluid.ariaLabeller", {
        gradeNames: [ "fluid.viewComponent" ],
        labelAttribute: "aria-label",
        liveRegionMarkup: '<div class="liveRegion fl-hidden-accessible" aria-live="polite"></div>',
        liveRegionId: "fluid-ariaLabeller-liveRegion",
        invokers: {
            generateLiveElement: {
                funcName: "fluid.ariaLabeller.generateLiveElement",
                args: "{that}"
            },
            update: {
                funcName: "fluid.ariaLabeller.update",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                func: "{that}.update",
                args: [ null ]
            }
        }
    }), t.ariaLabeller.update = function(e, n) {
        if (n = n || e.options, e.container.attr(e.options.labelAttribute, n.text), n.dynamicLabel) {
            var r = t.jById(e.options.liveRegionId);
            0 === r.length && (r = e.generateLiveElement()), r.text(n.text);
        }
    }, t.ariaLabeller.generateLiveElement = function(t) {
        var n = e(t.options.liveRegionMarkup);
        return n.prop("id", t.options.liveRegionId), e("body").append(n), n;
    };
    t.getAriaLabeller = function(n) {
        return n = e(n), t.getScopedData(n, "aria-labelling");
    }, t.updateAriaLabel = function(n, r, o) {
        o = e.extend({}, o || {}, {
            text: r
        });
        var a = t.getAriaLabeller(n);
        return a ? a.update(o) : (a = t.ariaLabeller(n, o), t.setScopedData(n, "aria-labelling", a)), 
        a;
    };
    var n = {};
    e(document).click(function(e) {
        for (var r = t.resolveEventTarget(e); r; ) {
            if (n[r.id]) return;
            r = r.parentNode;
        }
        t.each(n, function(t, r) {
            t(e), delete n[r];
        });
    }), t.globalDismissal = function(e, r) {
        t.each(e, function(e) {
            var o = t.unwrap(e).ownerDocument === document ? t.allocateSimpleId(e) : t.allocateGuid();
            r ? n[o] = r : delete n[o];
        });
    }, t.now = function() {
        return Date.now ? Date.now() : new Date().getTime();
    }, t.deadMansBlur = function(n, r) {
        var o = {
            options: e.extend(!0, {}, t.defaults("fluid.deadMansBlur"), r)
        };
        return o.blurPending = !1, o.lastCancel = 0, o.canceller = function(e) {
            t.log("Cancellation through " + e.type + " on " + t.dumpEl(e.target)), o.lastCancel = t.now(), 
            o.blurPending = !1;
        }, o.noteProceeded = function() {
            t.globalDismissal(o.options.exclusions);
        }, o.reArm = function() {
            t.globalDismissal(o.options.exclusions, o.proceed);
        }, o.addExclusion = function(e) {
            t.globalDismissal(e, o.proceed);
        }, o.proceed = function(e) {
            t.log("Direct proceed through " + e.type + " on " + t.dumpEl(e.target)), o.blurPending = !1, 
            o.options.handler(n);
        }, t.each(o.options.exclusions, function(n) {
            n = e(n), t.each(n, function(t) {
                e(t).on("focusin", o.canceller).on("fluid-focus", o.canceller).click(o.canceller).mousedown(o.canceller);
            });
        }), o.options.cancelByDefault ? o.reArm() : e(n).on("focusout", function(e) {
            t.log("Starting blur timer for element " + t.dumpEl(e.target));
            var r = t.now();
            t.log("back delay: " + (r - o.lastCancel)), r - o.lastCancel > o.options.backDelay && (o.blurPending = !0), 
            setTimeout(function() {
                o.blurPending && o.options.handler(n);
            }, o.options.delay);
        }), o;
    }, t.defaults("fluid.deadMansBlur", {
        gradeNames: "fluid.function",
        delay: 150,
        backDelay: 100
    });
}(jQuery, fluid_3_0_0), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.ArrayMath) {
        var t = {};
        t.add = function(e, t, n) {
            var r;
            if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] + n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t + n[r];
        }, t.sub = function(e, t, n) {
            var r;
            if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] - n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t - n[r];
        }, t.mul = function(e, t, n) {
            var r;
            if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] * n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t * n[r];
        }, t.mulCplx = function(e, t, n, r, o, a) {
            var i, u, s, l, c;
            if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, o.length, a.length) - 1; i >= 0; --i) u = n[i], 
            s = r[i], l = o[i], c = a[i], e[i] = u * l - s * c, t[i] = u * c + s * l; else for (i = Math.min(e.length, t.length, o.length, a.length) - 1; i >= 0; --i) l = o[i], 
            c = a[i], e[i] = n * l - r * c, t[i] = n * c + r * l;
        }, t.div = function(e, t, n) {
            var r;
            if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = t[r] / n[r]; else for (r = Math.min(e.length, n.length) - 1; r >= 0; --r) e[r] = t / n[r];
        }, t.divCplx = function(e, t, n, r, o, a) {
            var i, u, s, l, c, f;
            if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, r.length, o.length, a.length) - 1; i >= 0; --i) u = n[i], 
            s = r[i], f = 1 / ((l = o[i]) * l + (c = a[i]) * c), e[i] = (u * l + s * c) * f, 
            t[i] = (s * l - u * c) * f; else for (i = Math.min(e.length, t.length, o.length, a.length) - 1; i >= 0; --i) f = 1 / ((l = o[i]) * l + (c = a[i]) * c), 
            e[i] = (n * l + r * c) * f, t[i] = (r * l - n * c) * f;
        }, t.madd = function(e, t, n, r) {
            var o;
            if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length, r.length) - 1; o >= 0; --o) e[o] = t[o] * n[o] + r[o]; else for (o = Math.min(e.length, n.length, r.length) - 1; o >= 0; --o) e[o] = t * n[o] + r[o];
        }, t.abs = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.abs(t[n]);
        }, t.absCplx = function(e, t, n) {
            for (var r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = Math.sqrt(t[r] * t[r] + n[r] * n[r]);
        }, t.acos = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.acos(t[n]);
        }, t.asin = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.asin(t[n]);
        }, t.atan = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.atan(t[n]);
        }, t.atan2 = function(e, t, n) {
            for (var r = Math.min(e.length, n.length, t.length) - 1; r >= 0; --r) e[r] = Math.atan2(t[r], n[r]);
        }, t.ceil = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.ceil(t[n]);
        }, t.cos = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.cos(t[n]);
        }, t.exp = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.exp(t[n]);
        }, t.floor = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.floor(t[n]);
        }, t.log = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.log(t[n]);
        }, t.max = function(e) {
            for (var t = -1 / 0, n = e.length - 1; n >= 0; --n) {
                var r = e[n];
                r > t && (t = r);
            }
            return t;
        }, t.min = function(e) {
            for (var t = 1 / 0, n = e.length - 1; n >= 0; --n) {
                var r = e[n];
                r < t && (t = r);
            }
            return t;
        }, t.pow = function(e, t, n) {
            var r;
            if (n instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length) - 1; r >= 0; --r) e[r] = Math.pow(t[r], n[r]); else for (r = Math.min(e.length, t.length) - 1; r >= 0; --r) e[r] = Math.pow(t[r], n);
        }, t.random = function(e, t, n) {
            t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
            for (var r = n - t, o = e.length - 1; o >= 0; --o) e[o] = Math.random() * r + t;
        }, t.round = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.round(t[n]);
        }, t.sin = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sin(t[n]);
        }, t.sqrt = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.sqrt(t[n]);
        }, t.tan = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = Math.tan(t[n]);
        }, t.clamp = function(e, t, n, r) {
            for (var o = Math.min(e.length, t.length) - 1; o >= 0; --o) {
                var a = t[o];
                e[o] = a < n ? n : a > r ? r : a;
            }
        }, t.fract = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) {
                var r = t[n];
                e[n] = r - Math.floor(r);
            }
        }, t.fill = function(e, t) {
            for (var n = e.length - 1; n >= 0; --n) e[n] = t;
        }, t.ramp = function(e, t, n) {
            var r = e.length - 1;
            if (r >= 0 && (e[0] = t), r > 0) for (var o = (n - t) / r, a = 1; a <= r; ++a) e[a] = t + o * a;
        }, t.sign = function(e, t) {
            for (var n = Math.min(e.length, t.length) - 1; n >= 0; --n) e[n] = t[n] < 0 ? -1 : 1;
        }, t.sum = function(e) {
            for (var t = 0, n = e.length - 1; n >= 0; --n) t += e[n];
            return t;
        }, t.sampleLinear = function(e, t, n) {
            for (var r = t.length - 1, o = Math.min(e.length, n.length) - 1; o >= 0; --o) {
                var a = n[o];
                a = a < 0 ? 0 : a > r ? r : a;
                var i = Math.floor(a), u = a - i, s = t[i], l = t[i < r ? i + 1 : r];
                e[o] = s + u * (l - s);
            }
        }, t.sampleLinearRepeat = function(e, t, n) {
            for (var r = t.length, o = r - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                var i = n[a];
                i -= Math.floor(i / r) * r;
                var u = Math.floor(i), s = i - u, l = t[u], c = t[u < o ? u + 1 : 0];
                e[a] = l + s * (c - l);
            }
        }, t.sampleCubic = function(e, t, n) {
            for (var r = t.length - 1, o = Math.min(e.length, n.length) - 1; o >= 0; --o) {
                var a = n[o];
                a = a < 0 ? 0 : a > r ? r : a;
                var i = Math.floor(a), u = a - i, s = u * u, l = s * u, c = -2 * l + 3 * s, f = 1 - c, d = l - s, p = d - s + u, m = t[i > 0 ? i - 1 : 0], g = t[i], h = t[i < r ? i + 1 : r], v = t[i < r - 1 ? i + 2 : r];
                e[o] = f * g + c * h + .5 * (p * (h - m) + d * (v - g));
            }
        }, t.sampleCubicRepeat = function(e, t, n) {
            for (var r = t.length, o = r - 1, a = Math.min(e.length, n.length) - 1; a >= 0; --a) {
                var i = n[a];
                i -= Math.floor(i / r) * r;
                var u = Math.floor(i), s = i - u, l = s * s, c = l * s, f = -2 * c + 3 * l, d = 1 - f, p = c - l, m = p - l + s, g = t[u > 0 ? u - 1 : o], h = t[u], v = t[u < o ? u + 1 : 0], y = t[u < o - 1 ? u + 2 : u + 2 - Math.floor((u + 2) / r) * r];
                e[a] = d * h + f * v + .5 * (m * (v - g) + p * (y - h));
            }
        }, t.pack = function(e, t, n, r, o, a, i) {
            var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
            if (o) {
                s = Math.min(s, o.length);
                if (a) {
                    s = Math.min(s, a.length);
                    if (i) for (var s = Math.min(s, i.length), l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = o[l], 
                    e[t + 2] = a[l], e[t + 3] = i[l], t += n; else for (l = 0; l < s; ++l) e[t] = r[l], 
                    e[t + 1] = o[l], e[t + 2] = a[l], t += n;
                } else for (l = 0; l < s; ++l) e[t] = r[l], e[t + 1] = o[l], t += n;
            } else for (l = 0; l < s; ++l) e[t] = r[l], t += n;
        }, t.unpack = function(e, t, n, r, o, a, i) {
            var u = Math.floor(Math.max(0, e.length - t) / n), s = Math.min(u, r.length);
            if (o) {
                s = Math.min(s, o.length);
                if (a) {
                    s = Math.min(s, a.length);
                    if (i) for (var s = Math.min(s, i.length), l = 0; l < s; ++l) r[l] = e[t], o[l] = e[t + 1], 
                    a[l] = e[t + 2], i[l] = e[t + 3], t += n; else for (l = 0; l < s; ++l) r[l] = e[t], 
                    o[l] = e[t + 1], a[l] = e[t + 2], t += n;
                } else for (l = 0; l < s; ++l) r[l] = e[t], o[l] = e[t + 1], t += n;
            } else for (l = 0; l < s; ++l) r[l] = e[t], t += n;
        }, e.ArrayMath = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.Filter) {
        var t = function(e, t) {
            !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
            this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
            this._aHist = new Float32Array(t);
        };
        t.prototype.filter = function(e, t) {
            var n, r = this._a, o = r.length, a = this._b, i = a.length, u = this._aHist, s = this._bHist, l = t.length, c = e.length, f = i - 1, d = o;
            for (n = 0; (f || d) && n < l; ++n) {
                var p;
                p = i - f, f && f--;
                N = a[0] * t[n];
                for (A = 1; A < p; ++A) N += a[A] * t[n - A];
                for (;A < i; ++A) N += a[A] * s[A - p];
                for (p = o - d, d && d--, A = 0; A < p; ++A) N -= r[A] * e[n - 1 - A];
                for (;A < o; ++A) N -= r[A] * u[A - p];
                e[n] = N;
            }
            if (3 == i && 2 == o) for (var m, g, h = a[0], v = a[1], y = a[2], k = r[0], b = r[1], x = t[n - 1], S = t[n - 2], w = e[n - 1], C = e[n - 2]; n < l; ++n) m = S, 
            S = x, g = C, w = h * (x = t[n]) + v * S + y * m - k * (C = w) - b * g, e[n] = w; else for (;n < l; ++n) {
                var A, N = a[0] * t[n];
                for (A = 1; A < i; ++A) N += a[A] * t[n - A];
                for (A = 0; A < o; ++A) N -= r[A] * e[n - 1 - A];
                e[n] = N;
            }
            var T = Math.min(i - 1, l);
            for (n = i - 2; n >= T; --n) s[n] = s[n - T];
            for (n = 0; n < T; ++n) s[n] = t[l - 1 - n];
            for (T = Math.min(o, c), n = o - 1; n >= T; --n) u[n] = u[n - T];
            for (n = 0; n < T; ++n) u[n] = e[l - 1 - n];
        }, t.prototype.clearHistory = function() {
            for (e = this._bHist.length - 1; e >= 0; --e) this._bHist[e] = 0;
            for (var e = this._aHist.length - 1; e >= 0; --e) this._aHist[e] = 0;
        }, t.prototype.setB = function(e) {
            for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
        }, t.prototype.setA = function(e) {
            for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
        }, e.Filter = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.FFT) {
        var t = function(e, t, n, r, o, a, i) {
            for (var u, s, l, c, f, d, p, m, g = 0, h = n, v = n + i, y = .7071067811865475, k = h + i; h < k; ) l = e[h] * y, 
            c = t[h] * y, f = e[v] * y, d = t[v] * y, u = f * (p = o[g]) - d * (m = a[g]), s = f * m + d * p, 
            e[v] = l - u, t[v] = c - s, e[h] = l + u, t[h] = c + s, g += r, ++h, ++v;
        }, n = function(e, t, n, r, o, a, i) {
            for (var u, s, l, c, f, d, p, m, g, h, v, y, k, b, x, S, w = 0, C = 0, A = 2 * r, N = n, T = n + i, I = n + 2 * i, M = a[r * i], P = .5773502691896258, O = N + i; N < O; ) g = e[N] * P, 
            h = t[N] * P, v = e[T] * P, y = t[T] * P, k = e[I] * P, b = t[I] * P, x = o[w], 
            c = v * (S = a[w]) + y * x, u = (l = v * x - y * S) - (f = k * (x = o[C]) - b * (S = a[C])), 
            s = c - (d = k * S + b * x), v = g - .5 * (p = l + f), y = h - .5 * (m = c + d), 
            u *= M, s *= M, e[N] = g + p, t[N] = h + m, e[I] = v + s, t[I] = y - u, e[T] = v - s, 
            t[T] = y + u, w += r, C += A, ++N, ++T, ++I;
        }, r = function(e, t, n, r, o, a, i, u) {
            for (var s, l, c, f, d, p, m, g, h, v, y, k, b, x, S, w, C, A, N, T, I, M, P = 0, O = 0, D = 0, L = 2 * r, R = 3 * r, E = n, V = n + i, F = n + 2 * i, q = n + 3 * i, B = E + i; E < B; ) b = .5 * e[E], 
            x = .5 * t[E], S = .5 * e[V], w = .5 * t[V], C = .5 * e[F], A = .5 * t[F], N = .5 * e[q], 
            T = .5 * t[q], s = S * (I = o[P]) - w * (M = a[P]), l = S * M + w * I, y = b - (c = C * (I = o[O]) - A * (M = a[O])), 
            k = x - (f = C * M + A * I), b += c, x += f, m = s + (d = N * (I = o[D]) - T * (M = a[D])), 
            g = l + (p = N * M + T * I), h = s - d, v = l - p, e[F] = b - m, t[F] = x - g, e[E] = b + m, 
            t[E] = x + g, u ? (e[V] = y - v, t[V] = k + h, e[q] = y + v, t[q] = k - h) : (e[V] = y + v, 
            t[V] = k - h, e[q] = y - v, t[q] = k + h), P += r, O += L, D += R, ++E, ++V, ++F, 
            ++q;
        }, o = function(e, t, n, r, o, a, i) {
            for (var u, s, l, c, f, d, p, m, g, h, v, y, k, b, x, S, w, C, A, N, T, I, M, P, O, D, L, R, E, V, F, q, B, _, G, j, U, H, W = 0, z = 0, $ = 0, K = 0, X = 2 * r, J = 3 * r, Q = 4 * r, Y = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, re = o[r * i], oe = a[r * i], ae = o[2 * r * i], ie = a[2 * r * i], ue = .4472135954999579, se = Y + i; Y < se; ) L = e[Y] * ue, 
            R = t[Y] * ue, E = e[Z] * ue, V = t[Z] * ue, F = e[ee] * ue, q = t[ee] * ue, B = e[te] * ue, 
            _ = t[te] * ue, G = e[ne] * ue, j = t[ne] * ue, u = L, s = R, l = E * (U = o[W]) - V * (H = a[W]), 
            c = E * H + V * U, f = F * (U = o[z]) - q * (H = a[z]), d = F * H + q * U, p = B * (U = o[$]) - _ * (H = a[$]), 
            m = B * H + _ * U, x = l + (g = G * (U = o[K]) - j * (H = a[K])), S = c + (h = G * H + j * U), 
            T = l - g, I = c - h, w = f + p, C = d + m, A = f - p, N = d - m, e[Y] = L + x + w, 
            t[Y] = R + S + C, v = u + x * re + w * ae, y = s + S * re + C * ae, k = I * oe + N * ie, 
            b = -T * oe - A * ie, e[Z] = v - k, t[Z] = y - b, e[ne] = v + k, t[ne] = y + b, 
            M = u + x * ae + w * re, P = s + S * ae + C * re, O = -I * ie + N * oe, D = T * ie - A * oe, 
            e[ee] = M + O, t[ee] = P + D, e[te] = M - O, t[te] = P - D, W += r, z += X, $ += J, 
            K += Q, ++Y, ++Z, ++ee, ++te, ++ne;
        }, a = function(e, t, n, r, o, a, i, u, s) {
            var l, c, f, d, p, m, g, h, v, y, k = new Float32Array(u), b = new Float32Array(u), x = Math.sqrt(1 / u);
            for (l = 0; l < i; ++l) {
                for (d = n + l, c = 0; c < u; ++c) k[c] = e[d] * x, b[c] = t[d] * x, d += i;
                d = n + l;
                var S = r * l;
                for (c = 0; c < u; ++c) {
                    p = k[0], m = b[0];
                    var w = 0;
                    for (f = 1; f < u; ++f) (w += S) >= s && (w -= s), g = k[f], h = b[f], p += g * (v = o[w]) - h * (y = a[w]), 
                    m += g * y + h * v;
                    e[d] = p, t[d] = m, d += i, S += r;
                }
            }
        }, i = function(e, u, s, l, c, f, d, p, m, g, h, v, y, k) {
            var b = m[g++], x = m[g++], S = s, w = s + b * x, C = d * p;
            if (1 == x) do {
                e[s] = l[f], u[s] = c[f], f += C, ++s;
            } while (s != w); else do {
                i(e, u, s, l, c, f, d * b, p, m, g, h, v, y, k), f += C, s += x;
            } while (s != w);
            switch (s = S, b) {
              case 2:
                t(e, u, s, d, h, v, x);
                break;

              case 3:
                n(e, u, s, d, h, v, x);
                break;

              case 4:
                r(e, u, s, d, h, v, x, k);
                break;

              case 5:
                o(e, u, s, d, h, v, x);
                break;

              default:
                a(e, u, s, d, h, v, x, b, y);
            }
        }, u = function(e, t) {
            var n = 4, r = Math.floor(Math.sqrt(e)), o = 0;
            do {
                for (;e % n; ) {
                    switch (n) {
                      case 4:
                        n = 2;
                        break;

                      case 2:
                        n = 3;
                        break;

                      default:
                        n += 2;
                    }
                    n > r && (n = e);
                }
                e = Math.floor(e / n), t[o++] = n, t[o++] = e;
            } while (e > 1);
        }, s = function(e) {
            e || (e = 256), Object.defineProperty(this, "size", {
                configurable: !1,
                writable: !1,
                value: e
            }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
            this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
            for (var t = 0; t < e; ++t) {
                var n = -2 * Math.PI * t / e, r = Math.cos(n), o = Math.sin(n);
                this._twiddlesFwdRe[t] = r, this._twiddlesFwdIm[t] = o, this._twiddlesInvIm[t] = -o;
            }
            this._factors = new Int32Array(64), u(e, this._factors);
        };
        s.prototype.forwardCplx = function(e, t, n, r) {
            var o = this._twiddlesFwdRe, a = this._twiddlesFwdIm;
            i(e, t, 0, n, r, 0, 1, 1, this._factors, 0, o, a, this.size, !1);
        }, s.prototype.forward = function(e, t, n) {
            this.forwardCplx(e, t, n, new Float32Array(this.size));
        }, s.prototype.inverseCplx = function(e, t, n, r) {
            var o = this._twiddlesInvRe, a = this._twiddlesInvIm;
            i(e, t, 0, n, r, 0, 1, 1, this._factors, 0, o, a, this.size, !0);
        }, s.prototype.inverse = function(e, t, n) {
            this.inverseCplx(e, new Float32Array(this.size), t, n);
        }, e.FFT = s;
    }
}();

var Random = function(e) {
    if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
    this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
    this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
    this.init_by_array([ e ], 1);
};

Random.prototype.init_genrand = function(e) {
    for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
        var e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
        this.mt[this.mti] >>>= 0;
    }
}, Random.prototype.init_by_array = function(e, t) {
    var n, r, o;
    for (this.init_genrand(19650218), n = 1, r = 0, o = this.N > t ? this.N : t; o; o--) {
        a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & a) >>> 16) << 16) + 1664525 * (65535 & a)) + e[r] + r, 
        this.mt[n] >>>= 0, r++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
        r >= t && (r = 0);
    }
    for (o = this.N - 1; o; o--) {
        var a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & a) >>> 16) << 16) + 1566083941 * (65535 & a)) - n, 
        this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
    }
    this.mt[0] = 2147483648;
}, Random.prototype.genrand_int32 = function() {
    var e, t = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var n;
        for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
        for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
        e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
        this.mti = 0;
    }
    return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
    (e ^= e >>> 18) >>> 0;
}, Random.prototype.genrand_int31 = function() {
    return this.genrand_int32() >>> 1;
}, Random.prototype.genrand_real1 = function() {
    return this.genrand_int32() * (1 / 4294967295);
}, Random.prototype.random = function() {
    return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
    this.genrand_int32() * (1 / 4294967296);
}, Random.prototype.genrand_real3 = function() {
    return (this.genrand_int32() + .5) * (1 / 4294967296);
}, Random.prototype.genrand_res53 = function() {
    return (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6)) * (1 / 9007199254740992);
}, Random.prototype.LOG4 = Math.log(4), Random.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
Random.prototype.exponential = function(e) {
    if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
    var t = this.random();
    return -Math.log(t) / e;
}, Random.prototype.gamma = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
    if (!(e > 1)) {
        if (1 == e) {
            for (n = this.random(); n <= 1e-7; ) n = this.random();
            return -Math.log(n) * t;
        }
        for (;;) {
            var n = this.random(), r = (Math.E + e) / Math.E, o = r * n;
            if (o <= 1) a = Math.pow(o, 1 / e); else var a = -Math.log((r - o) / e);
            var i = this.random();
            if (o > 1) {
                if (i <= Math.pow(a, e - 1)) break;
            } else if (i <= Math.exp(-a)) break;
        }
        return a * t;
    }
    for (var u = Math.sqrt(2 * e - 1), s = e - this.LOG4, l = e + u; ;) if (!((i = this.random()) < 1e-7 || n > .9999999)) {
        var c = 1 - this.random(), f = Math.log(i / (1 - i)) / u, d = i * i * c, p = s + l * f - (a = e * Math.exp(f));
        if (p + this.SG_MAGICCONST - 4.5 * d >= 0 || p >= Math.log(d)) return a * t;
    }
}, Random.prototype.normal = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
    var n = this.lastNormal;
    if (this.lastNormal = NaN, !n) {
        var r = 2 * this.random() * Math.PI, o = Math.sqrt(-2 * Math.log(1 - this.random()));
        n = Math.cos(r) * o, this.lastNormal = Math.sin(r) * o;
    }
    return e + n * t;
}, Random.prototype.pareto = function(e) {
    if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
    var t = this.random();
    return 1 / Math.pow(1 - t, 1 / e);
}, Random.prototype.triangular = function(e, t, n) {
    if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
    var r = (n - e) / (t - e), o = this.random();
    return o <= r ? e + Math.sqrt(o * (t - e) * (n - e)) : t - Math.sqrt((1 - o) * (t - e) * (t - n));
}, Random.prototype.uniform = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
    return e + this.random() * (t - e);
}, Random.prototype.weibull = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
    var n = 1 - this.random();
    return e * Math.pow(-Math.log(n), 1 / t);
}, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = Random);

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    if (flock.fluid = fluid, flock.init = function(e) {
        var t = e ? {
            components: {
                audioSystem: {
                    options: {
                        model: e
                    }
                }
            }
        } : void 0;
        return flock.enviro(t);
    }, flock.ALL_CHANNELS = 32, flock.OUT_UGEN_ID = "flocking-out", flock.PI = Math.PI, 
    flock.TWOPI = 2 * Math.PI, flock.HALFPI = Math.PI / 2, flock.LOG01 = Math.log(.1), 
    flock.LOG001 = Math.log(.001), flock.ROOT2 = Math.sqrt(2), flock.rates = {
        AUDIO: "audio",
        CONTROL: "control",
        SCHEDULED: "scheduled",
        DEMAND: "demand",
        CONSTANT: "constant"
    }, fluid.registerNamespace("flock.debug"), flock.debug.failHard = !0, flock.browser = function() {
        if ("undefined" == typeof navigator) return {};
        var e, t, n = navigator.userAgent.toLowerCase(), r = {};
        return e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [], 
        (t = {
            browser: e[1] || "",
            version: e[2] || "0"
        }).browser && (r[t.browser] = !0, r.version = t.version), r.chrome ? r.webkit = !0 : r.webkit && (r.safari = !0), 
        r;
    }, fluid.registerNamespace("flock.platform"), flock.platform.isBrowser = "undefined" != typeof window, 
    flock.platform.hasRequire = "undefined" != typeof require, flock.platform.os = flock.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
    flock.platform.isLinux = flock.platform.os.indexOf("Linux") > -1, flock.platform.isAndroid = flock.platform.isLinux && flock.platform.os.indexOf("arm") > -1, 
    flock.platform.isIOS = "iPhone" === flock.platform.os || "iPad" === flock.platform.os || "iPod" === flock.platform.os, 
    flock.platform.isMobile = flock.platform.isAndroid || flock.platform.isIOS, flock.platform.browser = flock.browser(), 
    flock.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
    flock.platform.audioEngine = flock.platform.isBrowser ? "webAudio" : "nodejs", flock.platform.browser && void 0 !== flock.platform.browser.version) {
        var t = flock.platform.browser.version.indexOf(".");
        flock.platform.browser.majorVersionNumber = Number(t < 0 ? flock.platform.browser.version : flock.platform.browser.version.substring(0, t));
    }
    flock.shim = {
        URL: flock.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.requireModule = function(e, t) {
        if (flock.platform.isBrowser) return window[t || e];
        if (flock.platform.hasRequire) {
            var n = flock.requireModule.paths[e] || e, r = require(n);
            return t ? r[t] : r;
        }
    }, flock.requireModule.paths = {
        webarraymath: "../third-party/webarraymath/js/webarraymath.js",
        Random: "../third-party/simjs/js/random-0.26.js"
    }, flock.noOp = function() {}, flock.isIterable = function(e) {
        var t = typeof e;
        return e && void 0 !== e.length && "string" !== t && "function" !== t;
    }, flock.hasValue = function(e, t) {
        var n = !1;
        for (var r in e) if (e[r] === t) {
            n = !0;
            break;
        }
        return n;
    }, flock.hasTag = function(e, t) {
        return !(!e || !t) && (e.tags && e.tags.indexOf(t) > -1);
    }, flock.randomValue = function(e, t) {
        var n = t - e;
        return Math.random() * n + e;
    }, flock.randomAudioValue = function() {
        return 2 * Math.random() - 1;
    }, flock.fillBuffer = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t(n, e);
        return e;
    }, flock.fillBufferWithValue = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t;
        return e;
    }, flock.generateBuffer = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBuffer(n, t);
    }, flock.generateBufferWithValue = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBufferWithValue(n, t);
    }, flock.generate = function(e, t) {
        var n = "number" == typeof e;
        return ("function" == typeof t ? n ? flock.generateBuffer : flock.fillBuffer : n ? flock.generateBufferWithValue : flock.fillBufferWithValue)(e, t);
    }, flock.generate.silence = function(e) {
        return new Float32Array(e);
    }, flock.clearBuffer = function(e) {
        for (var t = 0; t < e.length; t++) e[t] = 0;
        return e;
    }, flock.reverse = function(e) {
        if (!e || !flock.isIterable(e) || e.length < 2) return e;
        if ("function" == typeof e.reverse) return e.reverse();
        for (var t, n = 0, r = e.length - 1; n < r; n++, r--) t = e[n], e[n] = e[r], e[r] = t;
        return e;
    }, flock.randomIndex = function(e) {
        var t = e.length - 1;
        return Math.round(Math.random() * t);
    }, flock.arrayChoose = function(e, t) {
        return t = t || flock.randomIndex, (e = fluid.makeArray(e))[t(e)];
    }, flock.choose = function(e, t) {
        var n;
        return flock.isIterable(e) ? flock.arrayChoose(e, t) : (n = flock.arrayChoose(e.keys, t), 
        e[n]);
    }, flock.shuffle = function(e) {
        for (var t = e.length - 1; t > 0; t -= 1) {
            var n = Math.floor(Math.random() * (t + 1)), r = e[t];
            e[t] = e[n], e[n] = r;
        }
        return e;
    }, flock.normalize = function(e, t, n) {
        n = n || e;
        var r, o, a, i = 0;
        for (t = void 0 === t ? 1 : t, r = 0; r < e.length; r++) (o = Math.abs(e[r])) > i && (i = o);
        if (i > 0) for (r = 0; r < e.length; r++) a = e[r], n[r] = a / i * t;
        return n;
    }, flock.generateFourierTable = function(e, t, n, r, o) {
        return r *= flock.TWOPI, flock.generateBuffer(e, function(e) {
            var a, i, u, s = 0;
            for (a = 0; a < n; a++) i = o ? o[a] : 1, u = (a + 1) * (e * t), s += i * Math.cos(u + r);
            return s;
        });
    }, flock.generateNormalizedFourierTable = function(e, t, n, r, o) {
        var a = flock.generateBuffer(n, function(e) {
            return o(e + 1);
        }), i = flock.generateFourierTable(e, t, n, r, a);
        return flock.normalize(i);
    }, flock.fillTable = function(e, t) {
        var n = "number" == typeof e ? e : e.length;
        return t(e, flock.TWOPI / n);
    }, flock.tableGenerators = {
        sin: function(e, t) {
            return flock.generateBuffer(e, function(e) {
                return Math.sin(e * t);
            });
        },
        tri: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                return e % 2 == 0 ? 0 : 1 / (e * e);
            });
        },
        saw: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return 1 / e;
            });
        },
        square: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return e % 2 == 0 ? 0 : 1 / e;
            });
        },
        hann: function(e) {
            return flock.generateBuffer(e, function(t) {
                var n = Math.sin(Math.PI * t / e);
                return n * n;
            });
        },
        sinWindow: function(e) {
            return flock.generateBuffer(e, function(t) {
                return Math.sin(Math.PI * t / e);
            });
        }
    }, flock.range = function(e) {
        var t, n, r = {
            max: Number.NEGATIVE_INFINITY,
            min: 1 / 0
        };
        for (t = 0; t < e.length; t++) (n = e[t]) > r.max && (r.max = n), n < r.min && (r.min = n);
        return r;
    }, flock.scale = function(e) {
        if (e) {
            var t, n = flock.range(e), r = (n.max - n.min) / 2, o = (n.max + n.min) / 2;
            for (t = 0; t < e.length; t++) e[t] = (e[t] - o) / r;
            return e;
        }
    }, flock.copyBuffer = function(e, t, n) {
        void 0 === n && (n = e.length);
        var r, o, a = n - t, i = new Float32Array(a);
        for (r = t, o = 0; r < n; r++, o++) i[o] = e[r];
        return i;
    }, flock.copyToBuffer = function(e, t) {
        for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) t[r] = e[r];
    }, flock.parseMidiString = function(e) {
        if (!e || e.length < 2) return NaN;
        var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, r = e.substring(0, n);
        return 12 * Number(e.substring(n)) + flock.midiFreq.noteNames[r];
    }, flock.midiFreq = function(e, t, n, r) {
        return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, r = r || 12, "string" == typeof e && (e = flock.parseMidiString(e)), 
        t * Math.pow(2, 1 * (e - n) / r);
    }, flock.midiFreq.noteNames = {
        "b#": 0,
        c: 0,
        "c#": 1,
        db: 1,
        d: 2,
        "d#": 3,
        eb: 3,
        e: 4,
        "e#": 5,
        f: 5,
        "f#": 6,
        gb: 6,
        g: 7,
        "g#": 8,
        ab: 8,
        a: 9,
        "a#": 10,
        bb: 10,
        b: 11,
        cb: 11
    }, flock.interpolate = {
        none: function(e, t) {
            return e %= t.length, t[0 | e];
        },
        linear: function(e, t) {
            var n = t.length, r = 0 | (e %= n), o = (r + 1) % n, a = e - r, i = t[r];
            return i + a * (t[o] - i);
        },
        hermite: function(e, t) {
            var n = t.length, r = Math.floor(e), o = r % n, a = e - r, i = (o + 1) % n, u = (o + 2) % n, s = t[o > 0 ? o - 1 : n - 1], l = t[o], c = t[i], f = .5 * (c - s), d = l - c, p = f + d, m = p + d + .5 * (t[u] - l);
            return ((m * a - (p + m)) * a + f) * a + l;
        }
    }, flock.interpolate.cubic = flock.interpolate.hermite, flock.log = {
        fail: function(e) {
            fluid.log(fluid.logLevel.FAIL, e);
        },
        warn: function(e) {
            fluid.log(fluid.logLevel.WARN, e);
        },
        debug: function(e) {
            fluid.log(fluid.logLevel.INFO, e);
        }
    }, flock.fail = function(e) {
        if (flock.debug.failHard) throw new Error(e);
        flock.log.fail(e);
    }, flock.pathParseError = function(e, t, n) {
        var r = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved. Root object was: " + fluid.prettyPrintJSON(e);
        flock.fail(r);
    }, flock.get = function(e, t) {
        if (!e) return fluid.getGlobalValue(t);
        if (1 === arguments.length && "string" == typeof e) return fluid.getGlobalValue(e);
        if (t && "" !== t) {
            var n, r = "" === t ? [] : String(t).split("."), o = e[r[0]];
            for (n = 1; n < r.length; n++) {
                if (null === o || void 0 === o) return void flock.pathParseError(e, t, r[n - 1]);
                o = o[r[n]];
            }
            return o;
        }
    }, flock.set = function(e, t, n) {
        if (e && t && "" !== t) {
            var r, o = String(t).split("."), a = o.length, i = o[0];
            for (r = 1; r < a; r++) {
                if (e = e[i], "object" !== typeof e) return void flock.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + i + "'. Value: " + e);
                void 0 === e[i = o[r]] && (e[i] = {});
            }
            return e[i] = n, n;
        }
    }, flock.invoke = function(e, t, n) {
        var r = "function" == typeof e ? e : flock.get(e, t);
        {
            if ("function" == typeof r) return r.apply(null, n);
            flock.fail("Path '" + t + "' does not resolve to a function.");
        }
    }, flock.input = {}, flock.input.shouldExpand = function(e) {
        return flock.parse.specialInputs.indexOf(e) < 0;
    }, flock.input.pathExpander = function(e) {
        var t, n = fluid.model.parseEL(e), r = n.length - 1, o = [];
        for (t = 0; t < r; t++) {
            var a = n[t], i = n[t + 1];
            if (o.push(a), "model" === i || "options" === i) {
                o = o.concat(n.slice(t + 1, r));
                break;
            }
            isNaN(Number(i)) && o.push("inputs");
        }
        return o.push(n[r]), o.join(".");
    }, flock.input.expandPaths = function(e) {
        var t, n, r, o = {};
        for (t in e) n = flock.input.pathExpander(t), r = e[t], o[n] = r;
        return o;
    }, flock.input.expandPath = function(e) {
        return "string" == typeof e ? flock.input.pathExpander(e) : flock.input.expandPaths(e);
    }, flock.input.getValueForPath = function(e, t) {
        t = flock.input.expandPath(t);
        var n = flock.get(e, t);
        return flock.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
    }, flock.input.getValuesForPathArray = function(e, t) {
        var n, r, o = {};
        for (n = 0; n < t.length; n++) o[r = t[n]] = flock.input.get(e, r);
        return o;
    }, flock.input.getValuesForPathObject = function(e, t) {
        var n;
        for (n in t) t[n] = flock.input.get(e, n);
        return t;
    }, flock.input.get = function(e, t) {
        return "string" == typeof t ? flock.input.getValueForPath(e, t) : flock.isIterable(t) ? flock.input.getValuesForPathArray(e, t) : flock.input.getValuesForPathObject(e, t);
    }, flock.input.resolveValue = function(e, t, n, r, o, a, i) {
        if ("string" == typeof n) {
            var u = fluid.extractEL(n, flock.input.valueExpressionSpec);
            if (u) {
                var s = flock.input.getValueForPath(e, u);
                return void 0 === s && flock.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                s;
            }
        }
        return flock.input.shouldExpand(o) && i ? i(n, t, r, a) : n;
    }, flock.input.valueExpressionSpec = {
        ELstyle: "${}"
    }, flock.input.setValueForPath = function(e, t, n, r, o) {
        t = flock.input.expandPath(t);
        var a = flock.get(e, t), i = t.lastIndexOf("."), u = t.slice(i + 1), s = i > -1 ? flock.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : r, l = flock.input.resolveValue(e, t, n, s, u, a, o);
        return flock.set(e, t, l), s && s.onInputChanged && s.onInputChanged(u), l;
    }, flock.input.setValuesForPaths = function(e, t, n, r) {
        var o, a, i, u = {};
        for (o in t) a = t[o], i = flock.input.set(e, o, a, n, r), u[o] = i;
        return u;
    }, flock.input.set = function(e, t, n, r, o) {
        return "string" == typeof t ? flock.input.setValueForPath(e, t, n, r, o) : flock.input.setValuesForPaths(e, t, r, o);
    }, fluid.defaults("flock.audioSystem", {
        gradeNames: [ "fluid.modelComponent" ],
        channelRange: {
            min: 1,
            max: 32
        },
        outputBusRange: {
            min: 2,
            max: 1024
        },
        inputBusRange: {
            min: 1,
            max: 32
        },
        model: {
            rates: {
                audio: 44100,
                control: 689.0625,
                scheduled: 0,
                demand: 0,
                constant: 0
            },
            blockSize: 64,
            numBlocks: 16,
            chans: 2,
            numInputBuses: 2,
            numBuses: 8,
            bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
        },
        modelRelay: [ {
            target: "rates.control",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.rates.audio",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "numBlocks",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.bufferSize",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "chans",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.chans",
                min: "{that}.options.channelRange.min",
                max: "{that}.options.channelRange.max"
            }
        }, {
            target: "numInputBuses",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.numInputBuses",
                min: "{that}.options.inputBusRange.min",
                max: "{that}.options.inputBusRange.max"
            }
        }, {
            target: "numBuses",
            singleTransform: {
                type: "fluid.transforms.free",
                func: "flock.audioSystem.clampNumBuses",
                args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
            }
        } ]
    }), flock.audioSystem.clampNumBuses = function(e, t, n) {
        return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
    }, flock.audioSystem.defaultBufferSize = function() {
        return flock.platform.isMobile ? 8192 : flock.platform.browser.mozilla ? 2048 : 1024;
    }, fluid.defaults("flock.busManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            nextAvailableBus: {
                input: 0,
                interconnect: 0
            }
        },
        members: {
            buses: {
                expander: {
                    funcName: "flock.enviro.createAudioBuffers",
                    args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                }
            }
        },
        invokers: {
            acquireNextBus: {
                funcName: "flock.busManager.acquireNextBus",
                args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
            },
            reset: {
                changePath: "nextAvailableBus",
                value: {
                    input: 0,
                    interconnect: 0
                }
            }
        },
        listeners: {
            "onDestroy.reset": "{that}.reset()"
        }
    }), flock.busManager.acquireNextBus = function(e, t, n, r, o, a) {
        var i = r.nextAvailableBus[e];
        if (void 0 !== i) {
            var u = i + o, s = o + a;
            if ("interconnect" === e && (u += a, s = t.length), !(u >= s)) return n.change("nextAvailableBus." + e, ++i), 
            u;
            flock.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
        } else flock.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
    }, fluid.defaults("flock.outputManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            audioSettings: "{audioSystem}.model"
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            reset: "{that}.events.onReset.fire"
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset"
        }
    }), fluid.defaults("flock.nodeListComponent", {
        gradeNames: "fluid.component",
        members: {
            nodeList: "@expand:flock.nodeList()"
        },
        invokers: {
            insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
            head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
            tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
            before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
            after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
            remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
            replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
        }
    }), fluid.defaults("flock.enviro", {
        gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
        singleRootType: "flock.enviro",
        isGlobalSingleton: !0,
        members: {
            buffers: {},
            bufferSources: {}
        },
        components: {
            asyncScheduler: {
                type: "flock.scheduler.async"
            },
            audioSystem: {
                type: "flock.audioSystem"
            },
            busManager: {
                type: "flock.busManager"
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            gen: {
                funcName: "flock.enviro.gen",
                args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
            },
            start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
            play: "{that}.start",
            stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
            reset: "{that}.events.onReset.fire()",
            registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
            releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
            saveBuffer: {
                funcName: "flock.enviro.saveBuffer",
                args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
            }
        },
        events: {
            onStart: null,
            onPlay: "{that}.events.onStart",
            onStop: null,
            onReset: null
        },
        listeners: {
            onCreate: [ "flock.enviro.registerGlobalSingleton({that})" ],
            onStart: [ "{that}.applier.change(isPlaying, true)" ],
            onStop: [ "{that}.applier.change(isPlaying, false)" ],
            onReset: [ "{that}.stop()", "{asyncScheduler}.clearAll()", "flock.nodeList.clearAll({that}.nodeList)", "{busManager}.reset()", "fluid.clear({that}.buffers)" ]
        }
    }), flock.enviro.registerGlobalSingleton = function(e) {
        e.options.isGlobalSingleton && (flock.environment = flock.enviro.shared = e);
    }, flock.enviro.registerBuffer = function(e, t) {
        e.id && (t[e.id] = e);
    }, flock.enviro.releaseBuffer = function(e, t) {
        e && delete t["string" == typeof e ? e : e.id];
    }, flock.enviro.saveBuffer = function(e, t, n) {
        if ("string" == typeof e && (e = {
            buffer: e
        }), "string" == typeof e.buffer) {
            var r = e.buffer;
            e.buffer = t[r], e.buffer.id = r;
        }
        return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
        e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
    }, flock.enviro.gen = function(e, t, n) {
        flock.evaluate.clearBuses(e, t.numBuses, t.blockSize), flock.evaluate.synths(n);
    }, flock.enviro.start = function(e, t) {
        e.isPlaying || t();
    }, flock.enviro.stop = function(e, t) {
        e.isPlaying && t();
    }, flock.enviro.createAudioBuffers = function(e, t) {
        var n, r = [];
        for (n = 0; n < e; n++) r[n] = new Float32Array(t);
        return r;
    }, fluid.defaults("flock.autoEnviro", {
        gradeNames: [ "fluid.component" ],
        members: {
            enviro: "@expand:flock.autoEnviro.initEnvironment()"
        }
    }), flock.autoEnviro.initEnvironment = function() {
        return flock.environment ? flock.environment : flock.init();
    }, fluid.defaults("flock.silentEnviro", {
        gradeNames: "flock.enviro",
        listeners: {
            onCreate: [ "flock.silentEnviro.insertOutputGainNode({that})" ]
        }
    }), flock.silentEnviro.insertOutputGainNode = function(e) {
        e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
            node: "Gain",
            params: {
                gain: 0
            }
        });
    }, fluid.defaults("flock.node", {
        gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
        addToEnvironment: "tail",
        model: {},
        components: {
            enviro: "{flock.enviro}"
        },
        invokers: {
            play: {
                funcName: "flock.node.play",
                args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
            },
            pause: "{that}.removeFromEnvironment()",
            addToEnvironment: {
                funcName: "flock.node.addToEnvironment",
                args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
            },
            removeFromEnvironment: {
                funcName: "flock.node.removeFromEnvironment",
                args: [ "{that}", "{that}.enviro.nodeList" ]
            },
            isPlaying: {
                funcName: "flock.nodeList.isNodeActive",
                args: [ "{that}.enviro.nodeList", "{that}" ]
            }
        },
        listeners: {
            onCreate: [ "{that}.addToEnvironment({that}.options.addToEnvironment)" ],
            onDestroy: [ "{that}.removeFromEnvironment()" ]
        }
    }), flock.node.addToEnvironment = function(e, t, n) {
        if (void 0 === t && (t = e.options.addToEnvironment), void 0 !== t && null !== t && !1 !== t) {
            var r = typeof t;
            "string" === r && "head" === t || "tail" === t ? flock.nodeList[t](n, e) : "number" === r ? flock.nodeList.insert(n, e, t) : flock.nodeList.tail(n, e);
        }
    }, flock.node.removeFromEnvironment = function(e, t) {
        flock.nodeList.remove(t, e);
    }, flock.node.play = function(e, t, n) {
        -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail"), t.model.isPlaying || t.play();
    }, fluid.defaults("flock.noteTarget", {
        gradeNames: "fluid.component",
        noteChanges: {
            on: {
                "env.gate": 1
            },
            off: {
                "env.gate": 0
            }
        },
        invokers: {
            set: {
                funcName: "fluid.notImplemented"
            },
            noteOn: {
                func: "{that}.events.noteOn.fire"
            },
            noteOff: {
                func: "{that}.events.noteOff.fire"
            },
            noteChange: {
                funcName: "flock.noteTarget.change",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            }
        },
        events: {
            noteOn: null,
            noteOff: null
        },
        listeners: {
            "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
            "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
        }
    }), flock.noteTarget.change = function(t, n, r) {
        var o = t.options.noteChanges[n], a = e.extend({}, o, r);
        t.set(a);
    }, fluid.defaults("flock.synth", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        rate: flock.rates.AUDIO,
        addToEnvironment: !0,
        mergePolicy: {
            ugens: "nomerge"
        },
        ugens: {
            expander: {
                funcName: "flock.makeUGens",
                args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
            }
        },
        members: {
            rate: "{that}.options.rate",
            audioSettings: "{that}.enviro.audioSystem.model",
            nodeList: "@expand:flock.nodeList()",
            out: "{that}.options.ugens",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.ugens)"
        },
        model: {
            blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
        },
        invokers: {
            set: {
                funcName: "flock.synth.set",
                args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            get: {
                funcName: "flock.input.get",
                args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
            },
            input: {
                funcName: "flock.synth.input",
                args: [ "{arguments}", "{that}.get", "{that}.set" ]
            }
        }
    }), flock.synth.createUGenTree = function(e, t, n) {
        return new flock.UGenTree(e, t, n);
    }, flock.synth.calcBlockSize = function(e, t) {
        return e === flock.rates.AUDIO ? t.blockSize : 1;
    }, flock.synth.set = function(e, t, n, r, o) {
        return flock.input.set(t, n, r, void 0, function(t, n, r, a) {
            return flock.synth.ugenValueParser(e, t, a, o);
        });
    }, flock.synth.input = function(e, t, n) {
        var r = e[0];
        return r ? "string" == typeof r ? e.length < 2 ? t(r) : n.apply(null, e) : flock.isIterable(r) ? t(r) : n.apply(null, e) : void 0;
    }, flock.synth.ugenValueParser = function(e, t, n, r) {
        if (null === t || void 0 === t) return n;
        var o, a, i, u = flock.parse.ugenDef(t, e.enviro, {
            audioSettings: e.audioSettings,
            buses: e.enviro.busManager.buses,
            buffers: e.enviro.buffers
        }), s = flock.isIterable(u) ? u : void 0 !== u ? [ u ] : [], l = flock.isIterable(n) ? n : void 0 !== n ? [ n ] : [], c = Math.min(s.length, l.length), f = r ? "swapTree" : "replaceTree";
        for (o = 0; o < c; o++) a = flock.ugenNodeList[f](e.nodeList, s[o], l[o]);
        for (i = o; i < s.length; i++) a++, flock.ugenNodeList.insertTree(e.nodeList, s[i], a);
        for (i = o; i < l.length; i++) flock.ugenNodeList.removeTree(e.nodeList, l[i]);
        return u;
    }, fluid.defaults("flock.synth.value", {
        gradeNames: [ "flock.synth" ],
        rate: "demand",
        addToEnvironment: !1,
        invokers: {
            value: {
                funcName: "flock.evaluate.synthValue",
                args: [ "{that}" ]
            }
        }
    }), fluid.defaults("flock.synth.frameRate", {
        gradeNames: [ "flock.synth.value" ],
        rate: "scheduled",
        fps: 60,
        members: {
            audioSettings: {
                rates: {
                    scheduled: "{that}.options.fps"
                }
            }
        }
    }), flock.bufferDesc = function() {
        throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.nodeList = function() {
        return {
            nodes: [],
            namedNodes: {}
        };
    }, flock.nodeList.insert = function(e, t, n) {
        return n < 0 && (n = 0), e.nodes.splice(n, 0, t), flock.nodeList.registerNode(e, t), 
        n;
    }, flock.nodeList.registerNode = function(e, t) {
        var n = t.name || t.id;
        n && (e.namedNodes[n] = t);
    }, flock.nodeList.head = function(e, t) {
        return flock.nodeList.insert(e, t, 0);
    }, flock.nodeList.before = function(e, t, n) {
        var r = e.nodes.indexOf(n);
        return flock.nodeList.insert(e, t, r);
    }, flock.nodeList.after = function(e, t, n) {
        var r = e.nodes.indexOf(n) + 1;
        return flock.nodeList.insert(e, t, r);
    }, flock.nodeList.tail = function(e, t) {
        var n = e.nodes.length;
        return flock.nodeList.insert(e, t, n);
    }, flock.nodeList.unregisterNode = function(e, t) {
        var n = t.name || t.id;
        n && delete e.namedNodes[n];
    }, flock.nodeList.isNodeActive = function(e, t) {
        return e.nodes.indexOf(t) > -1;
    }, flock.nodeList.remove = function(e, t) {
        if (e) {
            var n = e.nodes.indexOf(t);
            return n > -1 && (e.nodes.splice(n, 1), flock.nodeList.unregisterNode(e, t)), n;
        }
    }, flock.nodeList.replace = function(e, t, n) {
        var r = e.nodes.indexOf(n);
        return r < 0 ? flock.nodeList.tail(e, t) : (e.nodes[r] = t, flock.nodeList.unregisterNode(e, n), 
        flock.nodeList.registerNode(e, t), r);
    }, flock.nodeList.clearAll = function(e) {
        e.nodes.length = 0;
        for (var t in e.namedNodes) delete e.namedNodes[t];
    }, flock.ugenNodeList = function() {
        return flock.nodeList();
    }, flock.ugenNodeList.insertTree = function(e, t, n) {
        var r, o, a = t.inputs;
        for (r in a) o = a[r], flock.isUGen(o) && (n = flock.ugenNodeList.insertTree(e, o, n), 
        n++);
        return flock.nodeList.insert(e, t, n);
    }, flock.ugenNodeList.removeTree = function(e, t) {
        var n, r, o = t.inputs;
        for (n in o) r = o[n], flock.isUGen(r) && flock.ugenNodeList.removeTree(e, r);
        return flock.nodeList.remove(e, t);
    }, flock.ugenNodeList.tailTree = function(e, t) {
        var n = e.nodes.length;
        return flock.ugenNodeList.insertTree(e, t, n);
    }, flock.ugenNodeList.replaceTree = function(e, t, n) {
        if (!n) return flock.ugenNodeList.tailTree(e, t);
        var r = flock.ugenNodeList.removeTree(e, n);
        return flock.ugenNodeList.insertTree(e, t, r), r;
    }, flock.ugenNodeList.swapTree = function(e, t, n, r) {
        return r ? (flock.ugenNodeList.reattachInputs(e, t, n, r), flock.ugenNodeList.replaceInputs(e, t, n, r)) : t.inputs = n.inputs, 
        flock.nodeList.replace(e, t, n);
    }, flock.ugenNodeList.reattachInputs = function(e, t, n, r) {
        for (var o in n.inputs) r.indexOf(o) < 0 ? flock.ugenNodeList.removeTree(e, n.inputs[o]) : t.inputs[o] = n.inputs[o];
    }, flock.ugenNodeList.replaceInputs = function(e, t, n, r) {
        for (var o in t.inputs) r.indexOf(o) < 0 && flock.ugenNodeList.replaceTree(e, t.inputs[o], n.inputs[o]);
    }, flock.makeUGens = function(e, t, n, r, o) {
        e || fluid.log(fluid.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
        var a = t === flock.rates.SCHEDULED || t === flock.rates.DEMAND;
        return flock.parse.synthDef(e, r, {
            rate: t,
            overrideRate: a,
            visitors: [ flock.makeUGens.visitor(n) ],
            buffers: r.buffers,
            buses: r.busManager.buses,
            audioSettings: o || r.audioSystem.model
        });
    }, flock.makeUGens.visitor = function(e) {
        return function(t) {
            flock.nodeList.tail(e, t);
        };
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.evaluate = {
        synth: function(e) {
            e.genFn(e.nodeList.nodes), e.out && (e.model.value = e.out.model.value);
        },
        synthValue: function(e) {
            return flock.evaluate.synth(e), e.model.value;
        },
        synths: function(e) {
            for (var t = 0; t < e.length; t++) flock.evaluate.synth(e[t]);
        },
        clearBuses: function(e, t, n) {
            for (var r = 0; r < t; r++) for (var o = e[r], a = 0; a < n; a++) o[a] = 0;
        },
        ugens: function(e) {
            for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
        }
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.modelSynth", {
        gradeNames: "flock.synth",
        model: {
            inputs: {}
        },
        modelListeners: {
            inputs: [ {
                funcName: "flock.modelSynth.updateUGens",
                args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
            } ]
        },
        invokers: {
            value: "{that}.events.onEvaluate.fire()"
        },
        events: {
            onEvaluate: null
        },
        listeners: {
            onEvaluate: [ "{that}.genFn({that}.nodeList.nodes)", {
                changePath: "value",
                value: "{that}.out.model.value"
            } ]
        }
    }), flock.modelSynth.updateUGens = function(e, t, n) {
        var r = {};
        flock.modelSynth.flattenModel("", n.value, r), e(r);
    }, flock.modelSynth.shouldFlattenValue = function(e) {
        return fluid.isPrimitive(e) || flock.isIterable(e) || e.ugen;
    }, flock.modelSynth.flattenModel = function(e, t, n) {
        for (var r in t) {
            var o = t[r], a = fluid.pathUtil.composePath(e, r.toString());
            flock.modelSynth.shouldFlattenValue(o) ? n[a] = o : flock.modelSynth.flattenModel(a, o, n);
        }
        return n;
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.synth.group", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        methodEventMap: {
            onSet: "set"
        },
        members: {
            nodeList: "@expand:flock.nodeList()",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.synths)"
        },
        invokers: {
            play: "{that}.events.onPlay.fire",
            pause: "{that}.events.onPause.fire",
            set: "{that}.events.onSet.fire",
            get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
            head: "flock.synth.group.head({arguments}.0, {that})",
            tail: "flock.synth.group.tail({arguments}.0, {that})",
            insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
            before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
            after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
            remove: "{that}.events.onRemove.fire",
            input: {
                funcName: "flock.synth.group.input",
                args: [ "{arguments}", "{that}.get", "{that}.events.onSet.fire" ]
            }
        },
        events: {
            onSet: null,
            onGen: null,
            onPlay: null,
            onPause: null,
            onInsert: null,
            onRemove: null
        },
        listeners: {
            onInsert: [ {
                funcName: "flock.synth.group.bindMethods",
                args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
            }, "flock.synth.group.removeNodeFromEnvironment({arguments}.0)" ],
            onRemove: [ {
                funcName: "flock.synth.group.bindMethods",
                args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
            }, {
                this: "{that}.nodeList",
                method: "remove",
                args: [ "{arguments}.0" ]
            } ]
        }
    }), flock.synth.group.head = function(e, t) {
        flock.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
    }, flock.synth.group.tail = function(e, t) {
        flock.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
    }, flock.synth.group.insert = function(e, t, n) {
        flock.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.before = function(e, t, n) {
        flock.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.after = function(e, t, n) {
        flock.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
    }, flock.synth.group.removeNodeFromEnvironment = function(e) {
        e.removeFromEnvironment();
    }, flock.synth.group.get = function(e, t) {
        var n = t[t.length - 1];
        return n.get.apply(n, e);
    }, flock.synth.group.input = function(e, t, n) {
        return (e.length > 1 ? n : t).apply(null, e);
    }, flock.synth.group.bindMethods = function(e, t, n, r) {
        for (var o in t) {
            var a = e[t[o]];
            (0, n[o][r])(a);
        }
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    fluid.defaults("flock.synth.polyphonic", {
        gradeNames: [ "flock.synth.group" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        noteSpecs: "{that}.options.noteChanges",
        distributeOptions: {
            source: "{that}.options.voiceAllocatorOptions",
            target: "{that flock.synth.voiceAllocator}.options",
            removeSource: !0
        },
        voiceAllocatorOptions: {
            synthDef: "{polyphonic}.options.synthDef",
            maxVoices: "{polyphonic}.options.maxVoices",
            amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
            amplitudeKey: "{polyphonic}.options.amplitudeKey",
            listeners: {
                onCreateVoice: {
                    funcName: "flock.nodeList.tail",
                    args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                }
            }
        },
        components: {
            voiceAllocator: {
                type: "flock.synth.voiceAllocator.lazy"
            }
        },
        invokers: {
            noteChange: {
                funcName: "flock.synth.polyphonic.noteChange",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            createVoice: {
                func: "{voiceAllocator}.createVoice",
                args: [ "{that}.options", "{that}.insert" ]
            }
        },
        listeners: {
            "noteOn.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOn",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ],
            "noteOff.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOff",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ]
        }
    }), flock.synth.polyphonic.noteChange = function(t, n, r, o) {
        var a = t.options.noteChanges[n], i = e.extend({}, a, o);
        r.set(i);
    }, flock.synth.polyphonic.noteOn = function(e, t, n) {
        var r = e.voiceAllocator.getFreeVoice();
        return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = r, 
        e.noteChange("on", r, n), r;
    }, flock.synth.polyphonic.noteOff = function(e, t, n) {
        var r = e.voiceAllocator.activeVoices[t];
        return r ? (e.noteChange("off", r, n), delete e.voiceAllocator.activeVoices[t], 
        e.voiceAllocator.freeVoices.push(r), r) : null;
    }, fluid.defaults("flock.synth.voiceAllocator", {
        gradeNames: [ "fluid.component" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        members: {
            activeVoices: {},
            freeVoices: []
        },
        invokers: {
            createVoice: {
                funcName: "flock.synth.voiceAllocator.createVoice",
                args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
            }
        },
        events: {
            onCreateVoice: null
        }
    }), flock.synth.voiceAllocator.createVoice = function(e, t) {
        var n, r = flock.synth({
            synthDef: e.synthDef,
            addToEnvironment: !1
        }), o = e.amplitudeNormalizer, a = e.amplitudeKey;
        return o && ("function" == typeof o ? o(r, a) : "static" === o && (n = 1 / e.maxVoices, 
        r.input(a, n))), t(r), r;
    }, fluid.defaults("flock.synth.voiceAllocator.lazy", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: {
                funcName: "flock.synth.voiceAllocator.lazy.get",
                args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
            }
        }
    }), flock.synth.voiceAllocator.lazy.get = function(e, t, n, r) {
        return e.length > 1 ? e.pop() : Object.keys(t).length > r ? null : n();
    }, fluid.defaults("flock.synth.voiceAllocator.pool", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
        }
    }), flock.synth.voiceAllocator.pool.get = function(e) {
        if (e.length > 0) return e.pop();
    }, flock.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
        for (var r = 0; r < n; r++) e[r] = t();
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.band", {
        gradeNames: [ "fluid.component" ],
        synthGrade: "flock.noteTarget",
        invokers: {
            play: {
                func: "{that}.events.onPlay.fire"
            },
            pause: {
                func: "{that}.events.onPause.fire"
            },
            set: {
                func: "{that}.events.onSet.fire"
            },
            getSynths: {
                funcName: "fluid.queryIoCSelector",
                args: [ "{that}", "{that}.options.synthGrade" ]
            }
        },
        events: {
            onPlay: null,
            onPause: null,
            onSet: null
        },
        distributeOptions: [ {
            source: "{that}.options.synthListeners",
            removeSource: !0,
            target: "{that flock.synth}.options.listeners"
        } ],
        synthListeners: {
            "{band}.events.onPlay": {
                func: "{that}.play"
            },
            "{band}.events.onPause": {
                func: "{that}.pause"
            },
            "{band}.events.onSet": {
                func: "{that}.set"
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    function e() {
        function e(e, n) {
            r.value = n, r.then = "reject" === e ? function(e, t) {
                return t(n), this;
            } : function(e) {
                return e(n), this;
            }, r.resolve = r.reject = function() {
                throw new Error("Promise already completed");
            }, t(e, n);
        }
        function t(e, t) {
            var r, o;
            for (r = 0; r < n.length; r++) (o = n[r])[e] && o[e](t);
            n = null;
        }
        var n = [], r = {
            state: "pending",
            value: void 0,
            resolve: function(t) {
                e("resolve", t), r.state = "fulfilled";
            },
            reject: function(t) {
                e("reject", t), r.state = "rejected";
            },
            then: function(e, t) {
                return n ? n.push({
                    resolve: e,
                    reject: t
                }) : ("fulfilled" === r.state ? e : t)(r.value), this;
            },
            safe: {
                then: function(e, t) {
                    return r.then(e, t), this;
                }
            }
        };
        return r;
    }
    fluid.defaults("flock.promise", {
        gradeNames: [ "fluid.component" ],
        members: {
            promise: {
                expander: {
                    funcName: "flock.promise.make"
                }
            }
        }
    }), flock.promise.make = function() {
        return new e();
    }, flock.bufferDesc = function(e, t, n) {
        return (flock.platform.isWebAudio && e instanceof AudioBuffer ? flock.bufferDesc.fromAudioBuffer : flock.isIterable(e) ? flock.bufferDesc.fromChannelArray : flock.bufferDesc.expand)(e, t, n);
    }, flock.bufferDesc.inferFormat = function(e, t, n) {
        var r = e.format, o = e.data;
        return r.sampleRate = t || r.sampleRate || 44100, r.numChannels = n || r.numChannels || e.data.channels.length, 
        r.numSampleFrames = r.numSampleFrames || o.channels.length > 0 ? o.channels[0].length : 0, 
        r.duration = r.numSampleFrames / r.sampleRate, e;
    }, flock.bufferDesc.fromChannelArray = function(e, t, n) {
        e instanceof Float32Array && (e = [ e ]);
        var r = {
            container: {},
            format: {
                numChannels: n,
                sampleRate: t,
                numSampleFrames: e[0].length
            },
            data: {
                channels: e
            }
        };
        return flock.bufferDesc.inferFormat(r, t, n);
    }, flock.bufferDesc.expand = function(e, t, n) {
        if (e = e || {
            data: {
                channels: []
            }
        }, e.container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
        e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
        e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
        return flock.bufferDesc.inferFormat(e, t, n);
    }, flock.bufferDesc.fromAudioBuffer = function(e) {
        var t, n = {
            container: {},
            format: {
                sampleRate: e.sampleRate,
                numChannels: e.numberOfChannels,
                numSampleFrames: e.length,
                duration: e.duration
            },
            data: {
                channels: []
            }
        };
        for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
        return n;
    }, flock.bufferDesc.toAudioBuffer = function(e, t) {
        for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), r = 0; r < t.format.numChannels; r++) n.copyToChannel(t.data.channels[r], r);
        return n;
    }, fluid.defaults("flock.bufferSource", {
        gradeNames: [ "fluid.modelComponent" ],
        sampleRate: "{enviro}.audioSystem.model.sampleRate",
        model: {
            state: "start",
            src: null
        },
        components: {
            bufferPromise: {
                createOnEvent: "onRefreshPromise",
                type: "flock.promise",
                options: {
                    listeners: {
                        onCreate: {
                            this: "{that}.promise",
                            method: "then",
                            args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                        }
                    }
                }
            }
        },
        invokers: {
            get: {
                funcName: "flock.bufferSource.get",
                args: [ "{that}", "{arguments}.0" ]
            },
            set: {
                funcName: "flock.bufferSource.set",
                args: [ "{that}", "{arguments}.0" ]
            },
            error: {
                funcName: "flock.bufferSource.error",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                funcName: "{that}.events.onRefreshPromise.fire"
            },
            onRefreshPromise: {
                changePath: "state",
                value: "start"
            },
            onFetch: {
                changePath: "state",
                value: "in-progress"
            },
            afterFetch: [ {
                changePath: "state",
                value: "fetched"
            }, {
                funcName: "{that}.events.onBufferUpdated.fire",
                args: [ "{arguments}.0" ]
            } ],
            onBufferUpdated: "{enviro}.registerBuffer({arguments}.0)",
            onError: {
                changePath: "state",
                value: "error"
            }
        },
        events: {
            onRefreshPromise: null,
            onError: null,
            onFetch: null,
            afterFetch: null,
            onBufferUpdated: null
        }
    }), flock.bufferSource.get = function(e, t) {
        return "in-progress" === e.model.state || t.src === e.model.src && !t.replace ? e.bufferPromise.promise : (t.src && ("fetched" !== e.model.state && "errored" !== e.model.state || e.model.src === t.src && !t.replace || e.events.onRefreshPromise.fire(), 
        "start" === e.model.state && (e.model.src = t.src, e.events.onFetch.fire(t), flock.audio.decode({
            src: t.src,
            sampleRate: e.options.sampleRate,
            success: function(n) {
                t.id && (n.id = t.id), e.set(n);
            },
            error: e.error
        }))), e.bufferPromise.promise);
    }, flock.bufferSource.set = function(e, t) {
        var n = e.model.state;
        return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
        e.bufferPromise.promise;
    }, flock.bufferSource.error = function(e, t) {
        return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
    }, fluid.defaults("flock.bufferLoader", {
        gradeNames: [ "fluid.component" ],
        bufferDefs: [],
        members: {
            buffers: [],
            bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
        },
        components: {
            enviro: "{flock.enviro}"
        },
        events: {
            afterBuffersLoaded: null,
            onError: null
        },
        listeners: {
            "onCreate.loadBuffers": {
                funcName: "flock.bufferLoader.loadBuffers",
                args: [ "{that}" ]
            },
            "onError.logError": {
                funcName: "flock.log.fail"
            }
        }
    }), flock.bufferLoader.idFromURL = function(e) {
        var t = e.lastIndexOf("/"), n = t > -1 ? t + 1 : 0, r = e.lastIndexOf("."), o = r > -1 ? r : e.length;
        return e.substring(n, o);
    }, flock.bufferLoader.idsFromURLs = function(e) {
        return fluid.transform(e, flock.bufferLoader.idFromURL);
    }, flock.bufferLoader.expandFileSequence = function(e) {
        e = e || [];
        var t, n, r, o = [];
        for (t = 0; t < e.length; t++) n = e[t], r = flock.bufferLoader.idFromURL(n), o.push({
            id: r,
            url: n
        });
        return o;
    }, flock.bufferLoader.expandBufferDef = function(e) {
        return "string" == typeof e && (e = {
            url: e
        }), void 0 === e.id && void 0 !== e.url && (e.id = flock.bufferLoader.idFromURL(e.url)), 
        e;
    }, flock.bufferLoader.expandBufferDefs = function(e) {
        return e ? (e = fluid.makeArray(e), fluid.transform(e, flock.bufferLoader.expandBufferDef)) : [];
    }, flock.bufferLoader.loadBuffer = function(e, t, n) {
        try {
            flock.parse.bufferForDef(e, t, n.enviro);
        } catch (e) {
            n.events.onError.fire(e.message);
        }
    }, flock.bufferLoader.loadBuffers = function(e) {
        var t = 1, n = {
            setBuffer: function(r) {
                if (e.buffers.push(r), e.buffers.length === e.options.bufferDefs.length) e.events.afterBuffersLoaded.fire(e.buffers); else if (t < e.bufferDefs.length) {
                    var o = e.bufferDefs[t];
                    flock.bufferLoader.loadBuffer(o, n, e), t++;
                }
            }
        };
        flock.bufferLoader.loadBuffer(e.bufferDefs[0], n, e);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.parse"), flock.parse.synthDef = function(e, t, n) {
        return e || (e = []), flock.parse.synthDef.hasOutUGen(e) || (e = flock.parse.synthDef.makeOutUGenDef(e, n)), 
        flock.parse.ugenForDef(e, t, n);
    }, flock.parse.synthDef.hasOutUGen = function(e) {
        return !flock.isIterable(e) && (e.id === flock.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
    }, flock.parse.synthDef.makeOutUGenDef = function(e, t) {
        return e = {
            id: flock.OUT_UGEN_ID,
            ugen: "flock.ugen.valueOut",
            inputs: {
                sources: e
            }
        }, t.rate === flock.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, 
        e.inputs.expand = t.audioSettings.chans), e;
    }, flock.parse.makeUGen = function(t, n, r, o) {
        var a = o.audioSettings.rates, i = o.audioSettings.blockSize;
        if (t.rate || (t.rate = flock.rates.AUDIO), !flock.hasValue(flock.rates, t.rate) && (flock.fail("An invalid rate was specified for a unit generator. ugenDef was: " + fluid.prettyPrintJSON(t)), 
        !flock.debug.failHard)) {
            var u = t.rate;
            t.rate = flock.rates.AUDIO, flock.log.warn("Overriding invalid unit generator rate. Rate is now '" + t.rate + "'; was: " + fluid.prettyPrintJSON(u));
        }
        var s;
        s = t.options && void 0 !== t.options.sampleRate ? t.options.sampleRate : a[t.rate], 
        t.options = e.extend(!0, {}, t.options, {
            sampleRate: s,
            rate: t.rate,
            audioSettings: {
                rates: a,
                blockSize: i
            }
        });
        var l, c = t.rate === flock.rates.AUDIO ? i : 1;
        if (flock.hasTag(t.options, "flock.ugen.multiChannelOutput")) {
            var f = t.options.numOutputs || 1;
            l = [];
            for (var d = 0; d < f; d++) l.push(new Float32Array(c));
        } else l = new Float32Array(c);
        var p = fluid.copy(t.options);
        return p.buffers = o.buffers, p.buses = o.buses, p.enviro = r, flock.invoke(void 0, t.ugen, [ n, l, p ]);
    }, flock.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], flock.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
    flock.parse.expandInputs = function(e) {
        if (e.inputs) return e;
        var t, n = {};
        for (t in e) -1 === flock.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
        return e.inputs = n, e;
    }, flock.parse.ugenDefForConstantValue = function(e) {
        return {
            ugen: "flock.ugen.value",
            rate: flock.rates.CONSTANT,
            inputs: {
                value: e
            }
        };
    }, flock.parse.expandValueDef = function(e) {
        var t = typeof e;
        if ("number" === t) return flock.parse.ugenDefForConstantValue(e);
        if ("object" === t) return e;
        throw new Error("Invalid value type found in ugen definition. UGenDef was: " + fluid.prettyPrintJSON(e));
    }, flock.parse.rateMap = {
        ar: flock.rates.AUDIO,
        kr: flock.rates.CONTROL,
        sr: flock.rates.SCHEDULED,
        dr: flock.rates.DEMAND,
        cr: flock.rates.CONSTANT
    }, flock.parse.expandRate = function(e, t) {
        return e.rate = flock.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== flock.rates.CONSTANT && (e.rate = t.rate), 
        e;
    }, flock.parse.ugenDef = function(e, t, n) {
        return (flock.isIterable(e) ? flock.parse.ugensForDefs : flock.parse.ugenForDef)(e, t, n);
    }, flock.parse.ugenDef.mergeOptions = function(t) {
        var n = flock.ugenDefaults(t.ugen) || {};
        return n = fluid.copy(n), n.options = n.ugenOptions, delete n.ugenOptions, e.extend(!0, {}, n, t);
    }, flock.parse.ugensForDefs = function(e, t, n) {
        var r, o = [];
        for (r = 0; r < e.length; r++) o[r] = flock.parse.ugenForDef(e[r], t, n);
        return o;
    }, flock.parse.ugenForDef = function(t, n, r) {
        n = n || flock.environment;
        var o = r = e.extend(!0, {
            audioSettings: n.audioSystem.model,
            buses: n.busManager.buses,
            buffers: n.buffers
        }, r), a = o.visitors, i = o.audioSettings.rates;
        if (t = flock.parse.expandValueDef(t), flock.isIterable(t)) return flock.parse.ugensForDefs(t, n, r);
        t = flock.parse.expandInputs(t), flock.parse.expandRate(t, r);
        var u, s = (t = flock.parse.ugenDef.mergeOptions(t, r)).inputs, l = {};
        for (u in s) {
            var c = s[u];
            null !== c && (l[u] = flock.input.shouldExpand(u, t) ? flock.parse.ugenForDef(c, n, r) : c);
        }
        if (!t.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + fluid.prettyPrintJSON(t));
        var f = flock.parse.makeUGen(t, l, n, r);
        if (t.id && (f.id = t.id), f.options.ugenDef = t, a) for (var d = 0; d < a.length; d++) a[d](f, t, i);
        return f;
    }, flock.parse.expandBufferDef = function(e) {
        return "string" == typeof e ? {
            id: e
        } : flock.isIterable(e) || e.data || e.format ? flock.bufferDesc(e) : e;
    }, flock.parse.bufferForDef = function(e, t, n) {
        (e = flock.parse.expandBufferDef(e)).data && e.data.channels ? (e = flock.bufferDesc(e), 
        flock.parse.bufferForDef.resolveBuffer(e, t, n)) : flock.parse.bufferForDef.resolveDef(e, t, n);
    }, flock.parse.bufferForDef.createBufferSource = function(e) {
        return flock.bufferSource({
            sampleRate: e.audioSystem.model.sampleRate
        });
    }, flock.parse.bufferForDef.findSource = function(e, t) {
        var n;
        return t && e.id ? (n = t.bufferSources[e.id]) || (n = flock.parse.bufferForDef.createBufferSource(t), 
        t.bufferSources[e.id] = n) : n = flock.parse.bufferForDef.createBufferSource(t), 
        n;
    }, flock.parse.bufferForDef.bindToPromise = function(e, t, n) {
        var r = function(e) {
            t.events.onBufferUpdated.addListener(r), n && n.setBuffer(e);
        };
        e.then(r, function(e) {
            throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
            new Error("Error while resolving buffer " + t.model.src + ": " + e);
        });
    }, flock.parse.bufferForDef.resolveDef = function(e, t, n) {
        var r, o = flock.parse.bufferForDef.findSource(e, n);
        e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
        r = o.get(e), flock.parse.bufferForDef.bindToPromise(r, o, t);
    }, flock.parse.bufferForDef.resolveBuffer = function(e, t, n) {
        var r = flock.parse.bufferForDef.findSource(e, n), o = r.set(e);
        flock.parse.bufferForDef.bindToPromise(o, r, t);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = "undefined" != typeof window ? window.atob : require("atob");
    flock.applyDeferred = function(e, t, n) {
        e && (n = void 0 === n ? 0 : n, setTimeout(function() {
            e.apply(null, t);
        }, n));
    }, fluid.registerNamespace("flock.net"), flock.net.readBufferFromUrl = function(e) {
        var t = e.src, n = new XMLHttpRequest();
        n.onreadystatechange = function() {
            if (4 === n.readyState) if (flock.net.isXHRSuccessful(n)) e.success(n.response, flock.file.parseFileExtension(t)); else {
                if (!e.error) throw new Error(n.statusText);
                e.error(n.statusText);
            }
        }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
        n.send(e.data);
    }, flock.net.isXHRSuccessful = function(e) {
        return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
    }, fluid.registerNamespace("flock.file"), flock.file.mimeTypes = {
        "audio/wav": "wav",
        "audio/x-wav": "wav",
        "audio/wave": "wav",
        "audio/x-aiff": "aiff",
        "audio/aiff": "aiff",
        "sound/aiff": "aiff"
    }, flock.file.typeAliases = {
        aif: "aiff",
        wave: "wav"
    }, flock.file.parseFileExtension = function(e) {
        var t, n = e.lastIndexOf(".");
        if (!(n < 0)) return t = e.substring(n + 1), t = t.toLowerCase(), flock.file.typeAliases[t] || t;
    }, flock.file.parseMIMEType = function(e) {
        return flock.file.mimeTypes[e];
    }, flock.file.stringToBuffer = function(e) {
        var t, n = e.length, r = new ArrayBuffer(n), o = new Uint8Array(r);
        for (t = 0; t < n; t++) o[t] = e.charCodeAt(t);
        return o.buffer;
    }, flock.file.readBufferFromDataUrl = function(t) {
        var n = t.src, r = n.indexOf(","), o = n.substring(0, r), a = n.substring(r + 1), i = o.indexOf(";base64"), u = i > -1, s = n.indexOf("data:") + 5, l = u ? i : r, c = n.substring(s, l);
        u && (a = e(a)), flock.applyDeferred(function() {
            var e = flock.file.stringToBuffer(a);
            t.success(e, flock.file.parseMIMEType(c));
        });
    }, flock.file.readBufferFromFile = function(e) {
        var t = new FileReader();
        return t.onload = function(t) {
            e.success(t.target.result, flock.file.parseFileExtension(e.src.name));
        }, t.readAsArrayBuffer(e.src), t;
    }, fluid.registerNamespace("flock.audio"), flock.audio.loadBuffer = function(e) {
        var t = e.src || e.url;
        t && (t instanceof ArrayBuffer && flock.applyDeferred(e.success, [ t, e.type ]), 
        flock.audio.loadBuffer.readerForSource(t)(e));
    }, flock.audio.loadBuffer.readerForSource = function(e) {
        return "undefined" != typeof File && e instanceof File ? flock.file.readBufferFromFile : 0 === e.indexOf("data:") ? flock.file.readBufferFromDataUrl : flock.net.readBufferFromUrl;
    }, flock.audio.decode = function(e) {
        var t = e.success;
        e.success = function(n, r) {
            var o = flock.audio.decoderStrategies, a = o[r] || o.default;
            e.decoder && (a = "string" == typeof e.decoder ? fluid.getGlobalValue(e.decoder) : e.decoder), 
            a({
                rawData: n,
                type: r,
                success: t,
                error: e.error,
                sampleRate: e.sampleRate
            });
        }, flock.audio.loadBuffer(e);
    }, flock.audio.decode.webAudio = function(e) {
        flock.webAudio.audioSystem.audioContextSingleton.decodeAudioData(e.rawData, function(t) {
            var n = flock.bufferDesc.fromAudioBuffer(t);
            e.success(n);
        }, e.error);
    }, flock.audio.decoderStrategies = {
        default: flock.audio.decode.webAudio
    }, flock.audio.registerDecoderStrategy = function(e, t) {
        if (e) if ("object" != typeof e) "string" == typeof t && (t = fluid.getGlobalValue(t)), 
        flock.audio.decoderStrategies[e] = t; else for (var n in e) flock.audio.decoderStrategies[n] = e[n];
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
    fluid.registerNamespace("flock.audio.convert"), flock.audio.convert.maxFloatValue = function(e) {
        return 1 - 1 / e.scale;
    }, flock.audio.convert.pcm = {
        int8: {
            scale: 128,
            setter: "setInt8",
            width: 1
        },
        int16: {
            scale: 32768,
            setter: "setInt16",
            width: 2
        },
        int32: {
            scale: 2147483648,
            setter: "setInt32",
            width: 4
        },
        float32: {
            scale: 1,
            setter: "setFloat32",
            width: 4
        }
    };
    for (var t in flock.audio.convert.pcm) {
        var n = flock.audio.convert.pcm[t];
        n.maxFloatValue = flock.audio.convert.maxFloatValue(n);
    }
    flock.audio.convert.specForPCMType = function(e) {
        var t = "string" == typeof e ? flock.audio.convert.pcm[e] : e;
        return t || flock.fail("Flocking does not support " + e + " format PCM wave files."), 
        t;
    }, flock.audio.convert.floatToInt = function(e, t) {
        var n = Math.min(t.maxFloatValue, e);
        return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
    }, flock.audio.convert.floatsToInts = function(t, n) {
        if (t) {
            for (var r = "Int" + 8 * n.width + "Array", o = new e[r](t.length), a = 0; a < t.length; a++) {
                var i = t[a], u = flock.audio.convert.floatToInt(i, n);
                o[a] = u;
            }
            return o;
        }
    }, flock.audio.convert.intToFloat = function(e, t) {
        return e / t.scale;
    }, flock.audio.convert.intsToFloats = function(e, t) {
        if (e) {
            for (var n = new Float32Array(e.length), r = 0; r < e.length; r++) {
                var o = e[r], a = flock.audio.convert.intToFloat(o, t);
                n[r] = a;
            }
            return n;
        }
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.audio.encode"), flock.audio.interleave = function(e) {
        var t, n, r = e.format.numSampleFrames, o = e.data.channels, a = e.format.numChannels, i = r * a, u = new Float32Array(i), s = 0;
        for (t = 0; t < r; t++) for (n = 0; n < a; n++) u[s] = o[n][t], s++;
        return u;
    }, flock.audio.encode = function(e, t, n) {
        return "wav" !== (t = t || "wav").toLowerCase() && flock.fail("Flocking currently only supports encoding WAVE files."), 
        flock.audio.encode.wav(e, n);
    }, flock.audio.encode.writeFloat32Array = function(e, t, n) {
        for (var r = 0; r < n.length; r++) t.setFloat32(e, n[r], !0), e += 4;
        return t;
    }, flock.audio.encode.setString = function(e, t, n) {
        for (var r = 0; r < n.length; r++) e.setUint8(t + r, n.charCodeAt(r));
    }, flock.audio.encode.setBytes = function(e, t, n) {
        for (var r = 0; r < n.length; r++) e.setUint8(t + r, n[r]);
    }, flock.audio.encode.writeAsPCM = function(e, t, n, r) {
        if ("setFloat32" === e.setter && r instanceof Float32Array) return flock.audio.encode.writeFloat32Array(t, n, r);
        for (var o = 0; o < r.length; o++) {
            var a = flock.audio.convert.floatToInt(r[o], e);
            n[e.setter](t, a, !0), t += e.width;
        }
        return n;
    }, flock.audio.encode.wav = function(e, t) {
        t = t || flock.audio.convert.pcm.int16;
        var n = flock.audio.convert.specForPCMType(t), r = flock.audio.interleave(e), o = e.format.numChannels, a = e.format.sampleRate, i = "setFloat32" !== n.setter, u = 16, s = 1, l = r.length * n.width, c = 8 + l, f = n.width * o, d = 8 * n.width;
        if (o > 2 || !i) {
            u += 12, o > 2 ? (u += 24, s = 65534) : (u += 2, s = 3);
        }
        var p = 12 + u + c, m = 8 + p, g = new ArrayBuffer(m), h = new DataView(g);
        flock.audio.encode.setString(h, 0, "RIFF"), h.setUint32(4, p, !0), flock.audio.encode.setString(h, 8, "WAVE"), 
        flock.audio.encode.setString(h, 12, "fmt "), h.setUint32(16, u, !0), h.setUint16(20, s, !0), 
        h.setUint16(22, o, !0), h.setUint32(24, a, !0), h.setUint32(28, a * f, !0), h.setUint16(32, f, !0), 
        h.setUint16(34, d, !0);
        var v = 36;
        return 3 === s ? (h.setUint16(v, 0, !0), v += 2, v = flock.audio.encode.wav.writeFactChunk(h, v, e.format.numSampleFrames)) : 65534 === s && (h.setUint16(v, 22, !0), 
        v += 2, v = flock.audio.encode.wav.additionalFormat(v, h, d, i), v = flock.audio.encode.wav.writeFactChunk(h, v, e.format.numSampleFrames)), 
        flock.audio.encode.wav.writeDataChunk(n, v, h, r, l), h.buffer;
    }, flock.audio.encode.wav.subformats = {
        pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
        float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
    }, flock.audio.encode.wav.additionalFormat = function(e, t, n, r) {
        t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
        var o = flock.audio.encode.wav.subformats[r ? "pcm" : "float"];
        return flock.audio.encode.setBytes(t, e, o), e += 16;
    }, flock.audio.encode.wav.writeFactChunk = function(e, t, n) {
        return flock.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), 
        t += 4, e.setUint32(t, n, !0), t += 4;
    }, flock.audio.encode.wav.writeDataChunk = function(e, t, n, r, o) {
        flock.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, o, !0), t += 4, 
        flock.audio.encode.writeAsPCM(e, t, n, r);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.shim = {
        URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.worker = function(e) {
        var t, n, r = typeof e;
        if ("function" === r) e = "(" + e.toString() + ")();"; else if ("string" !== r) throw new Error("A flock.worker must be initialized with a String or a Function.");
        return window.Blob ? (n = new Blob([ e ], {
            type: "text/javascript"
        }), t = flock.shim.URL.createObjectURL(n)) : t = "data:text/javascript;base64," + window.btoa(e), 
        new Worker(t);
    }, fluid.registerNamespace("flock.scheduler"), fluid.defaults("flock.scheduler.clock", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            end: "fluid.mustBeOverridden"
        },
        events: {
            tick: null
        },
        listeners: {
            "onDestroy.end": "{that}.end()"
        }
    }), fluid.defaults("flock.scheduler.intervalClock", {
        gradeNames: [ "flock.scheduler.clock" ],
        members: {
            scheduled: {}
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.intervalClock.schedule",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
            },
            clear: {
                funcName: "flock.scheduler.intervalClock.clear",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            clearAll: {
                funcName: "flock.scheduler.intervalClock.clearAll",
                args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            end: "{that}.clearAll"
        }
    }), flock.scheduler.intervalClock.schedule = function(e, t, n) {
        var r = setInterval(function() {
            n(e);
        }, e);
        t[e] = r;
    }, flock.scheduler.intervalClock.clear = function(e, t) {
        var n = t[e];
        clearInterval(n), delete t[e];
    }, flock.scheduler.intervalClock.clearAll = function(e, t) {
        for (var n in e) flock.scheduler.intervalClock.clear(n, e, t);
    }, fluid.defaults("flock.scheduler.scheduleClock", {
        gradeNames: [ "flock.scheduler.clock" ],
        members: {
            scheduled: []
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.scheduleClock.schedule",
                args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
            },
            clear: {
                funcName: "flock.scheduler.scheduleClock.clear",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            clearAll: {
                funcName: "flock.scheduler.scheduleClock.clearAll",
                args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
            },
            end: "{that}.clearAll"
        }
    }), flock.scheduler.scheduleClock.schedule = function(e, t, n) {
        var r;
        r = setTimeout(function() {
            clearTimeout(r), n.tick.fire(e);
        }, e), t.push(r);
    }, flock.scheduler.scheduleClock.clear = function(e, t, n) {
        (t = void 0 === t ? n.indexOf(e) : t) > -1 && (n.splice(t, 1), clearTimeout(e));
    }, flock.scheduler.scheduleClock.clearAll = function(e) {
        for (var t = 0; t < e.length; t++) {
            var n = e[t];
            clearTimeout(n);
        }
        e.length = 0;
    }, fluid.defaults("flock.scheduler.webWorkerClock", {
        gradeNames: [ "fluid.component" ],
        members: {
            worker: {
                expander: {
                    funcName: "flock.worker",
                    args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
                }
            }
        },
        invokers: {
            postToWorker: {
                funcName: "flock.scheduler.webWorkerClock.postToWorker",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
            },
            schedule: "{that}.postToWorker(schedule, {arguments}.0)",
            clear: "{that}.postToWorker(clear, {arguments}.0)",
            clearAll: "{that}.postToWorker(clearAll)",
            end: "{that}.postToWorker(end)"
        },
        events: {
            tick: null
        },
        listeners: {
            onCreate: {
                funcName: "flock.scheduler.webWorkerClock.init",
                args: [ "{that}" ]
            },
            "onDestroy.clearAllScheduled": "{that}.clearAll",
            "onDestroy.endWorker": {
                priority: "after:clearAllScheduled",
                func: "{that}.end"
            }
        },
        startMsg: {
            msg: "start",
            value: "{that}.options.clockType"
        },
        messages: {
            schedule: {
                msg: "schedule"
            },
            clear: {
                msg: "clear"
            },
            clearAll: {
                msg: "clearAll"
            },
            end: {
                msg: "end"
            }
        }
    }), flock.scheduler.webWorkerClock.init = function(e) {
        e.worker.addEventListener("message", function(t) {
            e.events.tick.fire(t.data.value);
        }, !1), e.worker.postMessage(e.options.startMsg);
    }, flock.scheduler.webWorkerClock.postToWorker = function(e, t, n, r) {
        var o = n[e];
        void 0 !== t && (o.value = t), r.postMessage(o);
    }, flock.scheduler.webWorkerClock.workerImpl = function() {
        var e = e || {};
        e.worker = e.worker || {}, e.worker.clock = function() {
            var e = {};
            return e.tick = function(e) {
                self.postMessage({
                    msg: "tick",
                    value: e
                });
            }, e;
        }, e.worker.intervalClock = function() {
            var t = e.worker.clock();
            return t.scheduled = {}, t.schedule = function(e) {
                var n = setInterval(function() {
                    t.tick(e);
                }, e);
                t.scheduled[e] = n;
            }, t.clear = function(e) {
                var n = t.scheduled[e];
                clearInterval(n), delete t.scheduled[e];
            }, t.clearAll = function() {
                for (var e in t.scheduled) t.clear(e);
            }, t;
        }, e.worker.scheduleClock = function() {
            var t = e.worker.clock();
            return t.scheduled = [], t.schedule = function(e) {
                var n;
                n = setTimeout(function() {
                    t.clear(n), t.tick(e);
                }, e), t.scheduled.push(n);
            }, t.clear = function(e, n) {
                (n = void 0 === n ? t.scheduled.indexOf(e) : n) > -1 && t.scheduled.splice(n, 1), 
                clearTimeout(e);
            }, t.clearAll = function() {
                for (var e = 0; e < t.scheduled.length; e++) {
                    var n = t.scheduled[e];
                    clearTimeout(n);
                }
                t.scheduled.length = 0;
            }, t;
        }, self.addEventListener("message", function(t) {
            "start" === t.data.msg ? e.clock = e.worker[t.data.value]() : "end" === t.data.msg ? e.clock && (e.clock.clearAll(), 
            self.close()) : e.clock && e.clock[t.data.msg](t.data.value);
        }, !1);
    }, fluid.defaults("flock.scheduler.webWorkerIntervalClock", {
        gradeNames: [ "flock.scheduler.webWorkerClock" ],
        clockType: "intervalClock"
    }), fluid.defaults("flock.scheduler.webWorkerScheduleClock", {
        gradeNames: [ "flock.scheduler.webWorkerClock" ],
        clockType: "scheduleClock"
    }), fluid.defaults("flock.scheduler", {
        gradeNames: [ "fluid.component" ],
        events: {
            onScheduled: null,
            onFinished: null,
            onClearAll: null
        },
        listeners: {
            "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
        }
    }), flock.scheduler.addListener = function(e, t, n) {
        return t.push(e), n(e), e;
    }, flock.scheduler.removeListener = function(e, t, n) {
        if (e) {
            var r = t.indexOf(e);
            r > -1 ? (t.splice(r, 1), n(e)) : e.wrappedListener && flock.scheduler.removeListener(e.wrappedListener, t, n);
        }
    }, fluid.defaults("flock.scheduler.repeat", {
        gradeNames: [ "flock.scheduler" ],
        members: {
            listeners: {}
        },
        components: {
            clock: {
                type: "flock.scheduler.webWorkerIntervalClock"
            }
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.repeat.schedule",
                args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
            },
            clear: "{that}.events.onFinished.fire",
            clearAll: {
                funcName: "flock.scheduler.repeat.clearAll",
                args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
            },
            clearInterval: {
                funcName: "flock.scheduler.repeat.clearInterval",
                args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
            },
            addIntervalListener: {
                funcName: "flock.scheduler.repeat.addIntervalListener",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
            },
            removeIntervalListener: {
                funcName: "flock.scheduler.repeat.removeIntervalListener",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
            }
        },
        listeners: {
            onScheduled: [ "{that}.addIntervalListener({arguments}.0, {arguments}.1)", "{that}.clock.schedule({arguments}.0)" ],
            onFinished: [ "{that}.removeIntervalListener({arguments}.0, {arguments}.1)" ]
        }
    }), flock.scheduler.repeat.intervalListeners = function(e, t) {
        return t[e];
    }, flock.scheduler.repeat.addIntervalListener = function(e, t, n, r) {
        var o = flock.scheduler.repeat.intervalListeners(e, n);
        flock.scheduler.addListener(t, o, r);
    }, flock.scheduler.repeat.removeIntervalListener = function(e, t, n, r) {
        var o = flock.scheduler.repeat.intervalListeners(e, n);
        flock.scheduler.removeListener(t, o, r);
    }, flock.scheduler.repeat.schedule = function(e, t, n, r, o, a) {
        e = n.value(e), t = flock.scheduler.async.prepareListener(t, r);
        var i = flock.scheduler.repeat.wrapValueListener(e, t);
        return flock.scheduler.repeat.addInterval(e, o), a(e, i), i;
    }, flock.scheduler.repeat.wrapValueListener = function(e, t) {
        var n = function(n) {
            n === e && t(n);
        };
        return n.wrappedListener = t, n;
    }, flock.scheduler.repeat.addInterval = function(e, t) {
        var n = t[e];
        n || (n = t[e] = []);
    }, flock.scheduler.repeat.clearAll = function(e, t, n) {
        for (var r in e) flock.scheduler.repeat.clearInterval(r, e, t);
        n();
    }, flock.scheduler.repeat.clearInterval = function(e, t, n) {
        var r = t[e];
        if (r) for (var o = 0; o < r.length; o++) n(e, r[o]);
    }, fluid.defaults("flock.scheduler.once", {
        gradeNames: [ "flock.scheduler" ],
        members: {
            listeners: []
        },
        components: {
            clock: {
                type: "flock.scheduler.webWorkerScheduleClock"
            }
        },
        invokers: {
            schedule: {
                funcName: "flock.scheduler.once.schedule",
                args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
            },
            clear: "{that}.events.onFinished.fire",
            clearAll: {
                funcName: "flock.scheduler.once.clearAll",
                args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
            }
        },
        listeners: {
            onScheduled: [ {
                funcName: "flock.scheduler.addListener",
                args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
            }, {
                func: "{that}.clock.schedule",
                args: [ "{arguments}.0" ]
            } ],
            onFinished: {
                funcName: "flock.scheduler.removeListener",
                args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
            }
        }
    }), flock.scheduler.once.wrapValueListener = function(e, t, n) {
        var r = function(o) {
            o === e && (t(o), n(r));
        };
        return r.wrappedListener = t, r;
    }, flock.scheduler.once.schedule = function(e, t, n, r, o, a) {
        e = n.value(e), t = flock.scheduler.async.prepareListener(t, r);
        var i = flock.scheduler.once.wrapValueListener(e, t, o);
        return a(e, i), i;
    }, flock.scheduler.once.clearAll = function(e, t, n) {
        for (var r = 0; r < e.length; r++) t(e[r]);
        n();
    }, fluid.defaults("flock.scheduler.async", {
        gradeNames: [ "fluid.component" ],
        subSchedulerOptions: {
            components: {
                timeConverter: "{async}.timeConverter"
            },
            listeners: {
                "{async}.events.onClear": "{that}.clear()",
                "{async}.events.onClearAll": "{that}.clearAll()",
                "{async}.events.onEnd": "{that}.clock.end()"
            }
        },
        distributeOptions: {
            source: "{that}.options.subSchedulerOptions",
            removeSource: !0,
            target: "{that flock.scheduler}.options"
        },
        components: {
            timeConverter: {
                type: "flock.convert.seconds"
            },
            onceScheduler: {
                type: "flock.scheduler.once"
            },
            repeatScheduler: {
                type: "flock.scheduler.repeat"
            },
            synthContext: void 0
        },
        invokers: {
            repeat: {
                func: "{repeatScheduler}.schedule",
                args: [ "{arguments}.0", "{arguments}.1" ]
            },
            once: {
                func: "{onceScheduler}.schedule",
                args: [ "{arguments}.0", "{arguments}.1" ]
            },
            sequence: {
                funcName: "flock.scheduler.async.sequence",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
            },
            schedule: {
                funcName: "flock.scheduler.async.schedule",
                args: [ "{arguments}.0", "{that}" ]
            },
            clear: "{that}.events.onClear.fire",
            clearAll: "{that}.events.onClearAll.fire",
            end: "{that}.events.onEnd.fire"
        },
        events: {
            onClear: null,
            onClearAll: null,
            onEnd: null
        },
        listeners: {
            onCreate: "{that}.schedule({that}.options.score)",
            onEnd: "{that}.clearAll"
        }
    }), flock.scheduler.async.sequence = function(e, t, n) {
        for (var r = [], o = 0; o < e.length; o++) {
            var a = n(e[o], t);
            r.push(a);
        }
        return r;
    }, flock.scheduler.async.schedule = function(e, t) {
        if (e) {
            e = flock.isIterable(e) ? e : [ e ];
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                flock.invoke(t, r.interval, [ r.time, r.change ]);
            }
        }
    }, flock.scheduler.async.prepareListener = function(e, t) {
        return "function" == typeof e ? e : flock.scheduler.async.evaluateChangeSpec(e, t);
    }, flock.scheduler.async.getTargetSynth = function(e, t) {
        var n = e.synth;
        return n ? "string" != typeof n ? n : fluid.get(t, n) : t;
    }, flock.scheduler.async.makeSynthUpdater = function(e, t, n, r) {
        return function() {
            for (var o in e) {
                var a = e[o];
                n[o] = flock.evaluate.synthValue(a);
            }
            var i = flock.scheduler.async.getTargetSynth(t, r);
            i ? i.set(n) : flock.fail("A target synth named " + t.synth + " could not be found in the specified synthContext. Synth context was: " + r);
        };
    }, flock.scheduler.async.evaluateChangeSpec = function(e, t) {
        var n = {}, r = {};
        for (var o in e.values) {
            var a = e.values[o];
            a.synthDef ? n[o] = flock.synth.value(a) : r[o] = a;
        }
        return flock.scheduler.async.makeSynthUpdater(n, e, r, t);
    }, fluid.defaults("flock.scheduler.async.tempo", {
        gradeNames: [ "flock.scheduler.async" ],
        bpm: 60,
        components: {
            timeConverter: {
                type: "flock.convert.beats",
                options: {
                    bpm: "{tempo}.options.bpm"
                }
            }
        }
    }), fluid.registerNamespace("flock.convert"), fluid.defaults("flock.convert.ms", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            value: "fluid.identity({arguments}.0)"
        }
    }), fluid.defaults("flock.convert.seconds", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            value: "flock.convert.seconds.toMillis({arguments}.0)"
        }
    }), flock.convert.seconds.toMillis = function(e) {
        return 1e3 * e;
    }, fluid.defaults("flock.convert.beats", {
        gradeNames: [ "fluid.component" ],
        bpm: 60,
        invokers: {
            value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
        }
    }), flock.convert.beats.toMillis = function(e, t) {
        return t <= 0 ? 0 : e / t * 6e4;
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.webAudio"), flock.webAudio.createNode = function(e, t) {
        var n = t.args ? fluid.makeArray(t.args) : void 0, r = "create" + t.node, o = r.indexOf("Node");
        o > -1 && (r = r.substring(0, o));
        var a = e[r].apply(e, n);
        return flock.webAudio.initNodeParams(e, a, t), flock.webAudio.initNodeProperties(a, t), 
        flock.webAudio.initNodeInputs(a, t), a;
    }, flock.webAudio.setAudioParamValue = function(e, t, n, r) {
        r = r || 0;
        var o = e.currentTime + r;
        t.setValueAtTime(n, o);
    }, flock.webAudio.initNodeParams = function(e, t, n) {
        var r = n.params;
        if (t && r) {
            for (var o in r) {
                var a = t[o], i = r[o];
                flock.webAudio.setAudioParamValue(e, a, i);
            }
            return t;
        }
    }, flock.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
    flock.webAudio.shouldSetProperty = function(e) {
        return !flock.platform.browser.safari || flock.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
    }, flock.webAudio.initNodeProperties = function(e, t) {
        var n = t.props;
        if (n) {
            for (var r in n) {
                var o = n[r];
                flock.webAudio.shouldSetProperty(r) && (e[r] = o);
            }
            return e;
        }
    }, flock.webAudio.connectInput = function(e, t, n, r) {
        n.connect(e, r, t);
    }, flock.webAudio.initNodeInputs = function(e, t) {
        var n = t.inputs;
        for (var r in n) {
            var o = n[r], a = parseInt(r, 10);
            o = fluid.makeArray(o);
            for (var i = 0; i < o.length; i++) {
                var u = o[i];
                flock.webAudio.connectInput(e, a, u);
            }
        }
    }, fluid.defaults("flock.webAudio.node", {
        gradeNames: [ "fluid.modelComponent" ],
        members: {
            node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
        },
        nodeSpec: {
            args: [],
            params: {},
            properties: {}
        }
    }), fluid.defaults("flock.webAudio.gain", {
        gradeNames: [ "flock.webAudio.node" ],
        members: {
            node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
        },
        nodeSpec: {
            node: "Gain"
        }
    }), fluid.defaults("flock.webAudio.scriptProcessor", {
        gradeNames: [ "flock.webAudio.node" ],
        nodeSpec: {
            node: "ScriptProcessor",
            args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
            params: {},
            properties: {
                channelCountMode: "explicit"
            }
        }
    }), fluid.defaults("flock.webAudio.channelMerger", {
        gradeNames: [ "flock.webAudio.node" ],
        nodeSpec: {
            node: "ChannelMerger",
            args: [ "{audioSystem}.model.numInputBuses" ],
            properties: {
                channelCountMode: "discrete"
            }
        }
    }), fluid.defaults("flock.webAudio.outputFader", {
        gradeNames: [ "fluid.component" ],
        fadeDuration: .5,
        gainSpec: {
            node: "Gain",
            params: {
                gain: 0
            },
            properties: {
                channelCount: "{flock.enviro}.audioSystem.model.chans",
                channelCountMode: "explicit"
            }
        },
        members: {
            gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
            context: "{flock.enviro}.audioSystem.context"
        },
        invokers: {
            fadeIn: {
                funcName: "flock.webAudio.outputFader.fadeIn",
                args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
            },
            fadeTo: {
                funcName: "flock.webAudio.outputFader.fadeTo",
                args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
            }
        }
    }), flock.webAudio.outputFader.createGainNode = function(e, t) {
        return e.createOutputNode(t);
    }, flock.webAudio.outputFader.fade = function(e, t, n, r, o) {
        o = o || 0;
        var a = e.currentTime + o;
        flock.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(r, a);
    }, flock.webAudio.outputFader.fadeTo = function(e, t, n, r) {
        flock.webAudio.outputFader.fade(e, t, t.gain.value, n, r);
    }, flock.webAudio.outputFader.fadeIn = function(e, t, n, r) {
        flock.webAudio.outputFader.fade(e, t, 0, n, r);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.audioSystem", {
        gradeNames: [ "flock.audioSystem" ],
        channelRange: {
            min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
            max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
        },
        members: {
            context: "@expand:flock.webAudio.audioSystem.createContext()"
        },
        model: {
            rates: {
                audio: "{that}.context.sampleRate"
            }
        },
        components: {
            outputManager: {
                type: "flock.webAudio.outputManager"
            },
            nativeNodeManager: {
                type: "flock.webAudio.nativeNodeManager"
            },
            inputDeviceManager: {
                type: "flock.webAudio.inputDeviceManager"
            },
            bufferWriter: {
                type: "flock.webAudio.bufferWriter"
            }
        },
        listeners: {
            onCreate: [ "flock.webAudio.audioSystem.configureDestination({that}.context, {that}.model.chans)" ]
        }
    }), flock.webAudio.audioSystem.createContext = function() {
        var e = flock.webAudio.audioSystem;
        return e.audioContextSingleton || (e.audioContextSingleton = new flock.shim.AudioContext()), 
        e.audioContextSingleton;
    }, flock.webAudio.audioSystem.calcMaxChannels = function(e) {
        return flock.platform.browser.safari ? e.channelCount : e.maxChannelCount;
    }, flock.webAudio.audioSystem.calcMinChannels = function() {
        return flock.platform.browser.safari ? 2 : 1;
    }, flock.webAudio.audioSystem.configureDestination = function(e, t) {
        flock.platform.browser.safari || (e.destination.channelCount = t, e.destination.channelCountMode = "explicit", 
        e.destination.channelInterpretation = "discrete");
    }, fluid.defaults("flock.webAudio.enviroContextDistributor", {
        gradeNames: [ "fluid.component" ],
        distributeOptions: [ {
            target: "{/ flock.enviro > audioSystem}.options",
            record: {
                gradeNames: "flock.webAudio.audioSystem"
            }
        } ]
    }), fluid.constructSingle([], {
        singleRootType: "flock.enviroContextDistributor",
        type: "flock.webAudio.enviroContextDistributor"
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.bufferWriter", {
        gradeNames: "fluid.component",
        invokers: {
            save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
        }
    }), flock.webAudio.bufferWriter.saveBuffer = function(e) {
        try {
            var t = flock.audio.encode.wav(e.buffer, e.format), n = new Blob([ t ], {
                type: "audio/wav"
            });
            return flock.webAudio.bufferWriter.download(e.path, n), e.success && e.success(t), 
            t;
        } catch (t) {
            e.error ? e.error(t) : flock.fail("There was an error while trying to download the buffer named " + e.buffer.id + ". Error: " + t);
        }
    }, flock.webAudio.bufferWriter.download = function(e, t) {
        var n = flock.shim.URL.createObjectURL(t), r = window.document.createElement("a"), o = document.createEvent("Event");
        r.href = n, r.download = e, o.initEvent("click", !0, !0), r.dispatchEvent(o);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.webAudio.chrome"), flock.webAudio.chrome.getSources = function(e) {
        return MediaStreamTrack.getSources(function(t) {
            var n = fluid.transform(t, function(e) {
                return e.deviceId = e.id, e;
            });
            e(n);
        });
    }, flock.webAudio.mediaStreamFailure = function() {
        flock.fail("Media Capture and Streams are not supported on this browser.");
    };
    var e = {
        AudioContext: window.AudioContext || window.webkitAudioContext,
        getUserMediaImpl: navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || flock.webAudio.mediaStreamFailure,
        getUserMedia: function() {
            flock.shim.getUserMediaImpl.apply(navigator, arguments);
        },
        getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? flock.webAudio.chrome.getSources : flock.webAudio.mediaStreamFailure,
        getMediaDevice: function() {
            flock.shim.getMediaDevicesImpl.apply(navigator, arguments);
        }
    };
    jQuery.extend(flock.shim, e), fluid.defaults("flock.webAudio.inputDeviceManager", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            openAudioDevice: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
            },
            openAudioDeviceWithConstraints: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
            },
            openAudioDeviceWithId: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
            },
            openFirstAudioDeviceWithLabel: {
                funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
            }
        }
    }), flock.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, r) {
        if (e) {
            if (e.id) return t(e.id);
            if (e.label) return n(e.label);
        }
        return r();
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
        t({
            audio: {
                optional: [ {
                    sourceId: e
                } ]
            }
        });
    }, flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(e, t) {
        e && flock.shim.getMediaDevices(function(n) {
            var r = n.filter(function(t) {
                if (t.label.toLowerCase() === e.toLowerCase()) return !0;
            });
            r.length > 0 ? t(r[0].deviceId) : fluid.log(fluid.logLevel.IMPORTANT, "An audio device named '" + e + "' could not be found.");
        });
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, r) {
        r = r || {
            audio: !0
        };
        var o = t.busManager.acquireNextBus("input");
        return flock.shim.getUserMedia(r, function(e) {
            n(e, o);
        }, function(e) {
            fluid.log(fluid.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
        }), o;
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.registerNamespace("flock.midi"), flock.midi.requestAccess = function(e, t, n) {
        if (!navigator.requestMIDIAccess) {
            var r = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
            return fluid.log(fluid.logLevel.WARN, r), void n(r);
        }
        navigator.requestMIDIAccess({
            sysex: e
        }).then(t, n);
    }, flock.midi.getPorts = function(e) {
        var t = {}, n = "function" == typeof e.inputs ? flock.midi.collectPortsLegacy : flock.midi.collectPorts;
        return n("inputs", e, t), n("outputs", e, t), t;
    }, flock.midi.requestPorts = function(e, t) {
        flock.midi.requestAccess(!1, function(t) {
            var n = flock.midi.getPorts(t);
            e(n);
        }, t);
    }, flock.midi.createPortViews = function(e) {
        return fluid.transform(e, function(e) {
            return {
                id: e.id,
                name: e.name,
                manufacturer: e.manufacturer,
                state: e.state,
                connection: e.connection
            };
        });
    }, flock.midi.prettyPrintPorts = function(e) {
        return fluid.prettyPrintJSON({
            inputs: flock.midi.createPortViews(e.inputs),
            outputs: flock.midi.createPortViews(e.outputs)
        });
    }, flock.midi.logPorts = function() {
        flock.midi.requestPorts(function(e) {
            var t = flock.midi.prettyPrintPorts(e);
            console.log(t);
        }, function(e) {
            console.log(e);
        });
    }, flock.midi.collectPorts = function(e, t, n) {
        for (var r = n[e] = n[e] || [], o = t[e].values(), a = o.next(); !a.done; ) r.push(a.value), 
        a = o.next();
        return n;
    }, flock.midi.collectPortsLegacy = function(e, t, n) {
        return t[e] && (n[e] = t[e]()), n;
    }, flock.midi.read = function(e) {
        var t, n = e[0], r = 15 & n;
        switch (n >> 4) {
          case 8:
            t = flock.midi.read.noteOff;
            break;

          case 9:
            t = e[2] > 0 ? flock.midi.read.noteOn : flock.midi.read.noteOff;
            break;

          case 10:
            t = flock.midi.read.polyAftertouch;
            break;

          case 11:
            t = flock.midi.read.controlChange;
            break;

          case 12:
            t = flock.midi.read.programChange;
            break;

          case 13:
            t = flock.midi.read.channelAftertouch;
            break;

          case 14:
            t = flock.midi.read.pitchbend;
            break;

          case 15:
            t = flock.midi.read.system;
            break;

          default:
            return flock.fail("Received an unrecognized MIDI message: " + fluid.prettyPrintJSON(e));
        }
        return t(r, e);
    }, flock.midi.read.note = function(e, t, n) {
        return {
            type: e,
            chan: t,
            note: n[1],
            velocity: n[2]
        };
    }, flock.midi.read.noteOn = function(e, t) {
        return flock.midi.read.note("noteOn", e, t);
    }, flock.midi.read.noteOff = function(e, t) {
        return flock.midi.read.note("noteOff", e, t);
    }, flock.midi.read.polyAftertouch = function(e, t) {
        return {
            type: "aftertouch",
            chan: e,
            note: t[1],
            pressure: t[2]
        };
    }, flock.midi.read.controlChange = function(e, t) {
        return {
            type: "control",
            chan: e,
            number: t[1],
            value: t[2]
        };
    }, flock.midi.read.programChange = function(e, t) {
        return {
            type: "program",
            chan: e,
            program: t[1]
        };
    }, flock.midi.read.channelAftertouch = function(e, t) {
        return {
            type: "aftertouch",
            chan: e,
            pressure: t[1]
        };
    }, flock.midi.read.twoByteValue = function(e) {
        return e[2] << 7 | e[1];
    }, flock.midi.read.pitchbend = function(e, t) {
        return {
            type: "pitchbend",
            chan: e,
            value: flock.midi.read.twoByteValue(t)
        };
    }, flock.midi.read.system = function(e, t) {
        if (1 === e) return flock.midi.messageFailure("quarter frame MTC");
        var n;
        switch (e) {
          case 0:
            n = flock.midi.read.sysex;
            break;

          case 2:
            n = flock.midi.read.songPointer;
            break;

          case 3:
            n = flock.midi.read.songSelect;
            break;

          case 6:
            n = flock.midi.read.tuneRequest;
            break;

          case 8:
            n = flock.midi.read.clock;
            break;

          case 10:
            n = flock.midi.read.start;
            break;

          case 11:
            n = flock.midi.read.continue;
            break;

          case 12:
            n = flock.midi.read.stop;
            break;

          case 14:
            n = flock.midi.read.activeSense;
            break;

          case 15:
            n = flock.midi.read.reset;
            break;

          default:
            return flock.fail("Received an unrecognized MIDI system message: " + fluid.prettyPrintJSON(t));
        }
        return n(t);
    }, flock.midi.messageFailure = function(e) {
        flock.fail("Flocking does not currently support MIDI " + e + " messages.");
    }, flock.midi.read.sysex = function(e) {
        return {
            type: "sysex",
            data: e
        };
    }, flock.midi.read.valueMessage = function(e, t) {
        return {
            type: e,
            value: t
        };
    }, flock.midi.read.songPointer = function(e) {
        var t = flock.midi.read.twoByteValue(e);
        return flock.midi.read.valueMessage("songPointer", t);
    }, flock.midi.read.songSelect = function(e) {
        return flock.midi.read.valueMessage("songSelect", e[1]);
    }, flock.midi.read.tuneRequest = function() {
        return {
            type: "tuneRequest"
        };
    }, flock.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
    flock.midi.createSystemRealtimeMessageReaders = function(e) {
        fluid.each(e, function(e) {
            flock.midi.read[e] = function() {
                return {
                    type: e
                };
            };
        });
    }, flock.midi.createSystemRealtimeMessageReaders(flock.midi.systemRealtimeMessages), 
    fluid.defaults("flock.midi.system", {
        gradeNames: [ "fluid.component" ],
        sysex: !1,
        members: {
            access: void 0,
            ports: void 0
        },
        invokers: {
            requestAccess: {
                funcName: "flock.midi.requestAccess",
                args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
            },
            refreshPorts: {
                funcName: "flock.midi.system.refreshPorts",
                args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
            }
        },
        events: {
            onAccessGranted: null,
            onAccessError: null,
            onReady: null,
            onPortsAvailable: null
        },
        listeners: {
            onCreate: {
                func: "{that}.requestAccess"
            },
            onAccessGranted: [ "flock.midi.system.setAccess({that}, {arguments}.0)", "{that}.refreshPorts()", "{that}.events.onReady.fire({that}.ports)" ],
            onAccessError: {
                funcName: "fluid.log",
                args: [ fluid.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
            }
        }
    }), flock.midi.system.setAccess = function(e, t) {
        e.access = t;
    }, flock.midi.system.refreshPorts = function(e, t, n) {
        e.ports = flock.midi.getPorts(t), n(e.ports);
    }, fluid.defaults("flock.midi.receiver", {
        gradeNames: [ "fluid.component" ],
        events: {
            raw: null,
            message: null,
            note: null,
            noteOn: null,
            noteOff: null,
            control: null,
            program: null,
            aftertouch: null,
            pitchbend: null
        }
    }), fluid.defaults("flock.midi.connection", {
        gradeNames: [ "flock.midi.receiver" ],
        openImmediately: !1,
        sysex: !1,
        distributeOptions: {
            source: "{that}.options.sysex",
            target: "{that > system}.options.sysex"
        },
        ports: 0,
        invokers: {
            sendRaw: {
                func: "{that}.events.onSendRaw.fire"
            },
            send: {
                funcName: "flock.midi.connection.send"
            },
            open: {
                funcName: "flock.midi.connection.bind",
                args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
            },
            close: {
                funcName: "flock.midi.connection.close",
                args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
            }
        },
        components: {
            system: {
                type: "flock.midi.system",
                options: {
                    events: {
                        onReady: "{connection}.events.onPortsAvailable"
                    }
                }
            }
        },
        events: {
            onPortsAvailable: null,
            onReady: null,
            onError: null,
            onSendRaw: null
        },
        listeners: {
            onPortsAvailable: {
                funcName: "flock.midi.connection.autoOpen",
                args: [ "{that}.options.openImmediately", "{that}.open" ]
            },
            onError: {
                funcName: "fluid.log",
                args: [ fluid.logLevel.WARN, "{arguments}.0" ]
            },
            raw: {
                funcName: "flock.midi.connection.fireEvent",
                args: [ "{arguments}.0", "{that}.events" ]
            },
            onDestroy: [ "{that}.close()" ]
        }
    }), flock.midi.connection.send = function() {
        flock.fail("Sending MIDI messages is not currently supported.");
    }, flock.midi.connection.autoOpen = function(e, t) {
        e && t();
    }, flock.midi.findPorts = function(e, t) {
        t = fluid.makeArray(t);
        var n = [];
        return fluid.each(t, function(t) {
            var r = flock.midi.findPorts.portFinder(t)(e);
            n = n.concat(r);
        }), n;
    }, flock.midi.findPorts.portFinder = function(e) {
        if ("number" == typeof e) return flock.midi.findPorts.byIndex(e);
        "string" == typeof e && (e = {
            name: e
        });
        var t = e.id ? flock.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? flock.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? flock.midi.findPorts.manufacturerMatcher(e.manufacturer) : flock.midi.findPorts.nameMatcher(e.name);
        return function(e) {
            return e.filter(t);
        };
    }, flock.midi.findPorts.byIndex = function(e) {
        return function(t) {
            var n = t[e];
            return n ? [ n ] : [];
        };
    }, flock.midi.findPorts.lowerCaseContainsMatcher = function(e) {
        return function(t) {
            var n;
            for (var r in e) {
                var o = t[r], a = e[r];
                if (!(n = "*" === a || o && o.toLowerCase().indexOf(a.toLowerCase()) > -1)) break;
            }
            return n;
        };
    }, flock.midi.findPorts.idMatcher = function(e) {
        return function(t) {
            return t.id === e;
        };
    }, flock.midi.findPorts.bothMatcher = function(e, t) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: e,
            name: t
        });
    }, flock.midi.findPorts.manufacturerMatcher = function(e) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            manufacturer: e
        });
    }, flock.midi.findPorts.nameMatcher = function(e) {
        return flock.midi.findPorts.lowerCaseContainsMatcher({
            name: e
        });
    }, flock.midi.findPorts.eachPortOfType = function(e, t, n) {
        var r = fluid.makeArray(e);
        fluid.each(r, function(e) {
            e.type === t && n(e);
        });
    }, flock.midi.connection.openPort = function(e, t) {
        if (e.open) {
            var n = e.open();
            t.push(n);
        }
        return t;
    }, flock.midi.connection.listen = function(e, t, n) {
        return flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
            flock.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
        }), n;
    }, flock.midi.connection.stopListening = function(e, t) {
        flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
            e.close(), e.removeEventListener("midimessage", t, !1);
        });
    }, flock.midi.connection.bindSender = function(e, t, n) {
        var r = fluid.makeArray(e);
        return fluid.each(r, function(e) {
            flock.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
        }), n;
    }, flock.midi.connection.fireReady = function(e, t) {
        !e || e.length < 1 || Promise.all(e).then(t);
    }, flock.midi.connection.bind = function(e, t, n, r, o) {
        t = flock.midi.connection.expandPortSpec(t);
        var a = flock.midi.findPorts(e.inputs, t.input), i = flock.midi.findPorts(e.outputs, t.output), u = [];
        a && a.length > 0 ? flock.midi.connection.listen(a, r, u) : void 0 !== t.input && flock.midi.connection.logNoMatchedPorts("input", t), 
        i && i.length > 0 ? flock.midi.connection.bindSender(i, o, u) : void 0 !== t.output && flock.midi.connection.logNoMatchedPorts("output", t), 
        flock.midi.connection.fireReady(u, n);
    }, flock.midi.connection.close = function(e, t) {
        flock.midi.connection.stopListening(e.inputs, t);
    }, flock.midi.connection.logNoMatchedPorts = function(e, t) {
        fluid.log(fluid.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
    }, flock.midi.connection.expandPortSpec = function(e) {
        if (void 0 !== e.input || void 0 !== e.output) return e;
        var t = {
            input: {},
            output: {}
        };
        return "number" == typeof e ? t.input = t.output = e : (flock.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
        flock.midi.connection.expandPortSpecProperty("name", e, t)), t;
    }, flock.midi.connection.expandPortSpecProperty = function(e, t, n) {
        return n.input[e] = n.output[e] = t[e], n;
    }, flock.midi.connection.fireEvent = function(e, t) {
        var n = flock.midi.read(e.data), r = n.type ? t[n.type] : void 0;
        t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
        r && r.fire(n, e);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.midi.controller", {
        gradeNames: [ "fluid.component" ],
        members: {
            controlMap: {
                expander: {
                    funcName: "flock.midi.controller.optimizeMIDIMap",
                    args: [ "{that}.options.controlMap" ]
                }
            },
            noteMap: {
                expander: {
                    funcName: "flock.midi.controller.optimizeNoteMap",
                    args: [ "{that}.options.noteMap" ]
                }
            }
        },
        controlMap: {},
        noteMap: {},
        components: {
            synthContext: {
                type: "flock.band"
            },
            connection: {
                type: "flock.midi.connection",
                options: {
                    ports: {
                        input: "*"
                    },
                    openImmediately: !0
                }
            }
        },
        invokers: {
            mapControl: {
                funcName: "flock.midi.controller.mapControl",
                args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
            },
            mapNote: {
                funcName: "flock.midi.controller.mapNote",
                args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
            }
        },
        events: {
            control: "{that}.connection.events.control",
            note: "{that}.connection.events.note",
            noteOn: "{that}.connection.events.noteOn",
            noteOff: "{that}.connection.events.noteOff"
        },
        listeners: {
            control: "{that}.mapControl({arguments}.0)",
            note: "{that}.mapNote(note, {arguments}.0)",
            noteOn: "{that}.mapNote(noteOn, {arguments}.0)",
            noteOff: "{that}.mapNote(noteOff, {arguments}.0)"
        }
    }), flock.midi.controller.optimizeMIDIMap = function(e) {
        var t = new Array(127);
        return fluid.each(e, function(e, n) {
            var r = Number(n);
            t[r] = fluid.makeArray(e);
        }), t;
    }, flock.midi.controller.optimizeNoteMap = function(e) {
        return {
            note: fluid.makeArray(e.note),
            noteOn: fluid.makeArray(e.noteOn),
            noteOff: fluid.makeArray(e.noteOff),
            velocity: fluid.makeArray(e.velocity)
        };
    }, flock.midi.controller.expandControlMapSpec = function(e, t) {
        return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
        t;
    }, flock.midi.controller.makeValueSynth = function(e, t, n) {
        var r = (n = flock.midi.controller.expandControlMapSpec(t, n)).transform, o = n.valuePath;
        flock.set(r, o, e);
        var a = flock.synth.value({
            synthDef: r
        });
        return n.valuePath = t + "." + o, a;
    }, flock.midi.controller.transformValue = function(e, t) {
        var n = t.transform;
        return "function" === typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = flock.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
        t.transformSynth.value());
    }, flock.midi.controller.setMappedValue = function(e, t, n) {
        e = void 0 !== t.value ? t.value : t.transform ? flock.midi.controller.transformValue(e, t) : e, 
        (n[t.synth] || n).set(t.input, e);
    }, flock.midi.controller.mapMIDIValue = function(e, t, n) {
        if (t && !(t.length < 1)) for (var r = 0; r < t.length; r++) {
            var o = t[r];
            flock.midi.controller.setMappedValue(e, o, n);
        }
    }, flock.midi.controller.mapControl = function(e, t, n) {
        var r = n[e.number], o = e.value;
        flock.midi.controller.mapMIDIValue(o, r, t);
    }, flock.midi.controller.mapNote = function(e, t, n, r) {
        var o = r[e], a = t.note, i = r.velocity, u = t.velocity;
        flock.midi.controller.mapMIDIValue(a, o, n), flock.midi.controller.mapMIDIValue(u, i, n);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.nativeNodeManager", {
        gradeNames: [ "fluid.component" ],
        members: {
            outputNode: void 0,
            inputNodes: []
        },
        components: {
            scriptProcessor: {
                createOnEvent: "onCreateScriptProcessor",
                type: "flock.webAudio.scriptProcessor",
                options: {
                    nodeSpec: {
                        inputs: {
                            "0": "{inputMerger}"
                        }
                    }
                }
            },
            merger: {
                type: "flock.webAudio.channelMerger"
            }
        },
        invokers: {
            connect: "{that}.events.onConnect.fire",
            disconnect: "{that}.events.onDisconnect.fire",
            createNode: {
                funcName: "flock.webAudio.createNode",
                args: [ "{audioSystem}.context", "{arguments}.0" ]
            },
            createInputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            },
            createMediaStreamInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", {
                    node: "MediaStreamSource",
                    args: [ "{arguments}.0" ]
                }, "{arguments}.1" ]
            },
            createMediaElementInput: {
                funcName: "flock.webAudio.nativeNodeManager.createInputNode",
                args: [ "{that}", {
                    node: "MediaElementSource",
                    args: [ "{arguments}.0" ]
                }, "{arguments}.1" ]
            },
            createOutputNode: {
                funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
                args: [ "{that}", "{arguments}.0" ]
            },
            insertInput: {
                funcName: "flock.webAudio.nativeNodeManager.insertInput",
                args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
            },
            removeInput: {
                funcName: "flock.webAudio.nativeNodeManager.removeInput",
                args: [ "{arguments}.0", "{that}.inputNodes" ]
            },
            removeAllInputs: {
                funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
                args: "{that}.inputNodes"
            },
            insertOutput: {
                funcName: "flock.webAudio.nativeNodeManager.insertOutput",
                args: [ "{that}", "{arguments}.0" ]
            },
            removeOutput: {
                funcName: "flock.webAudio.nativeNodeManager.removeOutput",
                args: [ "{scriptProcessor}.node" ]
            }
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset",
            onCreateScriptProcessor: null,
            onConnect: null,
            onDisconnectNodes: null,
            onDisconnect: null
        },
        listeners: {
            onCreate: [ "{that}.events.onCreateScriptProcessor.fire()", {
                func: "{that}.insertOutput",
                args: "{scriptProcessor}.node"
            } ],
            onStart: [ "{that}.connect()" ],
            onConnect: [ {
                this: "{merger}.node",
                method: "connect",
                args: [ "{scriptProcessor}.node" ]
            }, {
                this: "{that}.outputNode",
                method: "connect",
                args: [ "{audioSystem}.context.destination" ]
            }, {
                funcName: "flock.webAudio.nativeNodeManager.connectOutput",
                args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
            } ],
            onStop: [ "{that}.disconnect()" ],
            onDisconnectNodes: [ {
                this: "{merger}.node",
                method: "disconnect",
                args: [ 0 ]
            }, {
                this: "{scriptProcessor}.node",
                method: "disconnect",
                args: [ 0 ]
            }, {
                this: "{that}.outputNode",
                method: "disconnect",
                args: [ 0 ]
            } ],
            "onDisconnect.onDisconnectNodes": {
                func: "{that}.events.onDisconnectNodes.fire"
            },
            onReset: [ "{that}.removeAllInputs()", "{that}.events.onCreateScriptProcessor.fire()" ],
            onDestroy: [ "{that}.events.onDisconnectNodes.fire()", "{that}.removeAllInputs()", "flock.webAudio.nativeNodeManager.disconnectOutput({that})" ]
        }
    }), flock.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
        var r = e.createNode(t);
        return e.insertInput(r, n);
    }, flock.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
        var n = e.createNode(t);
        return e.insertOutput(n);
    }, flock.webAudio.nativeNodeManager.connectOutput = function(e, t) {
        e !== t && e.connect(t);
    }, flock.webAudio.nativeNodeManager.disconnectOutput = function(e) {
        e.outputNode && e.outputNode.disconnect(0);
    }, flock.webAudio.nativeNodeManager.removeAllInputs = function(e) {
        for (var t = 0; t < e.length; t++) e[t].disconnect(0);
        e.length = 0;
    }, flock.webAudio.nativeNodeManager.insertInput = function(e, t, n, r, o) {
        var a = t.numInputBuses;
        {
            if (!(e.inputNodes.length >= a)) {
                var i = (o = void 0 === o ? n.busManager.acquireNextBus("input") : o) - t.chans;
                return e.inputNodes.push(r), r.connect(e.merger.node, 0, i), o;
            }
            flock.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + a + ". Either remove an existing input node or increase Flockings numInputBuses option.");
        }
    }, flock.webAudio.nativeNodeManager.removeInput = function(e, t) {
        var n = t.indexOf(e);
        n > -1 && t.splice(n, 1), e.disconnect(0);
    }, flock.webAudio.nativeNodeManager.insertOutput = function(e, t) {
        return flock.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t, t;
    }, flock.webAudio.nativeNodeManager.removeOutput = function(e) {
        flock.webAudio.nativeNodeManager.insertOutput(e);
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    fluid.defaults("flock.webAudio.outputManager", {
        gradeNames: [ "flock.outputManager" ],
        model: {
            isGenerating: !1,
            shouldInitIOS: flock.platform.isIOS,
            audioSettings: {}
        },
        invokers: {
            bindAudioProcess: {
                funcName: "flock.webAudio.outputManager.bindAudioProcess",
                args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
            },
            unbindAudioProcess: {
                funcName: "flock.webAudio.outputManager.unbindAudioProcess",
                args: [ "{nativeNodeManager}" ]
            }
        },
        listeners: {
            "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
            "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
            onStart: [ {
                func: "{that}.applier.change",
                args: [ "isGenerating", !0 ]
            }, {
                priority: "last",
                funcName: "flock.webAudio.outputManager.iOSStart",
                args: [ "{that}", "{audioSystem}.context", "{nativeNodeManager}.scriptProcessor.node" ]
            } ],
            onStop: [ {
                func: "{that}.applier.change",
                args: [ "isGenerating", !1 ]
            } ],
            "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
        }
    }), flock.webAudio.outputManager.bindAudioProcess = function(e, t, n, r) {
        var o = n.scriptProcessor.node;
        o.model = r, o.nodeList = e, o.buses = t, o.inputNodes = n.inputNodes, o.onaudioprocess = flock.webAudio.outputManager.writeSamples;
    }, flock.webAudio.outputManager.unbindAudioProcess = function(e) {
        e.scriptProcessor.node.onaudioprocess = void 0;
    }, flock.webAudio.outputManager.writeSamples = function(e) {
        var t, n, r, o = this.inputNodes ? this.inputNodes.length : 0, a = this.nodeList.nodes, i = this.model.audioSettings, u = e.inputBuffer, s = e.outputBuffer, l = i.numBlocks, c = this.buses, f = i.numBuses, d = i.blockSize, p = i.chans, m = u.numberOfChannels;
        if (a.length < 1) for (t = 0; t < p; t++) flock.clearBuffer(s.getChannelData(t)); else for (n = 0; n < l; n++) {
            var g = n * d;
            if (flock.evaluate.clearBuses(c, f, d), o > 0) for (t = 0; t < m; t++) {
                var h = u.getChannelData(t), v = c[p + t];
                for (r = 0; r < d; r++) v[r] = h[r + g];
            }
            for (flock.evaluate.synths(a), t = 0; t < p; t++) {
                var y = c[t], k = s.getChannelData(t);
                for (r = 0; r < d; r++) k[r + g] = y[r];
            }
        }
    }, flock.webAudio.outputManager.iOSStart = function(e, t, n) {
        if (e.model.shouldInitIOS) {
            var r = t.createBufferSource();
            r.connect(n), r.start(0), r.disconnect(0), e.applier.change("shouldInitIOS", !1);
        }
    };
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    flock.ugenDefaults = function(e, t) {
        return 1 === arguments.length ? flock.ugenDefaults.store[e] : (flock.ugenDefaults.store[e] = t, 
        t);
    }, flock.ugenDefaults.store = {}, flock.isUGen = function(e) {
        return e && e.tags && e.tags.indexOf("flock.ugen") > -1;
    }, flock.aliasUGen = function(t, n, r, o) {
        var a = flock.get(t);
        flock.set(a, n, function(t, n, r) {
            return r = e.extend(!0, {}, o, r), a(t, n, r);
        }), flock.ugenDefaults(t + "." + n, r);
    }, flock.aliasUGens = function(e, t) {
        var n, r;
        for (n in t) r = t[n], flock.aliasUGen(e, n, {
            inputs: r.inputDefaults
        }, r.options);
    }, flock.krMul = function(e, t, n) {
        var r, o = n.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * o;
    }, flock.mul = function(e, t, n) {
        var r, o = n.output;
        for (r = 0; r < e; r++) t[r] = t[r] * o[r];
    }, flock.krAdd = function(e, t, n, r) {
        var o, a = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] + a;
    }, flock.add = function(e, t, n, r) {
        var o, a = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] + a[o];
    }, flock.krMulAdd = function(e, t, n, r) {
        var o, a = n.output[0], i = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] * a + i[o];
    }, flock.mulKrAdd = function(e, t, n, r) {
        var o, a = n.output, i = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * a[o] + i;
    }, flock.krMulKrAdd = function(e, t, n, r) {
        var o, a = n.output[0], i = r.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * a + i;
    }, flock.mulAdd = function(e, t, n, r) {
        var o, a = n.output, i = r.output;
        for (o = 0; o < e; o++) t[o] = t[o] * a[o] + i[o];
    }, flock.onMulAddInputChanged = function(e) {
        var t, n = e.inputs.mul, r = e.inputs.add;
        n || r ? (t = n ? r ? n.rate !== flock.rates.AUDIO ? r.rate !== flock.rates.AUDIO ? flock.krMulKrAdd : flock.krMulAdd : r.rate !== flock.rates.AUDIO ? flock.mulKrAdd : flock.mulAdd : n.rate !== flock.rates.AUDIO ? flock.krMul : flock.mul : r.rate !== flock.rates.AUDIO ? flock.krAdd : flock.add, 
        e.mulAddFn = t, e.mulAdd = function(t) {
            e.mulAddFn(t, e.output, e.inputs.mul, e.inputs.add);
        }) : e.mulAdd = e.mulAddFn = flock.noOp;
    }, flock.ugen = function(e, t, n) {
        var r = {
            enviro: (n = n || {}).enviro || flock.environment,
            rate: n.rate || flock.rates.AUDIO,
            inputs: e,
            output: t,
            options: n,
            model: n.model || {
                unscaledValue: 0,
                value: 0
            },
            multiInputs: {},
            tags: [ "flock.ugen" ]
        };
        return r.lastOutputIdx = r.output.length - 1, r.get = function(e) {
            return flock.input.get(r.inputs, e);
        }, r.set = function(e, t) {
            return flock.input.set(r.inputs, e, t, r, function(e) {
                if (null !== e && void 0 !== e) return flock.parse.ugenDef(e, r.enviro, {
                    audioSettings: r.options.audioSettings,
                    buses: r.buses,
                    buffers: r.buffers
                });
            });
        }, r.input = function(e, t) {
            return e ? "string" == typeof e ? arguments.length < 2 ? r.get(e) : r.set(e, t) : flock.isIterable(e) ? r.get(e) : r.set(e, t) : void 0;
        }, r.calculateStrides = function() {
            var e, t, n, o = r.model, a = r.options.strideInputs, i = r.inputs;
            if (o.strides = o.strides || {}, a) for (e = 0; e < a.length; e++) (n = i[t = a[e]]) ? o.strides[t] = n.rate === flock.rates.AUDIO ? 1 : 0 : fluid.log(fluid.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + r);
        }, r.collectMultiInputs = function() {
            var e, t, n, o, a = r.options.multiInputNames, i = r.multiInputs;
            for (e = 0; e < a.length; e++) (n = i[t = a[e]]) ? n.length = 0 : n = i[t] = [], 
            o = r.inputs[t], flock.ugen.collectMultiInputs(o, n);
        }, r.onInputChanged = function(e) {
            var t = r.options.multiInputNames;
            flock.onMulAddInputChanged(r), r.options.strideInputs && r.calculateStrides(), !t || e && !t.indexOf(e) || r.collectMultiInputs();
        }, r.init = function() {
            var e, t, n, o = fluid.makeArray(r.options.tags), a = r.model, i = r.options;
            for (e = 0; e < o.length; e++) r.tags.push(o[e]);
            if (t = i.audioSettings = i.audioSettings || r.enviro.audioSystem.model, a.sampleRate = i.sampleRate || t.rates[r.rate], 
            a.nyquistRate = a.sampleRate, a.blockSize = r.rate === flock.rates.AUDIO ? t.blockSize : 1, 
            a.sampleDur = 1 / a.sampleRate, r.interpolate = flock.interpolate.none, i.interpolation) {
                var u = flock.interpolate[i.interpolation];
                u ? r.interpolate = u : fluid.log(fluid.logLevel.IMPORTANT, "An invalid interpolation type of '" + i.interpolation + "' was specified. Defaulting to none.");
            }
            r.rate === flock.rates.DEMAND && r.inputs.freq && (n = flock.parse.ugenDefForConstantValue(1), 
            r.inputs.freq = flock.parse.ugenDef(n, r.enviro));
        }, r.init(), r;
    }, flock.ugen.collectMultiInputs = function(e, t) {
        flock.isIterable(e) || (e = e = fluid.makeArray(e));
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            flock.ugen.collectChannelsForInput(r, t);
        }
        return t;
    }, flock.ugen.collectChannelsForInput = function(e, t) {
        var n, r = flock.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
        for (n = 0; n < r.length; n++) t.push({
            rate: e.rate,
            output: r[n]
        });
        return t;
    }, flock.ugen.lastOutputValue = function(e, t) {
        return t[e - 1];
    }, flock.ugen.buffer = function(e) {
        e.onBufferInputChanged = function(t) {
            var n = e.model, r = e.inputs;
            n.bufDef === r.buffer && "buffer" !== t || (n.bufDef = r.buffer, flock.parse.bufferForDef(n.bufDef, e, e.enviro));
        }, e.setBuffer = function(t) {
            e.buffer = t, e.onBufferReady && e.onBufferReady(t);
        }, e.initBuffer = function() {
            e.buffer = e.model.bufDef = flock.bufferDesc({
                format: {
                    sampleRate: e.options.audioSettings.rates.audio
                },
                data: {
                    channels: [ new Float32Array(e.output.length) ]
                }
            });
        };
    }, flock.ugen.value = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.value = function() {
            return r.model.value;
        }, r.dynamicGen = function(e) {
            for (var t = r.output, n = r.model, o = 0; o < e; o++) t[o] = n.unscaledValue;
            r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, t);
        }, r.onInputChanged = function() {
            var e = r.inputs;
            r.model.unscaledValue = e.value, "constant" !== r.rate ? r.gen = r.dynamicGen : r.gen = void 0, 
            flock.onMulAddInputChanged(r), r.dynamicGen(1);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.value", {
        rate: "control",
        inputs: {
            value: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 1,
                value: 1
            },
            tags: [ "flock.ugen.valueType" ]
        }
    }), flock.ugen.silence = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.onInputChanged = function() {
            for (var e = 0; e < r.output.length; e++) r.output[e] = 0;
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.silence", {
        rate: "constant"
    }), flock.ugen.passThrough = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.inputs.source.output, i = r.output;
            for (t = 0; t < a.length; t++) i[t] = n = a[t];
            for (;t < e; t++) i[t] = n = 0;
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.passThrough", {
        rate: "audio",
        inputs: {
            source: null,
            mul: null,
            add: null
        }
    }), flock.ugen.out = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l, c, f, d = r.model, p = r.multiInputs.sources, m = r.options.buses, g = r.inputs.bus.output[0], h = r.inputs.expand.output[0];
            if (t = p.length, n = Math.max(h, t), !(t < 1)) {
                for (o = 0; o < n; o++) {
                    for (u = (i = p[o % t]).rate, s = m[g + o], l = u === flock.rates.AUDIO ? 1 : 0, 
                    c = 0, a = 0; a < e; a++, c += l) f = i.output[c], s[a] = s[a] + f;
                    r.mulAddFn(e, s, r.inputs.mul, r.inputs.add);
                }
                d.value = d.unscaledValue = f;
            }
        }, r.init = function() {
            r.sourceBuffers = [], r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.out", {
        rate: "audio",
        inputs: {
            sources: null,
            bus: 0,
            expand: 2
        },
        ugenOptions: {
            tags: [ "flock.ugen.outputType" ],
            multiInputNames: [ "sources" ]
        }
    }), flock.ugen.valueOut = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.arraySourceGen = function() {
            var e, t = r.model, n = r.inputs.sources;
            for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
        }, r.ugenSourceGen = function() {
            r.model.value = r.model.unscaledValue = r.inputs.sources.output[0];
        }, r.onInputChanged = function() {
            var e = r.model, t = r.inputs.sources;
            flock.isIterable(t) ? (r.gen = r.arraySourceGen, e.value = new Float32Array(t.length), 
            e.unscaledValue = e.value) : r.gen = r.ugenSourceGen;
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.valueOut", {
        rate: "control",
        inputs: {
            sources: null
        },
        ugenOptions: {
            model: {
                unscaledValue: null,
                value: null
            },
            tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
        }
    }), flock.ugen.in = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.singleBusGen = function(e) {
            var t = r.model, n = r.output;
            flock.ugen.in.readBus(e, n, r.inputs.bus, r.options.buses), t.unscaledValue = flock.ugen.lastOutputValue(e, n), 
            r.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, r.multiBusGen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.bus, u = r.options.buses, s = r.output;
            for (t = 0; t < e; t++) {
                for (o = 0, n = 0; n < i.length; n++) o += u[0 | i[n].output[0]][t];
                s[t] = o;
            }
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, s);
        }, r.onInputChanged = function() {
            r.gen = flock.isIterable(r.inputs.bus) ? r.multiBusGen : r.singleBusGen, flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugen.in.readBus = function(e, t, n, r) {
        var o, a = r[0 | n.output[0]];
        for (o = 0; o < e; o++) t[o] = a[o];
    }, flock.ugenDefaults("flock.ugen.in", {
        rate: "audio",
        inputs: {
            bus: 0,
            mul: null,
            add: null
        }
    }), flock.ugen.audioIn = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.output, i = r.bus;
            for (t = 0; t < e; t++) a[t] = n = i[t];
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, r.onInputChanged = function() {
            flock.onMulAddInputChanged(r);
        }, r.init = function() {
            var e = r.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
            r.bus = r.options.buses[e], r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.audioIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.blit = function(e) {
        var t;
        return e >= 2 ? 0 : e >= 1 ? .16666666666666666 * (t = 2 - e) * t * t : e >= 0 ? .6666666666666666 - (t = e * e) + .5 * t * e : e >= -1 ? .6666666666666666 - (t = e * e) - .5 * t * e : e >= -2 ? .16666666666666666 * (t = 2 + e) * t * t : 0;
    }, flock.blit.period = function(e, t) {
        var n = e / t;
        return n < 1 ? 1 : n;
    }, flock.blit.updatePeriodState = function(e, t) {
        e.freq = t < 1e-6 ? 1e-6 : t, e.d0 = flock.blit.period(e.sampleRate, e.freq);
    }, flock.ugen.blit = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.output, i = r.inputs.freq.output[0], u = o.phase;
            for (t = 0; t < e; t++) (u -= 1) < -2 && (flock.blit.updatePeriodState(o, i), u += o.d0), 
            n = flock.blit(u), a[t] = n;
            o.phase = u, o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.blit", {
        rate: "audio",
        inputs: {
            freq: 440,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: -2,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.saw = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs.freq.output[0], i = 1 - r.inputs.leakRate.output[0], u = n.phase, s = n.unscaledValue;
            for (void 0 === u && (flock.ugen.saw.updatePeriodState(n, a), u = n.d0 / 2), t = 0; t < e; t++) (u -= 1) < -2 && (flock.ugen.saw.updatePeriodState(n, a), 
            u += n.d0), o[t] = s = flock.blit(u) - n.dcOffset + i * s;
            n.phase = u, n.unscaledValue = s, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugen.saw.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.dcOffset = 1 / e.d0;
    }, flock.ugenDefaults("flock.ugen.saw", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                dcOffset: void 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.square = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs.freq.output[0], i = 1 - r.inputs.leakRate.output[0], u = n.phase, s = n.unscaledValue;
            for (void 0 === u && (flock.ugen.square.updatePeriodState(n, a), u = n.phaseResetValue), 
            t = 0; t < e; t++) o[t] = s = flock.blit(u) * n.sign + i * s, u < -2 && (flock.ugen.square.updatePeriodState(n, a), 
            u += n.phaseResetValue), u -= 1;
            n.phase = u, n.unscaledValue = s, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugen.square.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.sign *= -1;
    }, flock.ugenDefaults("flock.ugen.square", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                unscaledValue: .5,
                value: .5,
                sign: 1
            }
        }
    }), flock.ugen.tri = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.output, u = r.inputs.freq.output[0], s = 1 - r.inputs.leakRate.output[0], l = a.phase, c = a.unscaledValue, f = a.secondPrevVal;
            for (void 0 === l && (flock.ugen.tri.updatePeriodState(a, u), l = a.d0 / 4), t = 0; t < e; t++) c = n = flock.blit(l) * a.sign + s * c, 
            f = o = n + s * f, i[t] = o * a.ampScale, (l -= 1) < -2 && (flock.ugen.tri.updatePeriodState(a, u), 
            l += a.phaseResetValue);
            a.phase = l, a.unscaledValue = c, a.secondPrevVal = f, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugen.tri.updatePeriodState = function(e, t) {
        flock.blit.updatePeriodState(e, t), e.phaseResetValue = e.d0 / 2, e.ampScale = 2 / e.d0, 
        e.sign *= -1;
    }, flock.ugenDefaults("flock.ugen.tri", {
        rate: "audio",
        inputs: {
            freq: 440,
            leakRate: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: void 0,
                value: .5,
                unscaledValue: .5,
                secondPrevVal: 0,
                sign: 1,
                ampScale: void 0,
                phaseResetValue: void 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.playBuffer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.defaultKrTriggerGen = function(t) {
            var n, o, a = r.model, i = r.output, u = r.inputs.channel.output[0], s = r.buffer.data.channels[u], l = a.idx, c = r.inputs.loop.output[0], f = e.trigger.output[0];
            for (f > 0 && a.prevTrig <= 0 && (l = 0), a.prevTrig = f, n = 0; n < t; n++) {
                if (l > a.lastIdx) {
                    if (!(c > 0 && f > 0)) {
                        i[n] = o = 0;
                        continue;
                    }
                    l = 0;
                }
                o = r.interpolate(l, s), i[n] = o, l++;
            }
            a.idx = l, a.unscaledValue = o, r.mulAdd(t), a.value = flock.ugen.lastOutputValue(t, i);
        }, r.otherwiseGen = function(t) {
            var n, o, a, i, u, s, l, c = r.model, f = r.output, d = r.inputs.channel.output[0], p = r.inputs.speed.output, m = r.buffer.data.channels[d], g = e.trigger.output, h = c.idx, v = r.inputs.loop.output[0], y = r.inputs.start.output[0] * c.lastIdx | 0, k = r.inputs.end.output[0] * c.lastIdx | 0;
            for (n = 0, o = 0, a = 0; n < t; n++, o += c.strides.trigger, a += c.strides.speed) {
                if (i = g[o], u = c.prevTrig, s = p[a], c.prevTrig = i, i > 0 && u <= 0) h = flock.ugen.playBuffer.resetIndex(s, y, k); else if (h < y || h > k) {
                    if (!(v > 0 && i > 0)) {
                        f[n] = l = 0;
                        continue;
                    }
                    h = flock.ugen.playBuffer.resetIndex(s, y, k);
                }
                l = r.interpolate(h, m), f[n] = l, h += c.stepSize * s;
            }
            c.idx = h, c.unscaledValue = l, r.mulAdd(t), c.value = flock.ugen.lastOutputValue(t, f);
        }, r.onInputChanged = function(e) {
            var t = r.inputs, n = t.speed, o = t.start, a = t.end, i = t.trigger;
            r.onBufferInputChanged(e), r.gen = n.rate === flock.rates.CONSTANT && 1 === n.output[0] && o.rate === flock.rates.CONSTANT && 0 === o.output[0] && a.rate === flock.rates.CONSTANT && 1 === a.output[0] && i.rate !== flock.rates.AUDIO ? r.defaultKrTriggerGen : r.otherwiseGen, 
            r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.onBufferReady = function() {
            var e = r.model, t = r.inputs.end.output[0], n = r.inputs.channel.output[0], o = r.buffer.data.channels[n].length;
            e.idx = t * o | 0, e.lastIdx = o - 1, e.stepSize = r.buffer.format.sampleRate / e.sampleRate;
        }, r.init = function() {
            flock.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugen.playBuffer.resetIndex = function(e, t, n) {
        return e > 0 ? t : n;
    }, flock.ugenDefaults("flock.ugen.playBuffer", {
        rate: "audio",
        inputs: {
            channel: 0,
            loop: 0,
            speed: 1,
            start: 0,
            end: 1,
            trigger: 1,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                finished: !1,
                unscaledValue: 0,
                value: 0,
                idx: 0,
                stepSize: 0,
                prevTrig: 0,
                channel: void 0
            },
            strideInputs: [ "trigger", "speed" ],
            interpolation: "linear"
        }
    }), flock.ugen.readBuffer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = i.strides.phase, s = r.output, l = r.inputs.channel.output[0], c = r.inputs.phase.output, f = r.buffer.data.channels[l], d = f.length;
            for (t = o = 0; t < e; t++, o += u) n = c[o] * d, a = r.interpolate(n, f), s[t] = a;
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, s);
        }, r.onInputChanged = function(e) {
            r.onBufferInputChanged(e), r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.init = function() {
            flock.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.readBuffer", {
        rate: "audio",
        inputs: {
            buffer: null,
            channel: 0,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                channel: void 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "phase" ],
            interpolation: "linear"
        }
    }), flock.ugen.writeBuffer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.output, u = r.inputs, s = r.buffer, l = r.multiInputs.sources, c = l.length, f = s.data.channels, d = s.format.numSampleFrames, p = u.start.output[0], m = u.loop.output[0];
            for (a.prevStart !== p && (a.prevStart = p, a.writeIdx = Math.floor(p)), t = 0; t < c; t++) {
                var g = l[t].output, h = f[t], v = i[t];
                for (n = a.writeIdx, o = 0; o < e; o++) {
                    var y = g[o];
                    v && (v[o] = y), n < d ? h[n] = y : m > 0 && (h[n = Math.floor(p)] = y), n++;
                }
            }
            a.writeIdx = n, r.mulAdd(e);
        }, r.createBuffer = function(e, t) {
            var n, r = e.options, o = r.audioSettings, a = r.buffers, i = e.multiInputs.sources.length, u = Math.round(e.options.duration * o.rates.audio), s = new Array(i);
            for (n = 0; n < i; n++) s[n] = new Float32Array(u);
            var l = flock.bufferDesc(s, o.rates.audio, i);
            return t.id && (l.id = t.id, a[t.id] = l), l;
        }, r.setupBuffer = function(e) {
            var t;
            return (e = "string" == typeof e ? {
                id: e
            } : e).id && (t = r.options.buffers[e.id]), r.buffer = t || r.createBuffer(r, e), 
            r.buffer;
        }, r.onInputChanged = function(e) {
            e ? "sources" === e ? r.collectMultiInputs() : "buffer" === e && r.setupBuffer(r.inputs.buffer) : (r.collectMultiInputs(), 
            r.setupBuffer(r.inputs.buffer)), flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.writeBuffer", {
        rate: "audio",
        inputs: {
            sources: null,
            buffer: null,
            start: 0,
            loop: 0
        },
        ugenOptions: {
            model: {
                prevStart: void 0,
                writeIdx: 0
            },
            tags: [ "flock.ugen.multiChannelOutput" ],
            numOutputs: 2,
            multiInputNames: [ "sources" ],
            duration: 600
        }
    }), flock.ugen.bufferDuration = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.krGen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs.channel.output[0], i = r.buffer.data.channels[a], u = r.buffer.format.sampleRate, s = i.length / u;
            for (t = 0; t < e; t++) o[t] = s;
            n.unscaledValue = s, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function(e) {
            flock.onMulAddInputChanged(r), r.onBufferInputChanged(e);
        }, r.onBufferReady = function() {
            r.krGen(1);
        }, r.init = function() {
            var e = r.rate;
            r.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? r.krGen : void 0, 
            r.output[0] = 0, flock.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.bufferDuration", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.bufferLength = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.krGen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs.channel.output[0], i = r.buffer.data.channels[a].length;
            for (t = 0; t < e; t++) o[t] = i;
            n.unscaledValue = i, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function(e) {
            flock.onMulAddInputChanged(r), r.onBufferInputChanged(e);
        }, r.onBufferReady = function() {
            r.krGen(1);
        }, r.init = function() {
            var e = r.rate;
            r.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? r.krGen : void 0, 
            r.output[0] = 0, flock.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.bufferLength", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.bufferPhaseStep = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.krGen = function(e) {
            var t, n = r.model, o = r.output, a = n.unscaledValue;
            for (t = 0; t < e; t++) o[t] = a;
            r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function(e) {
            r.onBufferInputChanged(e), flock.onMulAddInputChanged(r);
        }, r.onBufferReady = function(e) {
            var t = r.model, n = r.inputs.channel.output[0], o = e.data.channels[n], a = r.options.audioSettings.rates.audio, i = r.buffer.format.sampleRate || a;
            t.scale = i / a, r.output[0] = t.unscaledValue = 1 / (o.length * t.scale);
        }, r.init = function() {
            var e = r.rate;
            r.gen = e === flock.rates.CONTROL || e === flock.rates.AUDIO ? r.krGen : void 0, 
            r.output[0] = 0, flock.ugen.buffer(r), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.bufferPhaseStep", {
        rate: "constant",
        inputs: {
            buffer: null,
            channel: 0
        },
        ugenOptions: {
            model: {
                scale: 1,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.sampleRate = function(e, t, n) {
        var r = flock.ugen(e, t, n), o = r.model;
        return r.output[0] = o.value = o.unscaledValue = r.options.audioSettings.rates.audio, 
        r;
    }, flock.ugenDefaults("flock.ugen.sampleRate", {
        rate: "constant",
        inputs: {}
    }), flock.ugen.triggerBuffers = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l, c, f, d = r.model, p = d.strides, m = r.output, g = r.inputs, h = r.buffers, v = h.length - 1, y = d.prevTrigger, k = d.maxVoices, b = d.activeVoices, x = d.freeVoices, S = g.trigger.output, w = p.trigger, C = 0, A = g.bufferIndex.output, N = p.bufferIndex, T = 0, I = g.speed.output, M = p.speed, P = 0, O = r.inputs.channel.output[0];
            for (t = 0; t < e; t++) {
                if ((n = S[C]) > 0 && y <= 0 && b.length < k) {
                    if (a = Math.round(A[T] * v), a = Math.max(0, a), a = Math.min(a, v), !(i = h[a])) continue;
                    (o = x.pop()).speed = I[P], o.currentIdx = 0, o.writePos = t, o.buffer = i.data.channels[O], 
                    b.push(o);
                }
                C += w, P += M, T += N, m[t] = 0, y = n;
            }
            for (u = 0; u < b.length; ) {
                for (s = (o = b[u]).buffer, l = Math.min(s.length - o.currentIdx, e), c = o.writePos; c < l; c++) f = r.interpolate ? r.interpolate(o.currentIdx, s) : s[0 | o.currentIdx], 
                m[c] += f, o.currentIdx += o.speed;
                o.currentIdx >= s.length ? (x.push(o), b.splice(u, 1)) : (o.writePos = 0, u++);
            }
            d.prevTrigger = y, d.unscaledValue = f, r.mulAdd(e), d.value = flock.ugen.lastOutputValue(e, m);
        }, r.init = function() {
            r.buffers = [], r.allocateVoices(), r.onInputChanged();
        }, r.allocateVoices = function() {
            for (var e = 0; e < r.model.maxVoices; e++) r.model.freeVoices.push({});
        }, r.onInputChanged = function() {
            var e, t, n = r.enviro.buffers, o = r.options.bufferIDs;
            for (r.buffers.length = 0, e = 0; e < o.length; e++) t = n[o[e]], r.buffers.push(t);
            flock.onMulAddInputChanged(r), r.calculateStrides();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.triggerBuffers", {
        inputs: {
            trigger: 0,
            bufferIndex: 0,
            speed: 1,
            channel: 0
        },
        ugenOptions: {
            model: {
                prevTrigger: 0,
                maxVoices: 128,
                activeVoices: [],
                freeVoices: [],
                channel: 0
            },
            bufferIDs: [],
            strideInputs: [ "trigger", "bufferIndex", "speed" ]
        }
    }), flock.ugen.chopBuffer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return flock.ugen.buffer(r), r.gen = function(e) {
            var t = r.model, n = r.output;
            flock.ugen.chopBuffer.prepareVoices(r, e), flock.ugen.chopBuffer.generateSamplesForAllVoices(r, e), 
            t.unscaledValue = flock.ugen.lastOutputValue(e, n), r.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, r.onInputChanged = function(e) {
            r.onBufferInputChanged(e), r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.onBufferReady = function() {
            var e = r.model;
            e.stepSize = r.buffer.format.sampleRate / e.sampleRate, e.lastIdx = r.buffer.format.numSampleFrames - 1;
        }, r.init = function() {
            flock.ugen.chopBuffer.initVoices(r), r.initBuffer(), r.onInputChanged();
            var e = r.buffer.data.channels[r.inputs.channel.output[0]];
            r.model.lastIdx = e.length - 1;
        }, r.init(), r;
    }, flock.ugen.chopBuffer.initVoice = function() {
        return {
            currentStage: 4,
            samplesRemaining: 0,
            duration: 0,
            attackDur: 0,
            releaseDur: 0,
            hasTriggeredNextVoice: !1,
            idx: 0,
            stages: [ {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            }, {
                samplesRemaining: 0
            } ]
        };
    }, flock.ugen.chopBuffer.initVoices = function(e) {
        for (var t = e.model, n = 0; n < e.options.maxVoices; n++) {
            var r = flock.ugen.chopBuffer.initVoice(e);
            t.freeVoices[n] = r;
        }
    }, flock.ugen.chopBuffer.randomIndex = flock.randomValue, flock.ugen.chopBuffer.randomStartIndex = function(e) {
        var t = e.model, n = e.inputs, r = n.end.output[0] - t.inputState.numDurationSamps;
        return r = Math.max(0, r), flock.ugen.chopBuffer.randomIndex(n.start.output[0], r) * t.lastIdx;
    }, flock.ugen.chopBuffer.allocateVoice = function(e) {
        var t = e.model, n = t.stageSampleState;
        if (!(t.freeVoices.length < 1)) {
            var r = t.freeVoices.pop();
            t.activeVoices.push(r);
            for (var o = 0; o < n.length; o++) r.stages[o].samplesRemaining = n[o];
            return r.hasTriggeredNextVoice = !1, r.currentStage = flock.ugen.chopBuffer.stages.WAIT, 
            r.samplesRemaining = t.inputState.numDurationSamps + t.inputState.numGapSamps, r.idx = flock.ugen.chopBuffer.randomStartIndex(e), 
            r;
        }
    }, flock.ugen.chopBuffer.updateVoiceState = function(e, t) {
        for (var n = e.model, r = n.stageSampleState, o = n.inputState, a = t.currentStage; a < r.length; a++) {
            var i = t.stages[a], u = r[a];
            i.samplesRemaining > u && (i.samplesRemaining = u);
        }
        t.samplesRemaining > o.numDurationSamps && (t.samplesRemaining = o.numDurationSamps, 
        0 === t.currentStage && (t.samplesRemaining += o.numGapSamps));
    }, flock.ugen.chopBuffer.triggerNextVoice = function(e, t, n, r, o) {
        var a = t.samplesRemaining + o;
        a < n && (e.model.stageSampleState[0] = a, flock.ugen.chopBuffer.allocateVoice(e), 
        t.hasTriggeredNextVoice = !0);
    }, flock.ugen.chopBuffer.envLength = function(e, t, n) {
        return Math.floor((e > t ? t : e) * n);
    }, flock.ugen.chopBuffer.deactivateVoice = function(e, t) {
        var n = e.model, r = n.activeVoices.indexOf(t);
        r > -1 && n.activeVoices.splice(r, 1), n.freeVoices.push(t);
    }, flock.ugen.chopBuffer.prepareVoice = function(e, t, n) {
        flock.ugen.chopBuffer.updateVoiceState(e, t), t.currentStage < flock.ugen.chopBuffer.stages.DONE ? t.hasTriggeredNextVoice || flock.ugen.chopBuffer.triggerNextVoice(e, t, n) : flock.ugen.chopBuffer.deactivateVoice(e, t);
    }, flock.ugen.chopBuffer.durationSamples = function(e, t, n) {
        return 0 === t ? n.lastIdx : Math.floor(e / t * n.sampleRate);
    }, flock.ugen.chopBuffer.updateInputState = function(e, t) {
        var n = t.inputState, r = e.amount.output[0], o = e.minDuration.output[0], a = o / 2;
        return n.numDurationSamps = flock.ugen.chopBuffer.durationSamples(o, r, t), n.numAttackSamps = flock.ugen.chopBuffer.envLength(e.attack.output[0], a, t.sampleRate), 
        n.numReleaseSamps = flock.ugen.chopBuffer.envLength(e.release.output[0], a, t.sampleRate), 
        n.numSustainSamps = n.numDurationSamps - n.numAttackSamps - n.numReleaseSamps, n.numGapSamps = Math.floor(e.gap.output[0] * t.sampleRate), 
        n;
    }, flock.ugen.chopBuffer.prepareVoices = function(e, t) {
        var n = e.model;
        flock.ugen.chopBuffer.updateInputState(e.inputs, n), n.stageSampleState[0] = n.inputState.numGapSamps, 
        n.stageSampleState[1] = n.inputState.numAttackSamps, n.stageSampleState[3] = n.inputState.numReleaseSamps, 
        n.stageSampleState[2] = n.inputState.numSustainSamps;
        for (var r = 0; r < n.activeVoices.length; r++) {
            var o = n.activeVoices[r];
            flock.ugen.chopBuffer.prepareVoice(e, o, t);
        }
        0 === n.activeVoices.length && flock.ugen.chopBuffer.allocateVoice(e);
    }, flock.ugen.chopBuffer.generateSamplesForVoice = function(e, t, n) {
        for (var r = e.model, o = e.output, a = e.inputs, i = a.speed.output, u = e.buffer.data.channels[a.channel.output[0]], s = 0, l = 0; s < Math.min(n, t.samplesRemaining) && !(t.currentStage >= flock.ugen.chopBuffer.stages.DONE); s++, 
        l += r.strides.speed) {
            var c = r.stepSize * i[l], f = t.stages[t.currentStage];
            o[s] += e.interpolate(t.idx, u), t.samplesRemaining -= c, f.samplesRemaining -= c, 
            t.idx += c, f.samplesRemaining <= 0 && t.currentStage++;
        }
        t.samplesRemaining <= 0 && t.currentStage < flock.ugen.chopBuffer.stages.DONE && (t.currentStage = flock.ugen.chopBuffer.stages.DONE);
    }, flock.ugen.chopBuffer.generateSamplesForAllVoices = function(e, t) {
        var n = e.model;
        flock.clearBuffer(e.output);
        for (var r = n.activeVoices.length - 1; r >= 0; r--) {
            var o = n.activeVoices[r];
            flock.ugen.chopBuffer.generateSamplesForVoice(e, o, t);
        }
    }, flock.ugen.chopBuffer.stages = {
        WAIT: 0,
        ATTACK: 1,
        SUSTAIN: 2,
        RELEASE: 3,
        DONE: 4
    }, flock.ugenDefaults("flock.ugen.chopBuffer", {
        rate: "audio",
        inputs: {
            buffer: null,
            channel: 0,
            start: 0,
            end: 1,
            speed: 1,
            amount: 1,
            minDuration: .1,
            attack: .01,
            release: .01,
            gap: 0
        },
        ugenOptions: {
            model: {
                stepSize: 1,
                activeVoices: [],
                freeVoices: [],
                stageSampleState: [ 0, 0, 0, 0 ],
                lastIdx: 0,
                inputState: {
                    numAttackSamps: 0,
                    numSustainSamps: 0,
                    numReleaseSamps: 0,
                    numDurationSamps: 0,
                    numGapSamps: 0
                }
            },
            interpolation: "linear",
            envelopeType: "linear",
            maxVoices: 2,
            strideInputs: [ "speed" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.print = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.inputs, i = r.output, u = r.model, s = u.label, l = a.channel, c = l ? a.source.output[l.output[0]] : a.source.output, f = a.trigger.output[0], d = a.freq.output[0];
            for (f > 0 && u.prevTrig <= 0 && fluid.log(fluid.logLevel.IMPORTANT, s + c), u.freq !== d && (u.sampInterval = Math.round(u.sampleRate / d), 
            u.freq = d, u.counter = u.sampInterval), t = 0, n = 0; t < e; t++, n += u.strides.source) u.counter >= u.sampInterval && (fluid.log(fluid.logLevel.IMPORTANT, s + c[n]), 
            u.counter = 0), u.counter++, i[t] = o = c[t];
            u.value = u.unscaledValue = o;
        }, r.init = function() {
            var e = r.options;
            r.model.label = e.label ? e.label + ": " : "", r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.print", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0,
            freq: 1
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                counter: 0
            },
            strideInputs: [ "source" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.distortion = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u = r.model, s = r.output, l = r.inputs.source.output, c = u.strides.source, f = r.inputs.gain.output, d = u.strides.gain;
            for (o = a = i = 0; o < e; o++, a += c, i += d) n = 1.5 * (t = l[a] * f[i]) - .5 * t * t * t, 
            s[o] = n;
            u.unscaledValue = n, r.mulAdd(e), u.value = flock.ugen.lastOutputValue(e, s);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.distortion", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1
        },
        ugenOptions: {
            strideInputs: [ "source", "gain" ]
        }
    }), flock.ugen.distortion.tanh = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.output, u = r.inputs.source.output, s = a.strides.source;
            for (n = o = 0; n < e; n++, o += s) t = Math.tanh(u[n]), i[n] = t;
            a.unscaledValue = t, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.distortion.tanh", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            strideInputs: [ "source" ]
        }
    }), flock.ugen.distortion.deJonge = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.output, f = r.inputs.source.output, d = l.strides.source, p = r.inputs.amount.output, m = l.strides.amount;
            for (i = u = s = 0; i < e; i++, u += d, s += m) t = f[u], n = p[s], a = t * ((o = Math.abs(t)) + n) / (t * t + (n - 1) * o + 1), 
            c[i] = a;
            l.unscaledValue = a, r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, c);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.distortion.deJonge", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 2
        },
        ugenOptions: {
            strideInputs: [ "source", "amount" ]
        }
    }), flock.ugen.distortion.tarrabiaDeJonge = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.output, f = r.inputs.source.output, d = l.strides.source, p = r.inputs.amount.output, m = l.strides.amount;
            for (a = i = u = 0; a < e; a++, i += d, u += m) t = f[i], (n = p[u]) >= 1 ? n = .9999999999999999 : n < -1 && (n = -1), 
            o = (1 + (s = 2 * n / (1 - n))) * t / (1 + s * Math.abs(t)), c[a] = o;
            l.unscaledValue = o, r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, c);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.distortion.tarrabiaDeJonge", {
        rate: "audio",
        inputs: {
            source: null,
            amount: 10
        },
        ugenOptions: {
            strideInputs: [ "source", "amount" ]
        }
    }), flock.ugen.distortion.gloubiBoulga = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.output, f = r.inputs.source.output, d = l.strides.source, p = r.inputs.gain.output, m = l.strides.gain;
            for (n = o = a = 0; n < e; n++, o += d, a += m) i = .686306 * (f[o] * p[a]), u = 1 + Math.exp(-.75 * Math.sqrt(Math.abs(i))), 
            t = ((s = Math.exp(i)) - Math.exp(-i * u)) / (s + Math.exp(-i)), c[n] = t;
            l.unscaledValue = t, r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, c);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.distortion.gloubiBoulga", {
        rate: "audio",
        inputs: {
            source: null,
            gain: 1
        },
        ugenOptions: {
            strideInputs: [ "source", "gain" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.normalize = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function() {
            var e = r.model, t = r.output, n = r.inputs.max.output[0], o = r.inputs.source.output;
            flock.normalize(o, n, t), e.value = e.unscaledValue = t[t.length - 1];
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.normalize", {
        rate: "audio",
        inputs: {
            max: 1,
            source: null
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery"), t = flock.requireModule("webarraymath", "ArrayMath");
    flock.envelope = {}, flock.envelope.makeCreator = function(t, n) {
        return function(r) {
            var o = flock.ugenDefaults(t), a = e.extend(!0, {}, o, r);
            return n(a);
        };
    }, flock.envelope.registerCreators = function(e, t) {
        var n, r;
        for (var o in t) n = fluid.pathUtil.composePath(e, o), r = t[o], flock.ugenDefaults(n, r.defaults), 
        fluid.setGlobalValue(n, flock.envelope.makeCreator(n, r.transformer));
    }, flock.envelope.creatorSpecs = {
        line: {
            transformer: function(e) {
                return {
                    levels: [ e.start, e.end ],
                    times: [ e.duration ]
                };
            },
            defaults: {
                start: 0,
                end: 1,
                duration: 1
            }
        },
        linear: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, e.level, 0 ],
                    times: [ e.attack, e.sustain, e.release ]
                };
            },
            defaults: {
                level: 1,
                attack: .01,
                sustain: 1,
                release: 1
            }
        },
        tri: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, 0 ],
                    times: [ e.duration, e.duration ]
                };
            },
            defaults: {
                level: 1,
                duration: 1
            }
        },
        sin: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.level, 0 ],
                    times: [ e.duration, e.duration ],
                    curve: "sin"
                };
            },
            defaults: {
                level: 1,
                duration: 1
            }
        },
        asr: {
            transformer: function(e) {
                return {
                    levels: [ 0, e.sustain, 0 ],
                    times: [ e.attack, e.release ],
                    sustainPoint: 1,
                    curve: -4
                };
            },
            defaults: {
                sustain: 1,
                attack: .01,
                release: 1
            }
        },
        dadsr: {
            transformer: function(e) {
                var n = [ 0, 0, e.peak, e.peak * e.sustain, 0 ];
                return t.add(n, e.bias, n), {
                    levels: n,
                    times: [ e.delay, e.attack, e.decay, e.release ],
                    sustainPoint: 3,
                    curve: -4
                };
            },
            defaults: {
                delay: .1,
                attack: .01,
                decay: .3,
                sustain: .5,
                release: 1,
                peak: 1,
                bias: 0
            }
        },
        adsr: {
            transformer: function(e) {
                var n = [ 0, e.peak, e.peak * e.sustain, 0 ];
                return t.add(n, e.bias, n), {
                    levels: n,
                    times: [ e.attack, e.decay, e.release ],
                    sustainPoint: 2,
                    curve: -4
                };
            },
            defaults: {
                attack: .01,
                decay: .3,
                sustain: .5,
                release: 1,
                peak: 1,
                bias: 0
            }
        }
    }, flock.envelope.registerCreators("flock.envelope", flock.envelope.creatorSpecs), 
    flock.envelope.validate = function(e, t) {
        var n = e.levels, r = {};
        if (e.times ? !n || n.length < 2 ? r.levels = "An array containing at least two levels must be specified." : (flock.envelope.validate.times(e.times, n, r), 
        flock.envelope.validate.levels(n, r), flock.envelope.validate.curves(e.curve, n, r), 
        flock.envelope.validate.sustainPoint(e.sustainPoint, n, r)) : r.times = "An array containing at least one time value must be specified.", 
        !1 !== t) for (var o in r) flock.fail(r[o]);
        return r;
    }, flock.envelope.validate.times = function(e, t, n) {
        e.length !== t.length - 1 && (n.times = "The envelope specification should provide one fewer time value than the number of level values. times: " + e + " levels: " + t);
        for (var r = 0; r < e.length; r++) {
            var o = e[r];
            isNaN(o) && (n.times = "A NaN time value was specified at index " + r + ". times: " + e), 
            o < 0 && (n.times = "All times should be positive values. times: " + e);
        }
    }, flock.envelope.validate.levels = function(e, t) {
        for (var n = 0; n < e.length; n++) isNaN(e[n]) && (t.levels = "A NaN level value was specified at index " + n + ". levels: " + e);
    }, flock.envelope.validate.curves = function(e, t, n) {
        if (!e) return n;
        flock.isIterable(e) && (e.length !== t.length - 1 && (n.curve = "When curve is specified as an array, there should be one fewer curve value than the number of level values. curve: " + e + " levels: " + t), 
        fluid.each(e, function(t) {
            flock.lineGenerator(t) || (n.curve = "'" + t + "' is not a valid curve type. curve: " + e);
        })), flock.lineGenerator(e) || (n.curve = "'" + e + "' is not a valid curve type.");
    }, flock.envelope.validate.sustainPoint = function(e, t, n) {
        (e < 0 || e >= t.length) && (n.sustainPoint = "The specified sustainPoint index is out range for the levels array. sustainPoint: " + e + " levels: " + t);
    }, flock.envelope.expand = function(e) {
        var t = "string" == typeof e ? fluid.invokeGlobalFunction(e) : e.type ? fluid.invokeGlobalFunction(e.type, [ e ]) : e;
        if (t.curves && !t.curve && (t.curve = t.curves), !flock.isIterable(t.curve)) {
            var n = t.levels.length - 1;
            t.curve = flock.fillBufferWithValue(new Array(n), t.curve);
        }
        return flock.envelope.validate(t, !0), t;
    }, flock.fillBufferWithLine = function(e, t, n, r, o, a) {
        o = void 0 === o ? 0 : o;
        var i = (a = void 0 === a ? t.length : a) - o, u = flock.fillBufferWithLine.singletonModel;
        u.unscaledValue = n, u.destination = r, u.numSegmentSamps = i - 1, "number" == typeof e && (u.currentCurve = e, 
        e = "curve");
        var s = flock.line[e];
        return s || flock.fail("No line generator could be found for type " + e), s.init(u), 
        s.gen(i, o, t, u);
    }, flock.fillBufferWithLine.singletonModel = {
        unscaledValue: 0,
        value: 0,
        destination: 1
    }, flock.lineGenerator = function(e) {
        var t = typeof e;
        return "string" === t ? flock.line[e] : "number" === t ? flock.line.curve : flock.line.linear;
    }, flock.line = {
        constant: {
            init: function(e) {
                e.stepSize = 0;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = t; a < e + t; a++) n[a] = o;
                return n;
            }
        },
        step: {
            init: function(e) {
                e.arrived = !1;
            },
            gen: function(e, t, n, r) {
                for (var o = t; o < e + t; o++) n[o] = r.unscaledValue, r.arrived || (r.arrived = !0, 
                r.unscaledValue = r.destination);
                return n;
            }
        },
        linear: {
            init: function(e) {
                e.stepSize = (e.destination - e.unscaledValue) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.stepSize, i = t; i < e + t; i++) n[i] = o, o += a;
                return r.unscaledValue = o, n;
            }
        },
        exponential: {
            init: function(e) {
                0 === e.unscaledValue && (e.unscaledValue = 1e-16), e.stepSize = 0 === e.numSegmentSamps ? 0 : Math.pow(e.destination / e.unscaledValue, 1 / e.numSegmentSamps);
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.stepSize, i = t; i < e + t; i++) n[i] = o, o *= a;
                return r.unscaledValue = o, r.stepSize = a, n;
            }
        },
        curve: {
            init: function(e) {
                if (Math.abs(e.currentCurve) < .001) return flock.line.linear.init(e);
                var t = (e.destination - e.unscaledValue) / (1 - Math.exp(e.currentCurve));
                e.a2 = e.unscaledValue + t, e.b1 = t, e.stepSize = Math.exp(e.currentCurve / e.numSegmentSamps);
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.b1, i = t; i < e + t; i++) n[i] = o, a *= r.stepSize, 
                o = r.a2 - a;
                return r.unscaledValue = o, r.b1 = a, n;
            }
        },
        sin: {
            init: function(e) {
                var t = Math.PI / e.numSegmentSamps;
                e.a2 = .5 * (e.destination + e.unscaledValue), e.b1 = 2 * Math.cos(t), e.y1 = .5 * (e.destination - e.unscaledValue), 
                e.y2 = e.y1 * Math.sin(flock.HALFPI - t), e.unscaledValue = e.a2 - e.y1;
            },
            gen: function(e, t, n, r) {
                for (var o, a = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = a, 
                o = r.b1 * i - u, a = r.a2 - o, u = i, i = o;
                return r.unscaledValue = a, r.y1 = i, r.y2 = u, n;
            }
        },
        welsh: {
            init: function(e) {
                var t = flock.HALFPI / e.numSegmentSamps, n = Math.cos(t);
                e.b1 = 2 * n, e.destination >= e.unscaledValue ? (e.a2 = e.unscaledValue, e.y1 = 0, 
                e.y2 = -Math.sin(t) * (e.destination - e.unscaledValue)) : (e.a2 = e.destination, 
                e.y1 = e.unscaledValue - e.destination, e.y2 = n * (e.unscaledValue - e.destination)), 
                e.unscaledValue = e.a2 + e.y1;
            },
            gen: function(e, t, n, r) {
                for (var o, a = r.unscaledValue, i = r.y1, u = r.y2, s = t; s < e + t; s++) n[s] = a, 
                o = r.b1 * i - u, u = i, i = o, a = r.a2 + o;
                return r.unscaledValue = a, r.y1 = i, r.y2 = u, n;
            }
        },
        squared: {
            init: function(e) {
                e.y1 = Math.sqrt(e.unscaledValue), e.y2 = Math.sqrt(e.destination), e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.y1, i = t; i < e + t; i++) n[i] = o, o = (a += r.stepSize) * a;
                return r.y1 = a, r.unscaledValue = o, n;
            }
        },
        cubed: {
            init: function(e) {
                e.y1 = Math.pow(e.unscaledValue, .3333333333333333), e.y2 = Math.pow(e.destination, .3333333333333333), 
                e.stepSize = (e.y2 - e.y1) / e.numSegmentSamps;
            },
            gen: function(e, t, n, r) {
                for (var o = r.unscaledValue, a = r.y1, i = t; i < e + t; i++) n[i] = o, o = (a += r.stepSize) * a * a;
                return r.y1 = a, r.unscaledValue = o, n;
            }
        }
    }, flock.ugen.line = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n = r.model, o = n.stepSize, a = n.numSteps, i = a >= e ? e : a, u = e - i, s = n.level, l = r.output;
            for (t = 0; t < i; t++) l[t] = s, a--, s += o;
            if (u > 0) for (t = 0; t < u; t++) l[t] = s;
            n.level = n.unscaledValue = s, n.numSteps = a, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, l);
        }, r.onInputChanged = function() {
            var e = r.model;
            e.start = r.inputs.start.output[0], e.end = r.inputs.end.output[0], e.numSteps = Math.round(r.inputs.duration.output[0] * e.sampleRate), 
            0 === e.numSteps ? (e.stepSize = 0, e.level = e.end) : (e.stepSize = (e.end - e.start) / e.numSteps, 
            e.level = e.start), flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.line", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            duration: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0,
                end: 1,
                numSteps: 0,
                stepSize: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.xLine = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n = r.model, o = n.multiplier, a = n.numSteps, i = a >= e ? e : a, u = e - i, s = n.level, l = r.output;
            for (t = 0; t < i; t++) l[t] = s, a--, s *= o;
            if (u > 0) for (t = 0; t < u; t++) l[t] = s;
            n.level = n.unscaledValue = s, n.numSteps = a, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, l);
        }, r.onInputChanged = function() {
            var e = r.model;
            flock.onMulAddInputChanged(r), e.start = r.inputs.start.output[0], 0 === e.start && (e.start = 1e-101), 
            e.end = r.inputs.end.output[0], e.numSteps = Math.round(r.inputs.duration.output[0] * e.sampleRate), 
            e.multiplier = Math.pow(e.end / e.start, 1 / e.numSteps), e.level = e.start;
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.xLine", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            duration: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                start: 0,
                end: 1,
                numSteps: 0,
                multiplier: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.asr = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.output, i = o.previousGate, u = r.inputs.gate.output[0], s = o.level, l = o.stage, c = l.currentStep, f = l.stepInc, d = l.numSteps, p = o.targetLevel, m = !1;
            for (i <= 0 && u > 0 ? (p = r.inputs.sustain.output[0], t = r.inputs.attack.output[0], 
            m = !0) : i >= 0 && u <= 0 && c >= d && (p = r.inputs.start.output[0], t = r.inputs.release.output[0], 
            m = !0), m && (f = (d = Math.round(t * o.sampleRate)) > 0 ? (p - s) / d : 0, c = 0, 
            d < 1 && (s = p)), n = 0; n < e; n++) a[n] = s, s = ++c < d ? s + f : c === d ? p : s;
            o.level = o.unscaledValue = s, o.targetLevel = p, o.previousGate = u, l.currentStep = c, 
            l.stepInc = f, l.numSteps = d, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, r.init = function() {
            var e = r.model;
            e.level = e.unscaledValue = r.inputs.start.output[0], e.targetLevel = r.inputs.sustain.output[0], 
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.asr", {
        rate: "control",
        inputs: {
            start: 0,
            attack: .01,
            sustain: 1,
            release: 1,
            gate: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                level: 0,
                targetLevel: 0,
                previousGate: 0,
                unscaledValue: 0,
                value: 0,
                stage: {
                    currentStep: 0,
                    stepInc: 0,
                    numSteps: 0
                }
            }
        }
    }), flock.ugen.env = {}, flock.ugen.env.simpleASR = flock.ugen.asr, flock.ugenDefaults("flock.ugen.env.simpleASR", fluid.copy(flock.ugenDefaults("flock.ugen.asr"))), 
    flock.ugen.envGen = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.krGen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs, i = a.gate.output[0], u = a.timeScale.output[0], s = 0;
            for (flock.ugen.envGen.checkGate(r, i, u); s < e; ) t = Math.min(e - s, n.numSegmentSamps), 
            r.lineGen.gen(t, s, o, n), s += t, n.numSegmentSamps -= t, n.numSegmentSamps <= 0 && flock.ugen.envGen.nextStage(r, u);
            r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.arGen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs, i = a.gate.output, u = a.timeScale.output[0];
            for (t = 0; t < e; t++) flock.ugen.envGen.checkGate(r, i[t], u), r.lineGen.gen(1, t, o, n), 
            n.numSegmentSamps--, n.numSegmentSamps <= 0 && flock.ugen.envGen.nextStage(r, u);
            r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function(e) {
            e && "envelope" !== e || (r.envelope = flock.ugen.envGen.initEnvelope(r, r.inputs.envelope)), 
            e && "gate" !== e || (r.gen = r.inputs.gate.rate === flock.rates.AUDIO ? r.arGen : r.krGen), 
            flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugen.envGen.initEnvelope = function(e, t) {
        var n = e.model, r = flock.envelope.expand(t);
        return n.stage = 0, n.numStages = r.times.length, e.lineGen = flock.line.constant, 
        flock.ugen.envGen.lineGenForStage(e.inputs.timeScale.output[0], r, n), n.unscaledValue = r.levels[n.stage], 
        r;
    }, flock.ugen.envGen.checkGate = function(e, t, n) {
        var r = e.model, o = e.envelope;
        t !== r.previousGate && (t > 0 && r.previousGate <= 0 ? (r.stage = 1, e.lineGen = flock.ugen.envGen.lineGenForStage(n, o, r)) : t <= 0 && r.previousGate > 0 && (r.stage = r.numStages, 
        e.lineGen = flock.ugen.envGen.lineGenForStage(n, o, r))), r.previousGate = t;
    }, flock.ugen.envGen.nextStage = function(e, t) {
        var n = e.model, r = e.envelope;
        n.stage === r.sustainPoint ? (e.lineGen = flock.line.constant, n.numSegmentSamps = 1 / 0, 
        n.destination = n.unscaledValue) : (n.stage++, e.lineGen = flock.ugen.envGen.lineGenForStage(t, r, n));
    }, flock.ugen.envGen.setupStage = function(e, t, n) {
        var r, o, a = t.levels[n.stage];
        0 === n.stage || n.stage > n.numStages ? o = 1 / 0 : (r = t.times[n.stage - 1] * e, 
        o = Math.max(1, Math.round(r * n.sampleRate))), n.numSegmentSamps = o, n.destination = a;
    }, flock.ugen.envGen.lineGenForStage = function(e, t, n) {
        var r, o, a = t.curve;
        return 0 === n.stage || n.stage > n.numStages ? r = flock.line.constant : (o = a[n.stage - 1], 
        n.currentCurve = o, r = flock.lineGenerator(o)), flock.ugen.envGen.setupStage(e, t, n), 
        r.init(n), r;
    }, flock.ugenDefaults("flock.ugen.envGen", {
        rate: "audio",
        inputs: {
            envelope: "flock.envelope.adsr",
            gate: 0,
            timeScale: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                previousGate: 0,
                stepSize: 0,
                destination: 0,
                numSegmentSamps: 1,
                unscaledValue: 0,
                value: 0,
                stage: 0,
                numStages: 0
            }
        }
    }), flock.ugen.phasor = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs, u = r.output, s = i.step.output, l = i.trigger.output;
            for (void 0 === a.unscaledValue && (a.unscaledValue = i.start.output[0]), t = 0, 
            n = 0, o = 0; t < e; t++, n += a.strides.trigger, o += a.strides.step) l[n] > 0 && a.prevTrig <= 0 && (a.unscaledValue = i.reset.output[0]), 
            a.prevTrig = l[n], a.unscaledValue >= i.end.output[0] && (a.unscaledValue = i.start.output[0]), 
            u[t] = a.unscaledValue, a.unscaledValue += s[o];
            r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.phasor", {
        rate: "control",
        inputs: {
            start: 0,
            end: 1,
            reset: 0,
            step: .1,
            trigger: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: void 0,
                value: 0
            },
            strideInputs: [ "trigger", "step" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = flock.requireModule("webarraymath", "Filter");
    flock.ugen.lag = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.output, s = r.inputs, l = s.time.output[0], c = s.source.output, f = i.prevSamp, d = i.lagCoef;
            for (l !== i.prevTime && (i.prevtime = l, d = i.lagCoef = 0 === l ? 0 : Math.exp(flock.LOG001 / (l * i.sampleRate))), 
            t = n = 0; t < e; t++, n += i.strides.source) a = (o = c[n]) + d * (f - o), u[t] = f = a;
            i.prevSamp = f, r.mulAdd(e);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.lag", {
        rate: "audio",
        inputs: {
            source: null,
            time: .1
        },
        ugenOptions: {
            strideInputs: [ "source" ],
            model: {
                prevSamp: 0,
                lagCoef: 0,
                prevTime: 0
            }
        }
    }), flock.ugen.filter = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.gen = function() {
            var e = o.model, t = o.output, n = o.inputs, r = n.q.output[0], a = n.freq.output[0];
            e.prevFreq === a && e.prevQ === r || o.updateCoefficients(e, a, r), o.filterEngine.filter(t, o.inputs.source.output), 
            e.prevQ = r, e.prevFreq = a, e.value = e.unscaledValue = t[t.length - 1];
        }, o.init = function() {
            var t = o.options.recipe, n = "string" == typeof t ? flock.get(t) : t;
            if (!n) throw new Error("Can't instantiate a flock.ugen.filter() without specifying a filter coefficient recipe.");
            o.filterEngine = new e(n.sizes.b, n.sizes.a), o.model.coeffs = {
                a: o.filterEngine.a,
                b: o.filterEngine.b
            }, o.updateCoefficients = flock.get(n, o.options.type), o.onInputChanged();
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.filter", {
        rate: "audio",
        inputs: {
            freq: 440,
            q: 1,
            source: null
        }
    }), flock.ugen.filter.biquad = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.inputs, i = r.output, u = o.coeffs, s = a.freq.output[0], l = a.q.output[0], c = a.source.output;
            for (o.prevFreq === s && o.prevQ === l || r.updateCoefficients(o, s, l), t = 0; t < e; t++) n = c[t] - u.a[0] * o.d0 - u.a[1] * o.d1, 
            i[t] = u.b[0] * n + u.b[1] * o.d0 + u.b[2] * o.d1, o.d1 = o.d0, o.d0 = n;
            o.prevQ = l, o.prevFreq = s, o.value = o.unscaledValue = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged = function() {
            var e = r.options.type;
            r.updateCoefficients = "string" == typeof e ? flock.get(e) : e;
        }, r.init = function() {
            r.model.d0 = 0, r.model.d1 = 0, r.model.coeffs = {
                a: new Float32Array(2),
                b: new Float32Array(3)
            }, r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.filter.biquad", {
        inputs: {
            freq: 440,
            q: 1,
            source: null
        }
    }), flock.ugen.filter.biquad.types = {
        hp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.highPass"
            }
        },
        rhp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.rbj.highPass"
            }
        },
        lp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.lowPass"
            }
        },
        rlp: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.rbj.lowPass"
            }
        },
        bp: {
            inputDefaults: {
                freq: 440,
                q: 4
            },
            options: {
                type: "flock.coefficients.butterworth.bandPass"
            }
        },
        br: {
            inputDefaults: {
                freq: 440,
                q: 1
            },
            options: {
                type: "flock.coefficients.butterworth.bandReject"
            }
        }
    }, flock.aliasUGens("flock.ugen.filter.biquad", flock.ugen.filter.biquad.types), 
    flock.coefficients = {
        butterworth: {
            sizes: {
                a: 2,
                b: 3
            },
            lowPass: function(e, t) {
                var n = e.coeffs, r = 1 / Math.tan(Math.PI * t / e.sampleRate), o = r * r, a = flock.ROOT2 * r, i = 1 / (1 + a + o);
                n.b[0] = i, n.b[1] = 2 * i, n.b[2] = i, n.a[0] = 2 * (1 - o) * i, n.a[1] = (1 - a + o) * i;
            },
            highPass: function(e, t) {
                var n = e.coeffs, r = Math.tan(Math.PI * t / e.sampleRate);
                r === 1 / 0 && (r = 0);
                var o = r * r, a = flock.ROOT2 * r, i = 1 / (1 + a + o);
                n.b[0] = i, n.b[1] = -2 * i, n.b[2] = i, n.a[0] = 2 * (o - 1) * i, n.a[1] = (1 - a + o) * i;
            },
            bandPass: function(e, t, n) {
                var r = e.coeffs, o = t / n, a = 1 / Math.tan(Math.PI * o / e.sampleRate), i = 2 * Math.cos(flock.TWOPI * t / e.sampleRate), u = 1 / (1 + a);
                r.b[0] = u, r.b[1] = 0, r.b[2] = -u, r.a[0] = -a * i * u, r.a[1] = u * (a - 1);
            },
            bandReject: function(e, t, n) {
                var r = e.coeffs, o = t / n, a = Math.tan(Math.PI * o / e.sampleRate), i = 1 / (1 + a), u = -(2 * Math.cos(flock.TWOPI * t / e.sampleRate)) * i;
                r.b[0] = i, r.b[1] = u, r.b[2] = i, r.a[0] = u, r.a[1] = (1 - a) * i;
            }
        },
        rbj: {
            sizes: {
                a: 2,
                b: 3
            },
            lowPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 - a, s = 1 + i, l = u / 2 / s;
                r.b[0] = l, r.b[1] = u / s, r.b[2] = l, r.a[0] = -2 * a / s, r.a[1] = (1 - i) / s;
            },
            highPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + a, s = 1 + i, l = u / 2 / s;
                r.b[0] = l, r.b[1] = -u / s, r.b[2] = l, r.a[0] = -2 * a / s, r.a[1] = (1 - i) / s;
            },
            bandPass: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + i, s = n * i;
                r.b[0] = s / u, r.b[1] = 0, r.b[2] = -s / u, r.a[0] = -2 * a / u, r.a[1] = (1 - i) / u;
            },
            bandReject: function(e, t, n) {
                var r = e.coeffs, o = flock.TWOPI * t / e.sampleRate, a = Math.cos(o), i = Math.sin(o) / (2 * n), u = 1 + i, s = 1 / u, l = -2 * a / u;
                r.b[0] = s, r.b[1] = l, r.b[2] = s, r.a[0] = l, r.a[1] = (1 - i) / u;
            }
        }
    }, flock.ugen.filter.moog = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.inputs, f = r.output, d = c.source.output, p = l.strides.source, m = c.resonance.output, g = l.strides.resonance, h = c.cutoff.output, v = l.strides.cutoff, y = l.f, k = l.fSq, b = l.fSqSq, x = l.oneMinusF, S = l.fb;
            for (t = n = o = a = 0; t < e; t++, n += p, o += g, a += v) i = h[a], u = m[o], 
            i !== l.prevCutoff && (i > l.nyquistRate && (i = l.nyquistRate), y = l.f = i / l.nyquistRate * 1.16, 
            k = l.fSq = y * y, b = l.fSqSq = k * k, x = l.oneMinusF = 1 - y, l.prevRes = void 0), 
            u !== l.prevRes && (u > 4 ? u = 4 : u < 0 && (u = 0), S = l.fb = u * (1 - .15 * k)), 
            s = d[n] - l.out4 * S, s *= .35013 * b, l.out1 = s + .3 * l.in1 + x * l.out1, l.in1 = s, 
            l.out2 = l.out1 + .3 * l.in2 + x * l.out2, l.in2 = l.out1, l.out3 = l.out2 + .3 * l.in3 + x * l.out3, 
            l.in3 = l.out2, l.out4 = l.out3 + .3 * l.in4 + x * l.out4, l.in4 = l.out3, f[t] = l.out4;
            l.unscaledValue = l.out4, r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, f);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.filter.moog", {
        rate: "audio",
        inputs: {
            cutoff: 3e3,
            resonance: 3.99,
            source: null
        },
        ugenOptions: {
            model: {
                in1: 0,
                in2: 0,
                in3: 0,
                in4: 0,
                out1: 0,
                out2: 0,
                out3: 0,
                out4: 0,
                prevCutoff: void 0,
                prevResonance: void 0,
                f: void 0,
                fSq: void 0,
                fSqSq: void 0,
                oneMinusF: void 0,
                fb: void 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "source", "cutoff", "resonance" ]
        }
    }), flock.ugen.delay = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.inputs, i = r.output, u = a.source.output, s = a.time.output[0], l = r.delayBuffer;
            for (s !== o.time && (o.time = s, o.delaySamps = s * r.model.sampleRate), t = 0; t < e; t++) o.pos >= o.delaySamps && (o.pos = 0), 
            i[t] = n = l[o.pos], l[o.pos] = u[t], o.pos++;
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged = function(e) {
            if (flock.onMulAddInputChanged(r), !e || "maxTime" === e) {
                var t = r.model.sampleRate * r.inputs.maxTime.output[0];
                r.delayBuffer = new Float32Array(t);
            }
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.delay", {
        rate: "audio",
        inputs: {
            maxTime: 1,
            time: 1,
            source: null
        },
        ugenOptions: {
            model: {
                pos: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.delay1 = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.inputs, i = r.output, u = a.source.output, s = o.prevVal;
            for (t = 0; t < e; t++) i[t] = n = s, s = u[t];
            o.prevVal = s, o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged = function() {
            flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.delay1", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            model: {
                prevVal: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.freeverb = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.tunings = r.options.tunings, r.allpassTunings = r.options.allpassTunings, 
        r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs, u = r.output, s = i.source.output, l = i.mix.output[0], c = 1 - l, f = .28 * i.room.output[0] + .7, d = .4 * i.damp.output[0], p = 1 - d;
            for (t = 0; t < e; t++) {
                var m = s[t], g = .015 * m;
                for (n = 0; n < r.buffers_a.length; n++) ++r.bufferindices_a[n] === r.allpassTunings[n] && (r.bufferindices_a[n] = 0), 
                r.readsamp_a[n] = r.buffers_a[n][r.bufferindices_a[n]];
                for (n = 0; n < r.buffers_c.length; n++) {
                    ++r.bufferindices_c[n] === r.tunings[n] && (r.bufferindices_c[n] = 0);
                    var h = r.bufferindices_c[n], v = r.buffers_c[n][h];
                    r.filterx_c[n] = p * r.filtery_c[n] + d * r.filterx_c[n], r.buffers_c[n][h] = g + f * r.filterx_c[n], 
                    r.filtery_c[n] = v;
                }
                var y = r.filtery_c[6] + r.filtery_c[7];
                r.buffers_a[3][r.bufferindices_a[3]] = .5 * r.filterx_a[3] + r.filtery_c[0] + (r.filtery_c[1] + r.filtery_c[2]) + (r.filtery_c[3] + r.filtery_c[4] + (r.filtery_c[5] + y)), 
                r.filterx_a[3] = r.readsamp_a[3], r.filtery_a[3] = r.filterx_a[3] - (r.filtery_c[0] + r.filtery_c[1] + (r.filtery_c[2] + r.filtery_c[3]) + (r.filtery_c[4] + r.filtery_c[5] + y)), 
                r.buffers_a[2][r.bufferindices_a[2]] = .5 * r.filterx_a[2] + r.filtery_a[3], r.filterx_a[2] = r.readsamp_a[2], 
                r.filtery_a[2] = r.filterx_a[2] - r.filtery_a[3], r.buffers_a[1][r.bufferindices_a[1]] = .5 * r.filterx_a[1] + r.filtery_a[2], 
                r.filterx_a[1] = r.readsamp_a[1], r.filtery_a[1] = r.filterx_a[1] - r.filtery_a[2], 
                r.buffers_a[0][r.bufferindices_a[0]] = .5 * r.filterx_a[0] + r.filtery_a[1], r.filterx_a[0] = r.readsamp_a[0], 
                r.filtery_a[0] = r.filterx_a[0] - r.filtery_a[1], o = c * m + l * r.filtery_a[0], 
                u[t] = o;
            }
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.initDelayLines = function() {
            r.buffers_c = new Array(8), r.bufferindices_c = new Int32Array(8), r.filterx_c = new Float32Array(8), 
            r.filtery_c = new Float32Array(8);
            var e, t, n = r.model.spread;
            for (e = 0; e < r.buffers_c.length; e++) for (r.buffers_c[e] = new Float32Array(r.tunings[e] + n), 
            r.bufferindices_c[e] = 0, r.filterx_c[e] = 0, r.filtery_c[e] = 0, t = 0; t < r.tunings[e] + n; t++) r.buffers_c[e][t] = 0;
            for (r.buffers_a = new Array(4), r.bufferindices_a = new Int32Array(4), r.filterx_a = new Float32Array(4), 
            r.filtery_a = new Float32Array(4), r.readsamp_a = new Float32Array(4), e = 0; e < r.buffers_a.length; e++) {
                for (r.bufferindices_a[e] = 0, r.filterx_a[e] = 0, r.filtery_a[e] = 0, r.readsamp_a[e] = 0, 
                t = 0; t < r.allpassTunings.length; t++) r.allpassTunings[t] += n;
                for (r.buffers_a[e] = new Float32Array(r.allpassTunings[e]), t = 0; t < r.allpassTunings[e]; t++) r.buffers_a[e][t] = 0;
            }
        }, r.init = function() {
            r.initDelayLines(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.freeverb", {
        rate: "audio",
        inputs: {
            source: null,
            mix: .33,
            room: .5,
            damp: .5
        },
        ugenOptions: {
            model: {
                spread: 0,
                unscaledValue: 0,
                value: 0
            },
            tunings: [ 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 ],
            allpassTunings: [ 556, 441, 341, 225 ]
        }
    }), flock.ugen.decay = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.inputs, i = r.output, u = a.source.output, s = a.time.output[0];
            if (s !== o.time && (o.time = s, o.coeff = 0 === s ? 0 : Math.exp(flock.LOG001 / (s * r.model.sampleRate))), 
            0 === o.coeff) for (t = 0; t < e; t++) i[t] = n = u[t]; else for (t = 0; t < e; t++) o.lastSamp = u[t] + o.coeff * o.lastSamp, 
            i[t] = n = o.lastSamp;
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, i);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.decay", {
        rate: "audio",
        inputs: {
            source: null,
            time: 1
        },
        ugenOptions: {
            model: {
                time: 0,
                lastSamp: 0,
                coeff: 0,
                value: 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.gate = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = i.strides, s = r.output, l = r.inputs, c = l.source.output, f = l.sideChain.output, d = u.sideChain, p = l.threshold.output, m = u.threshold, g = r.options.holdLastValue, h = i.lastValue;
            for (t = n = o = 0; t < e; t++, n += d, o += m) f[n] >= p[o] ? s[t] = a = h = c[t] : s[t] = a = g ? h : 0;
            i.lastValue = h, i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, s);
        }, r.onInputChanged = function() {
            r.inputs.sideChain || (r.inputs.sideChain = r.inputs.source), flock.onMulAddInputChanged(r), 
            r.calculateStrides();
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.gate", {
        rate: "audio",
        inputs: {
            source: null,
            sideChain: null,
            threshold: Number.MIN_VALUE,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                lastValue: 0
            },
            holdLastValue: !1,
            strideInputs: [ "sideChain", "threshold" ]
        }
    }), flock.ugen.timedGate = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.output, s = r.inputs.trigger.output, l = r.inputs.duration.output[0];
            for (l !== i.duration && (i.duration = l, i.durationSamps = Math.floor(l * i.sampleRate)), 
            n = o = 0; n < e; n++, o += i.strides.trigger) (t = s[o]) > 0 && i.prevTrigger <= 0 ? (a = r.options.resetOnTrigger && i.sampsRemaining > 0 ? 0 : 1, 
            i.sampsRemaining = i.durationSamps) : a = i.sampsRemaining > 0 ? 1 : 0, u[n] = a, 
            i.sampsRemaining--, i.prevTrigger = t;
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.timedGate", {
        rate: "audio",
        inputs: {
            trigger: 0,
            duration: 1
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevTrigger: 0,
                sampsRemaining: 0,
                durationSamps: 0,
                duration: 0
            },
            resetOnTrigger: !0,
            strideInputs: [ "trigger" ]
        }
    }), flock.ugen.latch = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.arGen = function(e) {
            var t, n, o, a, i = r.model, u = r.inputs, s = u.source.output, l = u.trigger, c = i.strides.source, f = r.output;
            for (void 0 === i.holdVal && (i.holdVal = s[0]), t = 0, n = 0; t < e; t++, n += c) (o = l.output[t]) > 0 && i.prevTrig <= 0 && (i.holdVal = s[n]), 
            a = i.holdVal, f[t] = a, i.prevTrig = o;
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, f);
        }, r.krGen = function(e) {
            var t, n = r.model, o = r.output, a = r.inputs.trigger.output[0];
            for ((void 0 === n.holdVal || a > 0 && n.prevTrig <= 0) && (n.holdVal = r.inputs.source.output[0]), 
            n.prevTrig = a, t = 0; t < e; t++) o[t] = n.holdVal;
            n.unscaledValue = n.holdVal, r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function() {
            r.calculateStrides(), r.gen = r.inputs.trigger.rate === flock.rates.AUDIO ? r.arGen : r.krGen, 
            flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.latch", {
        rate: "audio",
        inputs: {
            source: null,
            trigger: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "source" ],
            model: {
                prevTrig: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.triggerGrains = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.inputs, f = r.output, d = c.channel.output[0], p = r.buffer.data.channels[d], m = r.buffer.format.sampleRate, g = c.dur.output[0], h = c.amp.output, v = c.centerPos.output, y = c.trigger.output, k = c.speed.output, b = r.options.grainEnv, x = e - 1, S = 0, w = 0, C = 0, A = 0;
            for (t = 0; t < e; t++) {
                if (y[w] > 0 && l.prevTrigger <= 0 && l.activeGrains.length < l.maxNumGrains) {
                    for ((a = l.freeGrains.pop()).numSamps = l.sampleRate * g, a.centerIdx = a.numSamps / 2 * l.stepSize, 
                    a.envScale = r.options.grainEnv.length / a.numSamps, a.sampIdx = 0, a.amp = h[C], 
                    i = v[S] * m - a.centerIdx; i < 0; ) i += p.length;
                    a.readPos = i, a.writePos = t, a.speed = k[A], l.activeGrains.push(a);
                }
                l.prevTrigger = y[w], f[t] = 0, S += l.strides.centerPos, w += l.strides.trigger, 
                C += l.strides.amp, A += l.strides.speed;
            }
            for (n = 0; n < l.activeGrains.length; ) {
                for (o = (a = l.activeGrains[n]).writePos; o < Math.min(o + (a.numSamps - a.sampIdx), e); o++) u = r.interpolate(a.readPos, p), 
                s = flock.interpolate.linear(a.sampIdx * a.envScale, b), f[o] += u * s * a.amp, 
                a.readPos = (a.readPos + l.stepSize * a.speed) % p.length, a.sampIdx++;
                a.sampIdx >= a.numSamps ? (l.freeGrains.push(a), l.activeGrains.splice(n, 1)) : (n++, 
                a.writePos = o % e);
            }
            l.unscaledValue = f[x], r.mulAdd(e), l.value = f[x];
        }, r.onBufferReady = function() {
            var e = r.model;
            e.stepSize = r.buffer.format.sampleRate / e.sampleRate;
        }, r.onInputChanged = function(e) {
            r.onBufferInputChanged(e), r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.allocateGrains = function(e) {
            e = e || r.model.maxNumGrains;
            for (var t = 0; t < e; t++) r.model.freeGrains.push({
                numSamps: 0,
                centerIdx: 0,
                envScale: 0,
                sampIdx: 0,
                amp: 0,
                readPos: 0,
                writePos: 0,
                speed: 0
            });
        }, r.init = function() {
            flock.ugen.buffer(r), r.allocateGrains(), r.initBuffer(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.triggerGrains", {
        rate: "audio",
        inputs: {
            centerPos: 0,
            channel: 0,
            amp: 1,
            dur: .1,
            speed: 1,
            trigger: 0,
            buffer: null,
            mul: null,
            add: null
        },
        ugenOptions: {
            grainEnv: flock.fillTable(8192, flock.tableGenerators.hann),
            model: {
                unscaledValue: 0,
                value: 0,
                maxNumGrains: 512,
                activeGrains: [],
                freeGrains: [],
                env: null,
                strides: {}
            },
            strideInputs: [ "centerPos", "trigger", "amp", "speed" ],
            interpolation: "cubic"
        }
    }), flock.ugen.granulator = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u, s, l = r.model, c = r.options, f = r.inputs, d = r.output, p = r.delayLine, m = f.grainDur.output[0], g = f.delayDur.output[0], h = f.numGrains.output[0], v = f.source.output, y = c.maxDelayDur, k = c.grainEnv;
            for (l.delayDur !== g && (l.delayDur = g, g > y && (g = y), l.delayLength = g * l.sampleRate | 0, 
            l.writePos = l.writePos % l.delayLength), l.grainDur !== m && (l.grainDur = m, l.grainLength = l.sampleRate * l.grainDur | 0, 
            l.envScale = k.length / l.grainLength), h = h > c.maxNumGrains ? c.maxNumGrains : Math.round(h), 
            t = 0; t < e; t++) {
                for (p[l.writePos] = v[t], l.writePos = ++l.writePos % l.delayLength, o = 0, n = 0; n < h; n++) a = l.grainIdx[n], 
                i = l.delayLineIdx[n], a > l.grainLength && (a = 0, i = Math.random() * l.delayLength | 0), 
                u = p[i], s = a * l.envScale, o += u * flock.interpolate.linear(s, k), l.delayLineIdx[n] = ++i % l.delayLength, 
                l.grainIdx[n] = ++a;
                o /= h, d[t] = o;
            }
            l.unscaledValue = o, r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, d);
        }, r.initGrains = function() {
            for (var e = r.model, t = 0; t < r.options.maxNumGrains; t++) e.grainIdx[t] = 0, 
            e.delayLineIdx[t] = Math.random() * e.delayLength;
        }, r.init = function() {
            var e = r.model, t = r.options, n = t.maxDelayDur * e.sampleRate | 0;
            r.delayLine = new Float32Array(n), e.delayLength = n, e.delayLineIdx = new Uint32Array(t.maxNumGrains), 
            e.grainIdx = new Uint32Array(t.maxNumGrains), r.initGrains(), r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.granulator", {
        rate: "audio",
        inputs: {
            source: null,
            grainDur: .1,
            delayDur: 1,
            numGrains: 5,
            mul: null,
            add: null
        },
        ugenOptions: {
            maxNumGrains: 512,
            maxDelayDur: 30,
            grainEnv: flock.fillTable(8192, flock.tableGenerators.sinWindow),
            model: {
                unscaledValue: 0,
                value: 0,
                grainLength: 0,
                writePos: 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.amplitude = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.source.output, u = r.output, s = a.attackTime, l = r.inputs.attack.output[0], c = a.releaseTime, f = r.inputs.release.output[0], d = a.prevVal, p = a.attackCoef, m = a.releaseCoef;
            for (l !== s && (a.attackTime = l, p = a.attackCoef = 0 === l ? 0 : Math.exp(flock.LOG01 / (l * a.sampleRate))), 
            f !== c && (a.releaseTime = f, m = a.releaseCoef = 0 === f ? 0 : Math.exp(flock.LOG01 / (f * a.sampleRate))), 
            t = 0; t < e; t++) o = (n = Math.abs(i[t])) < d ? m : p, u[t] = d = n + (d - n) * o;
            a.unscaledValue = a.prevVal = d, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.amplitude", {
        rate: "audio",
        inputs: {
            source: null,
            attack: .01,
            release: .01,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                prevVal: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = flock.requireModule("webarraymath", "ArrayMath");
    flock.ugen.math = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.expandedRight = new Float32Array(o.options.audioSettings.blockSize), o.krSourceKrInputGen = function() {
            var t = o.model, n = o.activeInput, r = o.inputs[n], a = o.output, i = o.inputs.source.output[0], u = flock.fillBufferWithValue(o.expandedRight, r.output[0]);
            e[n](a, i, u), t.value = t.unscaledValue = a[a.length - 1];
        }, o.krSourceArInputGen = function() {
            var t = o.model, n = o.activeInput, r = o.inputs[n], a = o.output, i = o.inputs.source.output[0], u = r.output;
            e[n](a, i, u), t.value = t.unscaledValue = a[a.length - 1];
        }, o.arSourceKrInputGen = function() {
            var t = o.model, n = o.activeInput, r = o.inputs[n], a = o.output, i = o.inputs.source.output, u = flock.fillBufferWithValue(o.expandedRight, r.output[0]);
            e[n](a, i, u), t.value = t.unscaledValue = a[a.length - 1];
        }, o.arSourceArInputGen = function() {
            var t = o.model, n = o.activeInput, r = o.inputs[n], a = o.output, i = o.inputs.source.output, u = r.output;
            e[n](a, i, u), t.value = t.unscaledValue = a[a.length - 1];
        }, o.onInputChanged = function() {
            var e, t, n, r = Object.keys(o.inputs);
            for (e = 0; e < r.length; e++) if ("source" !== (t = r[e])) {
                o.activeInput = t, n = "audio" === o.inputs[t].rate, o.gen = "audio" === o.inputs.source.rate ? n ? o.arSourceArInputGen : o.arSourceKrInputGen : n ? o.krSourceArInputGen : o.krSourceKrInputGen;
                break;
            }
        }, o.init = function() {
            if (void 0 === e) throw new Error("ArrayMath is undefined. Please include webarraymath.js to use the flock.math unit generator.");
            o.onInputChanged();
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.math", {
        rate: "audio",
        inputs: {
            source: null
        }
    }), flock.ugen.sum = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.copyGen = function(e) {
            var t, n, o = r.model, a = r.output, i = r.inputs.sources.output;
            for (t = 0; t < e; t++) n = i[t], a[t] = n;
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, r.sumGen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.sources, u = r.output;
            for (flock.clearBuffer(u), n = 0; n < i.length; n++) for (o = i[n].output, t = 0; t < e; t++) u[t] += o[t];
            a.unscaledValue = flock.ugen.lastOutputValue(e, u), r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged = function() {
            "number" == typeof r.inputs.sources.length ? r.gen = r.sumGen : r.gen = r.copyGen, 
            flock.onMulAddInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.sum", {
        rate: "audio",
        inputs: {
            sources: null
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.midiFreq = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = a.a4, u = i.freq, s = i.noteNum, l = a.notesPerOctave, c = r.inputs.note.output, f = r.output;
            for (t = 0, n = 0; t < e; t++, n += a.strides.note) f[t] = o = flock.midiFreq(c[n], u, s, l);
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, f);
        }, r.init = function() {
            r.model.octaveScale = 1 / r.model.notesPerOctave, r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.midiFreq", {
        rate: "control",
        inputs: {
            note: 69
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                a4: {
                    noteNum: 69,
                    freq: 440
                },
                notesPerOctave: 12
            },
            strideInputs: [ "note" ]
        }
    }), flock.ugen.midiAmp = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.velocity.output, u = r.output;
            for (t = 0, n = 0; t < e; t++, n += a.strides.velocity) u[t] = o = i[n] / 127;
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.midiAmp", {
        rate: "control",
        inputs: {
            velocity: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "velocity" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.pan2 = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.output, s = u[0], l = u[1], c = r.inputs, f = c.source.output, d = c.pan.output;
            for (t = 0, n = 0; t < e; t++, n += i.strides.pan) o = f[t], a = .5 * d[n] + .5, 
            l[t] = o * Math.sin(a * flock.HALFPI), s[t] = o * Math.cos(a * flock.HALFPI);
            var p = e - 1;
            i.value[0] = u[0][p], i.value[1] = u[1][p];
        }, r.init = function() {
            r.onInputChanged(), r.model.unscaledValue = r.model.value;
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.pan2", {
        rate: "audio",
        inputs: {
            source: null,
            pan: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: [ 0, 0 ],
                value: [ 0, 0 ]
            },
            tags: [ "flock.ugen.multiChannelOutput" ],
            strideInputs: [ "pan" ],
            numOutputs: 2
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.osc = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u = r.model, s = r.inputs, l = s.freq.output, c = s.phase.output, f = s.table, d = u.tableLen, p = u.tableIncHz, m = u.tableIncRad, g = r.output, h = u.phase;
            for (t = 0, n = 0, o = 0; t < e; t++, n += u.strides.phase, o += u.strides.freq) (a = h + c[n] * m) >= d ? a -= d : a < 0 && (a += d), 
            g[t] = i = r.interpolate(a, f), (h += l[o] * p) >= d ? h -= d : h < 0 && (h += d);
            u.phase = h, u.unscaledValue = i, r.mulAdd(e), u.value = flock.ugen.lastOutputValue(e, g);
        }, r.onInputChanged = function(e) {
            if (flock.ugen.osc.onInputChanged(r), !e || "table" === e) {
                var t = r.model, n = r.inputs.table;
                n.length < 1 && (n = r.inputs.table = flock.ugen.osc.emptyTable), t.tableLen = n.length, 
                t.tableIncHz = t.tableLen / t.sampleRate, t.tableIncRad = t.tableLen / flock.TWOPI;
            }
        }, r.onInputChanged(), r;
    }, flock.ugen.osc.emptyTable = new Float32Array([ 0, 0, 0 ]), flock.ugen.osc.onInputChanged = function(e) {
        e.calculateStrides(), flock.onMulAddInputChanged(e);
    }, flock.ugenDefaults("flock.ugen.osc", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            table: [],
            mul: null,
            add: null
        },
        ugenOptions: {
            interpolation: "linear",
            model: {
                phase: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq", "phase" ]
        },
        tableSize: 8192
    }), flock.ugen.osc.define = function(e, t) {
        var n = e.lastIndexOf("."), r = e.substring(0, n), o = e.substring(n + 1);
        flock.get(r)[o] = function(e, n, r) {
            var o = flock.ugenDefaults("flock.ugen.osc"), a = fluid.merge(null, o, r).tableSize;
            return e.table = flock.fillTable(a, t), flock.ugen.osc(e, n, r);
        }, flock.ugenDefaults(e, flock.ugenDefaults("flock.ugen.osc"));
    }, flock.ugen.osc.define("flock.ugen.sinOsc", flock.tableGenerators.sin), flock.ugen.osc.define("flock.ugen.triOsc", flock.tableGenerators.tri), 
    flock.ugen.osc.define("flock.ugen.sawOsc", flock.tableGenerators.saw), flock.ugen.osc.define("flock.ugen.squareOsc", flock.tableGenerators.square), 
    flock.ugen.sin = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.inputs.freq.output, s = r.inputs.phase.output, l = r.output, c = i.phase, f = i.sampleRate;
            for (t = 0, n = 0, o = 0; t < e; t++, n += i.strides.phase, o += i.strides.freq) l[t] = a = Math.sin(c + s[n]), 
            c += u[o] / f * flock.TWOPI;
            i.phase = c, i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, l);
        }, r.onInputChanged = function() {
            flock.ugen.osc.onInputChanged(r);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.sin", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq", "phase" ]
        }
    }), flock.ugen.lfSaw = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.freq.output, u = r.output, s = a.scale, l = r.inputs.phase.output[0], c = a.phase;
            for (t = 0, n = 0; t < e; t++, n += a.strides.freq) u[t] = o = c + l, (c += i[n] * s) >= 1 ? c -= 2 : c <= -1 && (c += 2);
            a.phase = c, a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged = function() {
            var e = r.model;
            e.freqInc = r.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0, e.phase = 0, r.calculateStrides(), 
            flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.model.scale = 1 / r.options.sampleRate * 2, r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.lfSaw", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                freqInc: 1,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq" ]
        }
    }), flock.ugen.lfPulse = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.inputs, i = r.model, u = a.freq.output, s = i.freqInc, l = a.width.output[0], c = r.output, f = i.scale, d = void 0 !== i.phase ? i.phase : a.phase.output[0];
            for (t = 0, n = 0; t < e; t++, n += s) d >= 1 ? (d -= 1, c[t] = o = l < .5 ? 1 : -1) : c[t] = o = d < l ? 1 : -1, 
            d += u[n] * f;
            i.phase = d, i.unscaledValue = o, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, c);
        }, r.onInputChanged = function() {
            r.model.freqInc = r.inputs.freq.rate === flock.rates.AUDIO ? 1 : 0, flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.model.scale = 1 / r.options.sampleRate, r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.lfPulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            width: .5,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                freqInc: 1,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.impulse = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.inputs, i = r.model, u = r.output, s = a.freq.output, l = i.strides.freq, c = a.phase.output[0], f = i.phase, d = i.scale;
            for (f += c, t = 0, n = 0; t < e; t++, n += l) f >= 1 ? (f -= 1, o = 1) : o = 0, 
            u[t] = o, f += s[n] * d;
            i.phase = f - c, i.unscaledValue = o, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged = function() {
            r.calculateStrides(), flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.model.scale = 1 / r.model.sampleRate, r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.impulse", {
        rate: "audio",
        inputs: {
            freq: 440,
            phase: 0,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                phase: 0,
                scale: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "freq" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = flock.requireModule("Random");
    flock.ugen.dust = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(t) {
            var n, o, a, i, u, s = r.model, l = r.output, c = e.density.output[0];
            for (c !== s.density ? (s.density = c, n = s.threshold = c * s.sampleDur, o = s.scale = n > 0 ? 1 / n : 0) : (n = s.threshold, 
            o = s.scale), u = 0; u < t; u++) i = (a = Math.random()) < n ? a * o : 0, l[u] = i;
            s.unscaledValue = i, r.mulAdd(t), s.value = flock.ugen.lastOutputValue(t, l);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.dust", {
        rate: "audio",
        inputs: {
            density: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                density: 0,
                scale: 0,
                threshold: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.whiteNoise = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.output;
            for (t = 0; t < e; t++) a[t] = n = flock.randomAudioValue();
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.whiteNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    }), flock.ugen.pinkNoise = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = i.state, s = r.a, l = r.p, c = i.offset, f = r.output;
            for (t = 0; t < e; t++) {
                for (a = 0, n = 0; n < u.length; n++) o = Math.random(), u[n] = l[n] * (u[n] - o) + o, 
                a += s[n] * u[n];
                a = 2 * a - c, f[t] = a;
            }
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, f);
        }, r.init = function() {
            r.a = new Float32Array(r.options.coeffs.a), r.p = new Float32Array(r.options.coeffs.p), 
            r.model.state = new Float32Array(r.a.length);
            for (var e = 0; e < r.a.length; e++) r.model.offset += r.a[e];
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.pinkNoise", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                state: 0,
                unscaledValue: 0,
                value: 0,
                offset: 0
            },
            coeffs: {
                a: [ .02109238, .07113478, .68873558 ],
                p: [ .319, .7756, .9613 ]
            }
        }
    }), flock.ugen.lfNoise = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(t) {
            var n, o, a = r.model, i = e.freq.output[0], u = t, s = r.output, l = 0;
            i = i > .001 ? i : .001;
            do {
                for (a.counter <= 0 && (a.counter = a.sampleRate / i, a.counter = a.counter > 1 ? a.counter : 1, 
                "linear" === r.options.interpolation ? (a.start = a.unscaledValue = a.end, a.end = Math.random(), 
                a.ramp = a.ramp = (a.end - a.start) / a.counter) : (a.start = a.unscaledValue = Math.random(), 
                a.ramp = 0)), u -= n = u < a.counter ? u : a.counter, a.counter -= n, o = 0; o < n; o++) s[l] = a.unscaledValue, 
                a.unscaledValue += a.ramp, l++;
            } while (u);
            r.mulAdd(t), a.value = flock.ugen.lastOutputValue(t, s);
        }, r.input = function() {
            r.model.end = Math.random(), r.onInputChanged();
        }, r.input(), r;
    }, flock.ugenDefaults("flock.ugen.lfNoise", {
        rate: "audio",
        inputs: {
            freq: 440,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                counter: 0,
                level: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    }), flock.ugen.random = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.gen = function(e) {
            var t, n, r = o.model, a = o.generator, i = o.output;
            for (t = 0; t < e; t++) i[t] = n = a.uniform(-1, 1);
            r.unscaledValue = n, o.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, i);
        }, o.onInputChanged = function(e) {
            "seed" === e && o.initGenerator(), flock.onMulAddInputChanged(o);
        }, o.initGenerator = function() {
            var t = o.inputs.seed;
            o.generator = t ? new e(t) : new e();
        }, o.init = function() {
            o.initGenerator(), o.calculateStrides(), o.onInputChanged();
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.random", {
        rate: "audio",
        inputs: {
            seed: null,
            mul: null,
            add: null
        }
    }), flock.ugen.random.exponential = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.generator, u = r.output, s = r.inputs.lambda.output, l = r.model.strides.lambda;
            for (t = n = 0; t < e; t++, n += l) u[t] = o = i.exponential(s[n]);
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.exponential", {
        rate: "audio",
        inputs: {
            seed: null,
            lambda: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "lambda" ]
        }
    }), flock.ugen.random.gamma = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.inputs, s = r.generator, l = r.output, c = i.strides.alpha, f = u.alpha.output, d = i.strides.beta, p = u.beta.output;
            for (t = n = o = 0; t < e; t++, n += c, o += d) l[t] = a = s.gamma(f[n], p[o]);
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, l);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.gamma", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 2,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha", "beta" ]
        }
    }), flock.ugen.random.normal = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.output, s = r.inputs, l = r.generator, c = i.strides.mu, f = s.mu.output, d = i.strides.sigma, p = s.sigma.output;
            for (t = n = o = 0; t < e; t++, n += c, o += d) u[t] = a = l.normal(f[n], p[o]);
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.normal", {
        rate: "audio",
        inputs: {
            seed: null,
            mu: 0,
            sigma: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "mu", "sigma" ]
        }
    }), flock.ugen.random.pareto = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.generator, u = r.output, s = r.model.strides.alpha, l = r.inputs.alpha.output;
            for (t = n = 0; t < e; t++, n += s) u[t] = o = i.pareto(l[n]);
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.pareto", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 5,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha" ]
        }
    }), flock.ugen.random.triangular = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.generator, u = r.output, s = r.model.strides.mode, l = r.inputs.mode.output;
            for (t = n = 0; t < e; t++, n += s) u[t] = o = i.triangular(-1, 1, l[n]);
            a.unscaledValue = o, r.mulAdd(e), a.value = flock.ugen.lastOutputValue(e, u);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.triangular", {
        rate: "audio",
        inputs: {
            seed: null,
            mode: .5,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "mode" ]
        }
    }), flock.ugen.random.weibull = function(e, t, n) {
        var r = flock.ugen.random(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.inputs, s = r.generator, l = r.output, c = i.strides.alpha, f = u.alpha.output, d = i.strides.beta, p = u.beta.output;
            for (t = n = o = 0; t < e; t++, n += c, o += d) l[t] = a = s.weibull(f[n], p[o]);
            i.unscaledValue = a, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, l);
        }, r;
    }, flock.ugenDefaults("flock.ugen.random.weibull", {
        rate: "audio",
        inputs: {
            seed: null,
            alpha: 1,
            beta: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            strideInputs: [ "alpha", "beta" ]
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.change = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            for (var t, n = r.model, o = r.inputs.initial.output, a = n.strides.initial, i = r.inputs.target.output, u = n.strides.target, s = r.output, l = n.samplesLeft, c = n.crossfadeLevel, f = 0, d = 0, p = 0; f < e; f++, 
            d += a, p += u) l > 0 ? (t = o[d], l--) : c > 0 ? (t = o[d] * c + i[p] * (1 - c), 
            c -= n.crossfadeStepSize) : t = i[p], s[f] = t;
            n.samplesLeft = l, n.crossfadeLevel = c, n.value = n.unscaledValue = t;
        }, r.onInputChanged = function(e) {
            var t = r.model, n = r.inputs;
            "time" !== e && e || (t.samplesLeft = Math.round(n.time.output[0] * t.sampleRate)), 
            "crossfade" !== e && e || (t.crossfadeStepSize = 1 / Math.round(n.crossfade.output[0] * t.sampleRate), 
            t.crossfadeLevel = n.crossfade.output[0] > 0 ? 1 : 0), r.calculateStrides();
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.change", {
        rate: "audio",
        inputs: {
            initial: 0,
            target: 0,
            time: 0,
            crossfade: 0
        },
        ugenOptions: {
            model: {
                samplesLeft: 0,
                crossfadeStepSize: 0,
                crossfadeLevel: 0,
                unscaledValue: 0,
                value: 0
            },
            strideInputs: [ "initial", "target" ]
        }
    }), flock.ugen.listItem = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i = r.model, u = r.output, s = r.inputs.list, l = s.length - 1, c = r.inputs.index.output;
            for (t = 0, o = 0; t < e; t++, o += i.strides.index) a = Math.round(c[o] * l), a = Math.max(0, a), 
            n = s[a = Math.min(a, l)], u[t] = n;
            i.unscaledValue = n, r.mulAdd(e), i.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.listItem", {
        rate: "control",
        inputs: {
            index: 0,
            list: [ 0 ]
        },
        ugenOptions: {
            strideInputs: [ "index" ]
        }
    }), flock.ugen.sequence = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.inputs.values, i = r.inputs, u = i.freq.output, s = i.loop.output[0], l = r.model, c = l.scale, f = r.output, d = i.start ? Math.round(i.start.output[0]) : 0, p = i.end ? Math.round(i.end.output[0]) : a.length;
            for (void 0 === l.unscaledValue && (t = a[d], l.unscaledValue = void 0 === t ? 0 : t), 
            void 0 === l.nextIdx && (l.nextIdx = d), n = 0, o = 0; n < e; n++, o += l.strides.freq) {
                if (l.nextIdx >= p) {
                    if (!(s > 0)) {
                        f[n] = l.unscaledValue;
                        continue;
                    }
                    l.nextIdx = d;
                }
                f[n] = l.unscaledValue = a[l.nextIdx], l.phase += u[o] * c, l.phase >= 1 && (l.phase = 0, 
                l.nextIdx++);
            }
            r.mulAdd(e), l.value = flock.ugen.lastOutputValue(e, f);
        }, r.onInputChanged = function() {
            r.model.scale = r.rate !== flock.rates.DEMAND ? r.model.sampleDur : 1, r.inputs.values && 0 !== r.inputs.values.length || !r.inputs.list || (flock.log.warn("The 'list' input to flock.ugen.sequence is deprecated. Use 'values' instead."), 
            r.inputs.values = r.inputs.list), r.inputs.values || (r.inputs.values = []), r.calculateStrides(), 
            flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.sequence", {
        rate: "control",
        inputs: {
            start: 0,
            freq: 1,
            loop: 0,
            values: []
        },
        ugenOptions: {
            model: {
                unscaledValue: void 0,
                value: 0,
                phase: 0
            },
            strideInputs: [ "freq" ]
        }
    }), flock.ugen.sequencer = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o = r.model, a = r.options, i = a.resetOnNext, u = r.output, s = r.inputs.loop.output[0], l = r.inputs.durations, c = r.inputs.values;
            for (o.shouldValidateSequences && (o.shouldValidateSequences = !1, flock.ugen.sequencer.validateSequences(l, c)), 
            t = 0; t < e; t++) 0 !== c.length && 0 !== l.length ? (o.samplesRemaining <= 0 ? o.idx < l.length - 1 ? (o.idx++, 
            n = flock.ugen.sequencer.nextStage(l, c, i, o)) : s > 0 ? (o.idx = 0, n = flock.ugen.sequencer.nextStage(l, c, i, o)) : n = a.holdLastValue ? o.unscaledValue : 0 : (n = c[o.idx], 
            o.samplesRemaining--), u[t] = n) : u[t] = n = 0;
            o.unscaledValue = n, r.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, u);
        }, r.onInputChanged = function(e) {
            var t = r.model, n = r.inputs;
            "durations" !== e && n.durations === t.prevDurations || (t.idx = 0, flock.ugen.sequencer.calcDurationsSamps(n.durations, r.model), 
            flock.ugen.sequencer.validateInput("durations", r), t.prevDurations = n.durations), 
            "values" !== e && n.values === t.prevValues || (t.idx = 0, flock.ugen.sequencer.validateInput("values", r), 
            t.prevValues = n.values), r.model.shouldValidateSequences = !0, flock.onMulAddInputChanged(r);
        }, r.init = function() {
            r.onInputChanged();
        }, r.init(), r;
    }, flock.ugen.sequencer.validateInput = function(e, t) {
        var n = t.inputs[e];
        n && flock.isIterable(n) || flock.fail("No " + e + " array input was specified for flock.ugen.sequencer: " + fluid.prettyPrintJSON(t.options.ugenDef));
    }, flock.ugen.sequencer.validateSequences = function(e, t) {
        e.length !== t.length && flock.fail("Mismatched durations and values array lengths for flock.ugen.sequencer. Durations: " + fluid.prettyPrintJSON(e) + ", values: " + fluid.prettyPrintJSON(t));
    }, flock.ugen.sequencer.calcDurationsSamps = function(e, t) {
        t.samplesRemaining = Math.floor(e[t.idx] * t.sampleRate);
    }, flock.ugen.sequencer.nextStage = function(e, t, n, r) {
        return flock.ugen.sequencer.calcDurationsSamps(e, r), r.samplesRemaining--, n ? 0 : t[r.idx];
    }, flock.ugenDefaults("flock.ugen.sequencer", {
        rate: "audio",
        inputs: {
            durations: [],
            values: [],
            loop: 0
        },
        ugenOptions: {
            model: {
                idx: 0,
                samplesRemaining: 0,
                unscaledValue: 0,
                value: 0,
                prevDurations: [],
                prevValues: []
            },
            resetOnNext: !1,
            holdLastvalue: !1
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    flock.ugen.valueChangeTrigger = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a = r.model, i = r.inputs.source.output, u = r.output;
            for (t = 0, n = 0; t < e; t++, n += a.strides.source) o = i[n], u[t] = o !== a.prevVal ? 1 : 0, 
            a.prevVal = o;
            a.value = a.unscaledValue = o;
        }, r.onInputChanged = function(e) {
            r.calculateStrides(), "source" === e && r.options.triggerOnSetSameValue && (r.model.prevVal = null);
        }, r.calculateStrides(), r;
    }, flock.ugenDefaults("flock.ugen.valueChangeTrigger", {
        rate: "control",
        inputs: {
            source: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevVal: 0
            },
            triggerOnSetSameValue: !0,
            strideInputs: [ "source" ]
        }
    }), flock.ugen.inputChangeTrigger = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u = r.model, s = r.inputs.source.output, l = u.strides.source, c = r.inputs.duration.output, f = u.strides.duration, d = u.prevDur, p = r.output;
            for (t = n = o = 0; t < e; t++, n += l, o += f) a = s[n], (i = c[o]) !== d && (u.prevDur = i, 
            u.remainingOpenSamples = a > 0 ? i > 0 ? u.sampleRate * i : 1 : 0), u.remainingOpenSamples > 0 ? (p[t] = a, 
            u.remainingOpenSamples--) : p[t] = 0;
            u.value = u.unscaledValue = flock.ugen.lastOutputValue(e, p);
        }, r.onInputChanged = function(e) {
            r.calculateStrides(), "source" === e && (r.model.prevDur = null);
        }, r.calculateStrides(), r;
    }, flock.ugenDefaults("flock.ugen.inputChangeTrigger", {
        rate: "control",
        inputs: {
            source: 0,
            duration: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                prevDuration: 0,
                remainingOpenSamples: 0
            },
            strideInputs: [ "source", "duration" ]
        }
    }), flock.ugen.triggerCallback = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n, o, a, i, u = r.model, s = r.options, l = r.output, c = r.inputs, f = u.strides.trigger, d = u.strides.source, p = c.trigger.output, m = c.source.output, g = s.callback, h = g.func, v = g.args, y = g.this, k = u.lastArgIdx, b = u.prevTrig;
            for (t = n = o = 0; t < e; t++, n += f, o += d) a = p[n], i = m[o], a > 0 && b <= 0 && h && (v[k] = i, 
            h.apply(y, v)), l[t] = i, b = a;
            u.prevTrig = b, u.value = u.unscaledValue = i;
        }, r.onInputChanged = function() {
            var e = r.options, t = r.model, n = e.callback, o = n.funcName;
            if (o) n.func = fluid.getGlobalValue(o); else if (n.this && n.method) {
                if ("string" != typeof n.this) throw new Error("flock.ugen.triggerCallback doesn't support raw 'this' objects.Use a global key path instead.");
                n.this = "string" == typeof n.this ? fluid.getGlobalValue(n.this) : n.this, n.func = fluid.get(n.this, n.method);
            }
            t.lastArgIdx = n.args.length, r.calculateStrides();
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.triggerCallback", {
        rate: "audio",
        inputs: {
            source: 0,
            trigger: 0
        },
        ugenOptions: {
            model: {
                unscaledValue: 0,
                value: 0,
                funcName: void 0,
                lastArgIdx: 0
            },
            callback: {
                this: void 0,
                method: void 0,
                func: void 0,
                args: []
            },
            strideInputs: [ "source", "trigger" ]
        }
    }), flock.ugen.t2a = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function() {
            for (var e, t = r.model, n = r.inputs.source.output[0], o = 0 | r.inputs.offset.output[0], a = r.output, i = 0; i < a.length; i++) a[i] = e = 0;
            n > 0 && t.prevTrig <= 0 && (a[o] = e = n), t.prevTrig = n, t.value = t.unscaledValue = e;
        }, r;
    }, flock.ugenDefaults("flock.ugen.t2a", {
        rate: "audio",
        inputs: {
            source: null,
            offset: 0
        },
        ugenOptions: {
            model: {
                prevTrig: 0,
                unscaledValue: 0,
                value: 0
            }
        }
    });
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.view"), flock.view.scope = function(t, n) {
        var r = {
            model: n || {
                values: []
            },
            canvas: e(t)[0]
        };
        return r.refreshView = function() {
            var e, t, n, o = r.ctx, a = r.model.height, i = r.model.halfHeight, u = r.model.width, s = r.model.values, l = s.length, c = r.model.scaleX * (u / l);
            for (o.clearRect(0, 0, u, a), o.beginPath(), e = 0; e < l; e++) t = e * c, n = s[e] * r.model.scaleY * i + i, 
            o.lineTo(t, n);
            o.stroke();
        }, r.init = function() {
            r.ctx = r.canvas.getContext("2d"), r.ctx.fillStyle = r.model.fill || r.ctx.fillStyle, 
            r.ctx.strokeStyle = r.model.strokeColor || r.ctx.strokeStyle, r.ctx.lineWidth = r.model.strokeWidth || r.ctx.lineWidth, 
            r.model.min = r.model.min || -1, r.model.max = r.model.max || 1, r.model.height = r.canvas.height, 
            r.model.halfHeight = r.model.height / 2, r.model.width = r.canvas.width, r.model.scaleX = r.model.scaleX || r.model.scale || 1, 
            r.model.scaleY = r.model.scaleY || r.model.scale || 1, r.refreshView();
        }, r.init(), r;
    }, flock.view.drawBuffer = function(t, n) {
        (n = n || {}).height = n.height || 200, n.width = n.width || 1e3;
        var r = fluid.stringTemplate(flock.view.drawBuffer.markupTemplate, n), o = e(r);
        return flock.view.scope(o[0], {
            values: t
        }), o;
    }, flock.view.drawBuffer.markupTemplate = "<canvas height='%height' width='%width'></canvas>";
}();

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    "use strict";
    var e = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.ugen"), flock.ugen.scope = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.gen = function(e) {
            var t, n = r.model, o = r.inputs.source.output, a = n.spf, i = n.bufIdx, u = n.scope.values;
            for (t = 0; t < e; t++) u[i] = o[t], i < a ? i += 1 : (i = 0, r.scopeView.refreshView());
            n.bufIdx = i, n.value = n.unscaledValue = flock.ugen.lastOutputValue(e, o);
        }, r.onInputChanged = function() {
            r.output = r.inputs.source.output;
        }, r.init = function() {
            r.model.spf = Math.round(r.model.sampleRate / r.options.fps), r.model.bufIdx = 0, 
            r.model.scope = r.options.styles, r.model.scope.values = new Float32Array(r.model.spf), 
            r.scopeView = flock.view.scope(r.options.canvas, r.model.scope), r.onInputChanged(), 
            r.scopeView.refreshView();
        }, r.init(), r;
    }, flock.ugenDefaults("flock.ugen.scope", {
        rate: "audio",
        inputs: {
            source: null
        },
        ugenOptions: {
            fps: 60,
            styles: {
                strokeColor: "#777777",
                strokeWidth: 1
            }
        }
    }), flock.ugen.mouse = {}, flock.ugen.mouse.cursor = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.exponentialGen = function(e) {
            var t, n, r = o.model, a = flock.ugen.mouse.cursor.normalize(o.target, r), i = r.movingAvg, u = o.inputs.lag.output[0], s = o.inputs.add.output[0], l = o.inputs.mul.output[0], c = r.lagCoef, f = o.output;
            for (u !== c && (c = 0 === u ? 0 : Math.exp(flock.LOG001 / (u * r.sampleRate)), 
            r.lagCoef = c), t = 0; t < e; t++) n = l + s, i = (a = Math.pow(n / s, a) * s) + c * (i - a), 
            f[t] = i;
            r.movingAvg = i, r.value = r.unscaledValue = i;
        }, o.linearGen = function(e) {
            var t, n = o.model, r = flock.ugen.mouse.cursor.normalize(o.target, n), a = n.movingAvg, i = o.inputs.lag.output[0], u = o.inputs.add.output[0], s = o.inputs.mul.output[0], l = n.lagCoef, c = o.output;
            for (i !== l && (l = 0 === i ? 0 : Math.exp(flock.LOG001 / (i * n.sampleRate)), 
            n.lagCoef = l), t = 0; t < e; t++) a = r + l * (a - r), c[t] = a * s + u;
            n.movingAvg = n.unscaledValue = a, n.value = flock.ugen.lastOutputValue(e, c);
        }, o.noInterpolationGen = function(e) {
            var t, n = o.model, r = o.output, a = flock.ugen.mouse.cursor.normalize(o.target, n);
            for (t = 0; t < e; t++) r[t] = a * o.inputs.mul.output[0] + o.inputs.add.output[0];
            n.value = n.unscaledValue = flock.ugen.lastOutputValue(e, r);
        }, o.moveListener = function(e) {
            var t = o.model;
            t.mousePosition = e[t.eventProp];
        }, o.overListener = function() {
            o.model.isWithinTarget = !0;
        }, o.outListener = function() {
            var e = o.model;
            e.isWithinTarget = !1, e.mousePosition = 0;
        }, o.downListener = function() {
            o.model.isMouseDown = !0;
        }, o.upListener = function() {
            var e = o.model;
            e.isMouseDown = !1, e.mousePosition = 0;
        }, o.moveWhileDownListener = function(e) {
            o.model.isMouseDown && o.moveListener(e);
        }, o.bindEvents = function() {
            var e = o.target, t = o.moveListener;
            o.options.onlyOnMouseDown && (e.mousedown(o.downListener), e.mouseup(o.upListener), 
            t = o.moveWhileDownListener), e.mouseover(o.overListener), e.mouseout(o.outListener), 
            e.mousemove(t);
        }, o.onInputChanged = function() {
            flock.onMulAddInputChanged(o);
            var e = o.options.interpolation;
            o.gen = "none" === e ? o.noInterpolationGen : "exponential" === e ? o.exponentialGen : o.linearGen;
        }, o.init = function() {
            var t = o.model, n = o.options, r = n.axis, a = e(n.target || window);
            "x" === r || "width" === r || "horizontal" === r ? (t.eventProp = "clientX", t.offsetProp = "left", 
            t.dimension = "width") : (t.eventProp = "clientY", t.offsetProp = "top", t.dimension = "height"), 
            o.target = a, t.mousePosition = 0, t.movingAvg = 0, o.bindEvents(), o.onInputChanged();
        }, o.init(), o;
    }, flock.ugen.mouse.cursor.normalize = function(e, t) {
        if (!t.isWithinTarget) return 0;
        var n = e[t.dimension](), r = e.offset(), o = t.mousePosition;
        return r && (o -= r[t.offsetProp]), o / n;
    }, flock.ugenDefaults("flock.ugen.mouse.cursor", {
        rate: "control",
        inputs: {
            lag: .5,
            add: 0,
            mul: 1
        },
        ugenOptions: {
            axis: "x",
            interpolation: "linear",
            model: {
                mousePosition: 0,
                movingAvg: 0,
                value: 0
            }
        }
    }), flock.ugen.mouse.click = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.gen = function(e) {
            var t, n = o.output, r = o.model;
            for (t = 0; t < e; t++) n[t] = r.unscaledValue;
            o.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, n);
        }, o.mouseDownListener = function() {
            o.model.unscaledValue = 1;
        }, o.mouseUpListener = function() {
            o.model.unscaledValue = 0;
        }, o.init = function() {
            var t = o.model;
            t.target = e(o.options.target ? o.options.target : window), t.target.mousedown(o.mouseDownListener), 
            t.target.mouseup(o.mouseUpListener), o.onInputChanged();
        }, o.onInputChanged = function() {
            flock.onMulAddInputChanged(o);
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.mouse.click", {
        rate: "control"
    }), flock.ugen.mediaIn = function(t, n, r) {
        var o = flock.ugen(t, n, r);
        return o.gen = function(e) {
            for (var t, n = o.model, r = o.output, a = o.bus, i = 0; i < e; i++) r[i] = t = a[i];
            n.unscaledValue = t, o.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, r);
        }, o.onInputChanged = function() {
            flock.onMulAddInputChanged(o);
        }, o.init = function() {
            var t = o.enviro.audioSystem.nativeNodeManager, n = e(o.options.element), r = t.createMediaElementInput(n[0]);
            o.bus = o.options.buses[r], o.onInputChanged(), flock.platform.browser.safari && flock.platform.browser.majorVersionNumber < 601 ? flock.log.warn("MediaElementSourceNode only works on Safari 9 or higher. For more information, see https://bugs.webkit.org/show_bug.cgi?id=84743 and https://bugs.webkit.org/show_bug.cgi?id=125031") : flock.platform.isAndroid && flock.log.warn("MediaElementSourceNode does not work on Android. For more information, see https://code.google.com/p/chromium/issues/detail?id=419446");
        }, o.init(), o;
    }, flock.ugenDefaults("flock.ugen.mediaIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        },
        ugenOptions: {
            element: "audio"
        }
    });
}();